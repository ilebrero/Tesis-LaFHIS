<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
  <meta charset="UTF-8" /> 
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  
  <title>ISSTA 2020 – Author Index</title>

  <style>
     body {
       font-family: Helvetica, Arial, sans-serif;
       color: #444444;
       background: transparent;
     }
     a, a:link, a:visited {
       text-decoration: none;
       color: #285A86;
     }
     a:hover {
       color: #3C88CB;
       cursor: pointer;
     }
     a, img {
       border-style: none;
     }
     h4 {
       font-size: 1.2em;
     }
  </style>

  </head>
  <body>
    <div style="text-align:center;" >
      <a style="color: blue;"
         href="https://conf.researchr.org/home/issta-2020" >
        <span style="font-weight: bold; font-size: 300%;">ISSTA 2020</span>

        <br />
        <span style="font-weight: bold; font-size: 150%;">29th ACM SIGSOFT International Symposium on Software Testing and Analysis (ISSTA 2020)</span>

      </a>
    </div>

<script>
  function toggle(pId) {
    var e=document.getElementById(pId);
    if (!e) return;
    if (e.style.display == "none") {
      e.style.display = "block"
    } else {
      e.style.display = "none"
    }
    return;
  }
</script>
<hr style="width: 100%; height: 2px;" />
<div class="vevent" style="font-size: small; text-align: center;">
  <span class="summary">29th ACM SIGSOFT International Symposium on Software Testing and Analysis (ISSTA 2020)</span>, 
  <span class="dtstart">July 18–22, 2020<span class="value-title" title="2020-07-18"></span></span>, 
  <span class="dtend"><span class="value-title" title="2020-07-22"></span></span>
  <span class="location">Virtual Event, USA</span>
</div>
<hr style="width: 100%; height: 2px;" />
<table style="text-align: left; vertical-align: middle; width: 100%; border-spacing: 0;">
  <tr>
    <td>
      <h1 style="margin-top: 7px; margin-bottom: 7px;">ISSTA 2020 – Author Index</h1>
    </td>
    <td style="vertical-align: middle; text-align: right;">
        <a title="Table of Contents"  href="index.html"       >Contents</a> - 
              <a title="ToC with Abstracts" href="index-all.html"   >Abstracts</a> - 
              <a title="Author Index"       href="index-auth.html"  >Authors</a> 
        <br /> 
    </td>
  </tr>
</table>
<!-- END HEADER -->

<p>
<a href="#A">A</a>
<a href="#B">B</a>
<a href="#C">C</a>
<a href="#D">D</a>
<a href="#E">E</a>
<a href="#F">F</a>
<a href="#G">G</a>
<a href="#H">H</a>
<a href="#J">J</a>
<a href="#K">K</a>
<a href="#L">L</a>
<a href="#M">M</a>
<a href="#N">N</a>
<a href="#O">O</a>
<a href="#P">P</a>
<a href="#Q">Q</a>
<a href="#R">R</a>
<a href="#S">S</a>
<a href="#T">T</a>
<a href="#V">V</a>
<a href="#W">W</a>
<a href="#X">X</a>
<a href="#Y">Y</a>
<a href="#Z">Z</a>
</p>

<table>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;"><a id="A"> </a>Abdessalem, Raja Ben
  </td>
  <td>
    <span onclick="toggle('issta20main-id83-p-abdessalemrajaben')" title="Automated Repair of Feature Interaction Failures in Automated Driving Systems  --  Raja Ben Abdessalem, Annibale Panichella, Shiva Nejati, Lionel C. Briand, and Thomas Stifter" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Automated Repair of Feature ..."</span></small></a>
    </span>

    <span id="issta20main-id83-p-abdessalemrajaben"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id83-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id83-p-abdessalemrajaben')" 
      >
        <a id="issta20main-id83-p-titleabdessalemrajaben" >
          <span style="font-size: 100%">
            Automated Repair of Feature Interaction Failures in Automated Driving Systems
          </span>
        </a>
      </span>
      <br />
      Raja Ben Abdessalem, Annibale Panichella, Shiva Nejati, Lionel C. Briand, and Thomas Stifter<br />
      <i><small>(University of Luxembourg, Luxembourg; Delft University of Technology, Netherlands; University of Ottawa, Canada; IEE, Luxembourg)</small></i><br />
      <span id="issta20main-id83-p-absabdessalemrajaben" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              In the past years, several automated repair strategies have been proposed to fix bugs in individual software programs without any human intervention. There has been, however, little work on how automated repair techniques can resolve failures that arise at the system-level and are caused by undesired interactions among different system components or functions. Feature interaction failures are common in complex systems such as autonomous cars that are typically built as a composition of independent features (i.e., units of functionality). In this paper, we propose a repair technique to automatically resolve undesired feature interaction failures in automated driving systems (ADS) that lead to the violation of system safety requirements. Our repair strategy achieves its goal by (1) localizing faults spanning several lines of code, (2) simultaneously resolving multiple interaction failures caused by independent faults, (3) scaling repair strategies from the unit-level to the system-level, and (4) resolving failures based on their order of severity. We have evaluated our approach using two industrial ADS containing four features. Our results show that our repair strategy resolves the undesired interaction failures in these two systems in less than 16h and outperforms existing automated repair techniques.<br/>
        <br />
        <a href="issta20main-id83-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Afzal, Wasif  </td>
  <td>
    <span onclick="toggle('issta20main-id63-p-afzalwasif')" title="Intermittently Failing Tests in the Embedded Systems Domain  --  Per Erik Strandberg, Thomas J. Ostrand, Elaine J. Weyuker, Wasif Afzal, and Daniel Sundmark" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Intermittently Failing Tests ..."</span></small></a>
    </span>

    <span id="issta20main-id63-p-afzalwasif"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id63-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id63-p-afzalwasif')" 
      >
        <a id="issta20main-id63-p-titleafzalwasif" >
          <span style="font-size: 100%">
            Intermittently Failing Tests in the Embedded Systems Domain
          </span>
        </a>
      </span>
      <br />
      Per Erik Strandberg, Thomas J. Ostrand, Elaine J. Weyuker, Wasif Afzal, and Daniel Sundmark<br />
      <i><small>(Westermo Network Technologies, Sweden; Mälardalen University, Sweden; University of Central Florida, USA)</small></i><br />
      <span id="issta20main-id63-p-absafzalwasif" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Software testing is sometimes plagued with intermittently failing tests and finding the root causes of such failing tests is often difficult. This problem has been widely studied at the unit testing level for open source software, but there has been far less investigation at the system test level, particularly the testing of industrial embedded systems. This paper describes our investigation of the root causes of intermittently failing tests in the embedded systems domain, with the goal of better understanding, explaining and categorizing the underlying faults. The subject of our investigation is a currently-running industrial embedded system, along with the system level testing that was performed. We devised and used a novel metric for classifying test cases as intermittent. From more than a half million test verdicts, we identified intermittently and consistently failing tests, and identified their root causes using multiple sources. We found that about 1-3% of all test cases were intermittently failing. From analysis of the case study results and related work, we identified nine factors associated with test case intermittence. We found that a fix for a consistently failing test typically removed a larger number of failures detected by other tests than a fix for an intermittent test. We also found that more effort was usually needed to identify fixes for intermittent tests than for consistent tests. An overlap between root causes leading to intermittent and consistent tests was identified. Many root causes of intermittence are the same in industrial embedded systems and open source software. However, when comparing unit testing to system level testing, especially for embedded systems, we observed that the test environment itself is often the cause of intermittence.<br/>
        <br />
        <a href="issta20main-id63-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Alhanahnah, Mohannad  </td>
  <td>
    <span onclick="toggle('issta20main-id143-p-alhanahnahmohannad')" title="Scalable Analysis of Interaction Threats in IoT Systems  --  Mohannad Alhanahnah, Clay Stevens, and Hamid Bagheri" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Scalable Analysis of Interaction ..."</span></small></a>
    </span>

    <span id="issta20main-id143-p-alhanahnahmohannad"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id143-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id143-p-alhanahnahmohannad')" 
      >
        <a id="issta20main-id143-p-titlealhanahnahmohannad" >
          <span style="font-size: 100%">
            Scalable Analysis of Interaction Threats in IoT Systems
          </span>
        </a>
      </span>
      <br />
      Mohannad Alhanahnah, Clay Stevens, and Hamid Bagheri<br />
      <i><small>(University of Nebraska-Lincoln, USA)</small></i><br />
      <span id="issta20main-id143-p-absalhanahnahmohannad" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              The ubiquity of Internet of Things (IoT) and our growing reliance on IoT apps are leaving us more vulnerable to safety and security threats than ever before. Many of these threats are manifested at the interaction level, where undesired or malicious coordinations between apps and physical devices can lead to intricate safety and security issues. This paper presents IoTCOM, an approach to automatically discover such hidden and unsafe interaction threats in a compositional and scalable fashion. It is backed with auto-mated program analysis and formally rigorous violation detection engines. IoTCOM relies on program analysis to automatically infer the relevant app&#8217;s behavior. Leveraging a novel strategy to trim the extracted app&#8217;s behavior prior to translating them to analyzable formal specifications,IoTCOM mitigates the state explosion associated with formal analysis. Our experiments with numerous bundles of real-world IoT apps have corroborated IoTCOM&#8217;s ability to effectively detect a broad spectrum of interaction threats triggered through cyber and physical channels, many of which were previously unknown, and to significantly outperform the existing techniques in terms of scalability.<br/>
        <br />
        <a href="issta20main-id143-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
          <span style="font-size: 80%; color: blue;"> 
            <img width="20" src="../images/award.svg" alt="" />
            ACM SIGSOFT Distinguished Paper Award</span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Araujo Rodriguez, Luis Gustavo  </td>
  <td>
    <span onclick="toggle('issta20doc-p3-p-araujorodriguezluisgustavo')" title="Program-Aware Fuzzing for MQTT Applications  --  Luis Gustavo Araujo Rodriguez and Daniel Macêdo Batista" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20-DOC: "Program-Aware Fuzzing for ..."</span></small></a>
    </span>

    <span id="issta20doc-p3-p-araujorodriguezluisgustavo"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20doc-p3-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20doc-p3-p-araujorodriguezluisgustavo')" 
      >
        <a id="issta20doc-p3-p-titlearaujorodriguezluisgustavo" >
          <span style="font-size: 100%">
            Program-Aware Fuzzing for MQTT Applications
          </span>
        </a>
      </span>
      <br />
      Luis Gustavo Araujo Rodriguez and Daniel Macêdo Batista<br />
      <i><small>(University of São Paulo, Brazil)</small></i><br />
      <span id="issta20doc-p3-p-absaraujorodriguezluisgustavo" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Over the last few years, MQTT applications have been widely exposed to vulnerabilities because of their weak protocol implementations. For our preliminary research, we conducted background studies to: (1) determine the main cause of vulnerabilities in MQTT applications; and (2) analyze existing MQTT-based testing frameworks. Our preliminary results confirm that MQTT is most susceptible to malformed packets, and its existing testing frameworks are based on blackbox fuzzing, meaning vulnerabilities are difficult and time-consuming to find. Thus, the aim of my research is to study and develop effective fuzzing strategies for the MQTT protocol, thereby contributing to the development of more robust MQTT applications in IoT and Smart Cities.<br/>
        <br />
        <a href="issta20doc-p3-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;"><a id="B"> </a>Bagheri, Hamid
  </td>
  <td>
    <span onclick="toggle('issta20main-id143-p-bagherihamid')" title="Scalable Analysis of Interaction Threats in IoT Systems  --  Mohannad Alhanahnah, Clay Stevens, and Hamid Bagheri" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Scalable Analysis of Interaction ..."</span></small></a>
    </span>

    <span id="issta20main-id143-p-bagherihamid"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id143-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id143-p-bagherihamid')" 
      >
        <a id="issta20main-id143-p-titlebagherihamid" >
          <span style="font-size: 100%">
            Scalable Analysis of Interaction Threats in IoT Systems
          </span>
        </a>
      </span>
      <br />
      Mohannad Alhanahnah, Clay Stevens, and Hamid Bagheri<br />
      <i><small>(University of Nebraska-Lincoln, USA)</small></i><br />
      <span id="issta20main-id143-p-absbagherihamid" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              The ubiquity of Internet of Things (IoT) and our growing reliance on IoT apps are leaving us more vulnerable to safety and security threats than ever before. Many of these threats are manifested at the interaction level, where undesired or malicious coordinations between apps and physical devices can lead to intricate safety and security issues. This paper presents IoTCOM, an approach to automatically discover such hidden and unsafe interaction threats in a compositional and scalable fashion. It is backed with auto-mated program analysis and formally rigorous violation detection engines. IoTCOM relies on program analysis to automatically infer the relevant app&#8217;s behavior. Leveraging a novel strategy to trim the extracted app&#8217;s behavior prior to translating them to analyzable formal specifications,IoTCOM mitigates the state explosion associated with formal analysis. Our experiments with numerous bundles of real-world IoT apps have corroborated IoTCOM&#8217;s ability to effectively detect a broad spectrum of interaction threats triggered through cyber and physical channels, many of which were previously unknown, and to significantly outperform the existing techniques in terms of scalability.<br/>
        <br />
        <a href="issta20main-id143-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
          <span style="font-size: 80%; color: blue;"> 
            <img width="20" src="../images/award.svg" alt="" />
            ACM SIGSOFT Distinguished Paper Award</span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Bartocci, Ezio  </td>
  <td>
    <span onclick="toggle('issta20tool-id22-p-bartocciezio')" title="CPSDebug: A Tool for Explanation of Failures in Cyber-Physical Systems  --  Ezio Bartocci, Niveditha Manjunath, Leonardo Mariani, Cristinel Mateis, Dejan Ničković, and Fabrizio Pastore" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20-TOOL: "CPSDebug: A Tool for Explanation ..."</span></small></a>
    </span>

    <span id="issta20tool-id22-p-bartocciezio"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20tool-id22-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20tool-id22-p-bartocciezio')" 
      >
        <a id="issta20tool-id22-p-titlebartocciezio" >
          <span style="font-size: 100%">
            CPSDebug: A Tool for Explanation of Failures in Cyber-Physical Systems
          </span>
        </a>
      </span>
      <br />
      Ezio Bartocci, Niveditha Manjunath, Leonardo Mariani, Cristinel Mateis, Dejan Ničković, and Fabrizio Pastore<br />
      <i><small>(TU Vienna, Austria; Austrian Institute of Technology, Austria; University of Milano-Bicocca, Italy; University of Luxembourg, Luxembourg)</small></i><br />
      <span id="issta20tool-id22-p-absbartocciezio" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Debugging Cyber-Physical System models is often challenging, as it requires identifying a potentially long, complex and heterogenous combination of events that resulted in a violation of the expected behavior of the system. In this paper we present CPSDebug, a tool for supporting designers in the debugging of failures in MATLAB Simulink/Stateflow models. CPSDebug implements a gray-box approach that combines testing, specification mining, and failure analysis to identify the causes of failures and explain their propagation in time and space. The evaluation of the tool, based on multiple usage scenarios and faults and direct feedback from engineers, shows that CPSDebug can effectively aid engineers during debugging tasks.<br/>
        <br />
        <a href="issta20tool-id22-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Bell, Jonathan  </td>
  <td>
    <span onclick="toggle('issta20main-id166-p-belljonathan')" title="Debugging the Performance of Maven’s Test Isolation: Experience Report  --  Pengyu Nie, Ahmet Celik, Matthew Coley, Aleksandar Milicevic, Jonathan Bell, and Milos Gligoric" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Debugging the Performance ..."</span></small></a>
    </span>

    <span id="issta20main-id166-p-belljonathan"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id166-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id166-p-belljonathan')" 
      >
        <a id="issta20main-id166-p-titlebelljonathan" >
          <span style="font-size: 100%">
            Debugging the Performance of Maven’s Test Isolation: Experience Report
          </span>
        </a>
      </span>
      <br />
      Pengyu Nie, Ahmet Celik, Matthew Coley, <a href="https://aleksandarmilicevic.github.io/" target="_blank">Aleksandar Milicevic</a>, Jonathan Bell, and <a href="http://users.ece.utexas.edu/~gligoric/" target="_blank">Milos Gligoric</a><br />
      <i><small>(University of Texas at Austin, USA; Facebook, USA; George Mason University, USA; Microsoft, USA)</small></i><br />
      <span id="issta20main-id166-p-absbelljonathan" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Testing is the most common approach used in industry for checking software correctness. Developers frequently practice reliable testing-executing individual tests in isolation from each other-to avoid test failures caused by test-order dependencies and shared state pollution (e.g., when tests mutate static fields). A common way of doing this is by running each test as a separate process. Unfortunately, this is known to introduce substantial overhead. This experience report describes our efforts to better understand the sources of this overhead and to create a system to confirm the minimal overhead possible. We found that different build systems use different mechanisms for communicating between these multiple processes, and that because of this design decision, running tests with some build systems could be faster than with others. Through this inquiry we discovered a significant performance bug in Apache Maven&#8217;s test running code, which slowed down test execution by on average 350 milliseconds per-test when compared to a competing build system, Ant. When used for testing real projects, this can result in a significant reduction in testing time. We submitted a patch for this bug which has been integrated into the Apache Maven build system, and describe our ongoing efforts to improve Maven&#8217;s test execution tooling.<br/>
        <br />
        <a href="issta20main-id166-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Bezzo, Nicola  </td>
  <td>
    <span onclick="toggle('issta20main-id108-p-bezzonicola')" title="Feasible and Stressful Trajectory Generation for Mobile Robots  --  Carl Hildebrandt, Sebastian Elbaum, Nicola Bezzo, and Matthew B. Dwyer" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Feasible and Stressful Trajectory ..."</span></small></a>
    </span>

    <span id="issta20main-id108-p-bezzonicola"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id108-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id108-p-bezzonicola')" 
      >
        <a id="issta20main-id108-p-titlebezzonicola" >
          <span style="font-size: 100%">
            Feasible and Stressful Trajectory Generation for Mobile Robots
          </span>
        </a>
      </span>
      <br />
      Carl Hildebrandt, Sebastian Elbaum, Nicola Bezzo, and Matthew B. Dwyer<br />
      <i><small>(University of Virginia, USA)</small></i><br />
      <span id="issta20main-id108-p-absbezzonicola" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              While executing nominal tests on mobile robots is required for their validation, such tests may overlook faults that arise under trajectories that accentuate certain aspects of the robot&#39;s behavior. Uncovering such stressful trajectories is challenging as the input space for these systems, as they move, is extremely large, and the relation between a planned trajectory and its potential to induce stress can be subtle. To address this challenge we propose a framework that 1) integrates kinematic and dynamic physical models of the robot into the automated trajectory generation in order to generate valid trajectories, and 2) incorporates a parameterizable scoring model to efficiently generate physically valid yet stressful trajectories for a broad range of mobile robots. We evaluate our approach on four variants of a state-of-the-art quadrotor in a racing simulator. We find that, for non-trivial length trajectories, the incorporation of the kinematic and dynamic model is crucial to generate any valid trajectory, and that the approach with the best hand-crafted scoring model and with a trained scoring model can cause on average a 55.9% and 41.3% more stress than a random selection among valid trajectories. A follow-up study shows that the approach was able to induce similar stress on a deployed commercial quadrotor, with trajectories that deviated up to 6m from the intended ones.<br/>
        <br />
        <a href="issta20main-id108-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
      <a href="https://hildebrandt-carl.github.io/RobotTestGenerationArtifact/"><img width="15" src="../images/tool.png" alt="" /><span style="font-size: 90%"> Info</span></a>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_available_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Available</span></a>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_evaluated_reusable_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Reusable</span></a>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_evaluated_functional_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Functional</span></a>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Briand, Lionel C.  </td>
  <td>
    <span onclick="toggle('issta20main-id83-p-briandlionelc')" title="Automated Repair of Feature Interaction Failures in Automated Driving Systems  --  Raja Ben Abdessalem, Annibale Panichella, Shiva Nejati, Lionel C. Briand, and Thomas Stifter" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Automated Repair of Feature ..."</span></small></a>
    </span>

    <span id="issta20main-id83-p-briandlionelc"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id83-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id83-p-briandlionelc')" 
      >
        <a id="issta20main-id83-p-titlebriandlionelc" >
          <span style="font-size: 100%">
            Automated Repair of Feature Interaction Failures in Automated Driving Systems
          </span>
        </a>
      </span>
      <br />
      Raja Ben Abdessalem, Annibale Panichella, Shiva Nejati, Lionel C. Briand, and Thomas Stifter<br />
      <i><small>(University of Luxembourg, Luxembourg; Delft University of Technology, Netherlands; University of Ottawa, Canada; IEE, Luxembourg)</small></i><br />
      <span id="issta20main-id83-p-absbriandlionelc" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              In the past years, several automated repair strategies have been proposed to fix bugs in individual software programs without any human intervention. There has been, however, little work on how automated repair techniques can resolve failures that arise at the system-level and are caused by undesired interactions among different system components or functions. Feature interaction failures are common in complex systems such as autonomous cars that are typically built as a composition of independent features (i.e., units of functionality). In this paper, we propose a repair technique to automatically resolve undesired feature interaction failures in automated driving systems (ADS) that lead to the violation of system safety requirements. Our repair strategy achieves its goal by (1) localizing faults spanning several lines of code, (2) simultaneously resolving multiple interaction failures caused by independent faults, (3) scaling repair strategies from the unit-level to the system-level, and (4) resolving failures based on their order of severity. We have evaluated our approach using two industrial ADS containing four features. Our results show that our repair strategy resolves the undesired interaction failures in these two systems in less than 16h and outperforms existing automated repair techniques.<br/>
        <br />
        <a href="issta20main-id83-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;"><a href="http://www.cs.ucsb.edu/~bultan/">Bultan, Tevfik</a>  </td>
  <td>
    <span onclick="toggle('issta20main-id101-p-bultantevfik')" title="Feedback-Driven Side-Channel Analysis for Networked Applications  --  İsmet Burak Kadron, Nicolás Rosner, and Tevfik Bultan" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Feedback-Driven Side-Channel ..."</span></small></a>
    </span>

    <span id="issta20main-id101-p-bultantevfik"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id101-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id101-p-bultantevfik')" 
      >
        <a id="issta20main-id101-p-titlebultantevfik" >
          <span style="font-size: 100%">
            Feedback-Driven Side-Channel Analysis for Networked Applications
          </span>
        </a>
      </span>
      <br />
      İsmet Burak Kadron, Nicolás Rosner, and <a href="http://www.cs.ucsb.edu/~bultan/" target="_blank">Tevfik Bultan</a><br />
      <i><small>(University of California at Santa Barbara, USA)</small></i><br />
      <span id="issta20main-id101-p-absbultantevfik" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Information leakage in software systems is a problem of growing importance. Networked applications can leak sensitive information even when they use encryption. For example, some characteristics of network packets, such as their size, timing and direction, are visible even for encrypted traffic. Patterns in these characteristics can be leveraged as side channels to extract information about secret values accessed by the application. In this paper, we present a new tool called AutoFeed for detecting and quantifying information leakage due to side channels in networked software applications. AutoFeed profiles the target system and automatically explores the input space, explores the space of output features that may leak information, quantifies the information leakage, and identifies the top-leaking features.  
Given a set of input mutators and a small number of initial inputs provided by the user, AutoFeed iteratively mutates inputs and periodically updates its leakage estimations to identify the features that leak the greatest amount of information about the secret of interest. AutoFeed uses a feedback loop for incremental profiling, and a stopping criterion that terminates the analysis when the leakage estimation for the top-leaking features converges. AutoFeed also automatically assigns weights to mutators in order to focus the search of the input space on exploring dimensions that are relevant to the leakage quantification. Our experimental evaluation on the benchmarks shows that AutoFeed is effective in detecting and quantifying information leaks in networked applications.<br/>
        <br />
        <a href="issta20main-id101-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Busse, Frank  </td>
  <td>
    <span onclick="toggle('issta20main-id94-p-bussefrank')" title="Running Symbolic Execution Forever  --  Frank Busse, Martin Nowack, and Cristian Cadar" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Running Symbolic Execution ..."</span></small></a>
    </span>

    <span id="issta20main-id94-p-bussefrank"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id94-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id94-p-bussefrank')" 
      >
        <a id="issta20main-id94-p-titlebussefrank" >
          <span style="font-size: 100%">
            Running Symbolic Execution Forever
          </span>
        </a>
      </span>
      <br />
      Frank Busse, Martin Nowack, and <a href="http://www.doc.ic.ac.uk/~cristic/" target="_blank">Cristian Cadar</a><br />
      <i><small>(Imperial College London, UK)</small></i><br />
      <span id="issta20main-id94-p-absbussefrank" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              When symbolic execution is used to analyse real-world applications, it often consumes all available memory in a relatively short amount of time, sometimes making it impossible to analyse an application for an extended period.  
In this paper, we present a technique that can record an ongoing symbolic execution analysis to disk and selectively restore paths of interest later, making it possible to run symbolic execution indefinitely.  
To be successful, our approach addresses several essential research challenges related to detecting divergences on re-execution, storing long-running executions efficiently, changing search heuristics during re-execution, and providing a global view of the stored execution.  
Our extensive evaluation of 93 Linux applications shows that our approach is practical, enabling these applications to run for days while continuing to explore new execution paths.<br/>
        <br />
        <a href="issta20main-id94-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_available_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Available</span></a>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_evaluated_reusable_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Reusable</span></a>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_evaluated_functional_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Functional</span></a>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;"><a id="C"> </a><a href="http://www.doc.ic.ac.uk/~cristic/">Cadar, Cristian</a>
  </td>
  <td>
    <span onclick="toggle('issta20main-id94-p-cadarcristian')" title="Running Symbolic Execution Forever  --  Frank Busse, Martin Nowack, and Cristian Cadar" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Running Symbolic Execution ..."</span></small></a>
    </span>

    <span id="issta20main-id94-p-cadarcristian"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id94-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id94-p-cadarcristian')" 
      >
        <a id="issta20main-id94-p-titlecadarcristian" >
          <span style="font-size: 100%">
            Running Symbolic Execution Forever
          </span>
        </a>
      </span>
      <br />
      Frank Busse, Martin Nowack, and <a href="http://www.doc.ic.ac.uk/~cristic/" target="_blank">Cristian Cadar</a><br />
      <i><small>(Imperial College London, UK)</small></i><br />
      <span id="issta20main-id94-p-abscadarcristian" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              When symbolic execution is used to analyse real-world applications, it often consumes all available memory in a relatively short amount of time, sometimes making it impossible to analyse an application for an extended period.  
In this paper, we present a technique that can record an ongoing symbolic execution analysis to disk and selectively restore paths of interest later, making it possible to run symbolic execution indefinitely.  
To be successful, our approach addresses several essential research challenges related to detecting divergences on re-execution, storing long-running executions efficiently, changing search heuristics during re-execution, and providing a global view of the stored execution.  
Our extensive evaluation of 93 Linux applications shows that our approach is practical, enabling these applications to run for days while continuing to explore new execution paths.<br/>
        <br />
        <a href="issta20main-id94-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_available_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Available</span></a>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_evaluated_reusable_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Reusable</span></a>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_evaluated_functional_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Functional</span></a>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Celik, Ahmet  </td>
  <td>
    <span onclick="toggle('issta20main-id166-p-celikahmet')" title="Debugging the Performance of Maven’s Test Isolation: Experience Report  --  Pengyu Nie, Ahmet Celik, Matthew Coley, Aleksandar Milicevic, Jonathan Bell, and Milos Gligoric" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Debugging the Performance ..."</span></small></a>
    </span>

    <span id="issta20main-id166-p-celikahmet"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id166-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id166-p-celikahmet')" 
      >
        <a id="issta20main-id166-p-titlecelikahmet" >
          <span style="font-size: 100%">
            Debugging the Performance of Maven’s Test Isolation: Experience Report
          </span>
        </a>
      </span>
      <br />
      Pengyu Nie, Ahmet Celik, Matthew Coley, <a href="https://aleksandarmilicevic.github.io/" target="_blank">Aleksandar Milicevic</a>, Jonathan Bell, and <a href="http://users.ece.utexas.edu/~gligoric/" target="_blank">Milos Gligoric</a><br />
      <i><small>(University of Texas at Austin, USA; Facebook, USA; George Mason University, USA; Microsoft, USA)</small></i><br />
      <span id="issta20main-id166-p-abscelikahmet" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Testing is the most common approach used in industry for checking software correctness. Developers frequently practice reliable testing-executing individual tests in isolation from each other-to avoid test failures caused by test-order dependencies and shared state pollution (e.g., when tests mutate static fields). A common way of doing this is by running each test as a separate process. Unfortunately, this is known to introduce substantial overhead. This experience report describes our efforts to better understand the sources of this overhead and to create a system to confirm the minimal overhead possible. We found that different build systems use different mechanisms for communicating between these multiple processes, and that because of this design decision, running tests with some build systems could be faster than with others. Through this inquiry we discovered a significant performance bug in Apache Maven&#8217;s test running code, which slowed down test execution by on average 350 milliseconds per-test when compared to a competing build system, Ant. When used for testing real projects, this can result in a significant reduction in testing time. We submitted a patch for this bug which has been integrated into the Apache Maven build system, and describe our ongoing efforts to improve Maven&#8217;s test execution tooling.<br/>
        <br />
        <a href="issta20main-id166-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Černý, Pavol  </td>
  <td>
    <span onclick="toggle('issta20main-id50-p-cernypavol')" title="Detecting and Understanding Real-World Differential Performance Bugs in Machine Learning Libraries  --  Saeid Tizpaz-Niari, Pavol Černý, and Ashutosh Trivedi" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Detecting and Understanding ..."</span></small></a>
    </span>

    <span id="issta20main-id50-p-cernypavol"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id50-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id50-p-cernypavol')" 
      >
        <a id="issta20main-id50-p-titlecernypavol" >
          <span style="font-size: 100%">
            Detecting and Understanding Real-World Differential Performance Bugs in Machine Learning Libraries
          </span>
        </a>
      </span>
      <br />
      Saeid Tizpaz-Niari, Pavol Černý, and Ashutosh Trivedi<br />
      <i><small>(University of Colorado Boulder, USA; TU Vienna, Austria)</small></i><br />
      <span id="issta20main-id50-p-abscernypavol" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Programming errors that degrade the performance of systems are widespread, yet there is very little tool support for finding and diagnosing these bugs. We present a method and a tool based on differential performance analysis---we find inputs for which the performance varies widely, despite having the same size. To ensure that the differences in the performance are robust (i.e. hold also for large inputs), we compare the performance of not only single inputs, but of classes of inputs, where each class has similar inputs parameterized by their size. Thus, each class is represented by a performance function from the input size to performance. Importantly, we also provide an explanation for why the performance differs in a form that can be readily used to fix a performance bug.  
The two main phases in our method are discovery with fuzzing and explanation with decision tree classifiers, each of which is supported by clustering. First, we propose an evolutionary fuzzing algorithm to generate inputs that characterize different performance functions. For this fuzzing task, the unique challenge is that we not only need the input class with the worst performance, but rather a set of classes exhibiting differential performance. We use clustering to merge similar input classes which significantly improves the efficiency of our fuzzer. Second, we explain the differential performance in terms of program inputs and internals (e.g., methods and conditions). We adapt discriminant learning approaches with clustering and decision trees to localize suspicious code regions.  
We applied our techniques on a set of micro-benchmarks and real-world machine learning libraries. On a set of micro-benchmarks, we show that our approach outperforms state-of-the-art fuzzers in finding inputs to characterize differential performance. On a set of case-studies, we discover and explain multiple performance bugs in popular machine learning frameworks, for instance in implementations of logistic regression in scikit-learn. Four of these bugs, reported first in this paper, have since been fixed by the developers.<br/>
        <br />
        <a href="issta20main-id50-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_available_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Available</span></a>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_evaluated_functional_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Functional</span></a>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Cha, Sooyoung  </td>
  <td>
    <span onclick="toggle('issta20main-id26-p-chasooyoung')" title="Effective White-Box Testing of Deep Neural Networks with Adaptive Neuron-Selection Strategy  --  Seokhyun Lee, Sooyoung Cha, Dain Lee, and Hakjoo Oh" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Effective White-Box Testing ..."</span></small></a>
    </span>

    <span id="issta20main-id26-p-chasooyoung"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id26-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id26-p-chasooyoung')" 
      >
        <a id="issta20main-id26-p-titlechasooyoung" >
          <span style="font-size: 100%">
            Effective White-Box Testing of Deep Neural Networks with Adaptive Neuron-Selection Strategy
          </span>
        </a>
      </span>
      <br />
      Seokhyun Lee, Sooyoung Cha, Dain Lee, and Hakjoo Oh<br />
      <i><small>(Korea University, South Korea)</small></i><br />
      <span id="issta20main-id26-p-abschasooyoung" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              We present Adapt, a new white-box testing technique for deep neural networks. As deep neural networks are increasingly used in safety-first applications, testing their behavior systematically has become a critical problem. Accordingly, various testing techniques for deep neural networks have been proposed in recent years. However, neural network testing is still at an early stage and existing techniques are not yet sufficiently effective. In this paper, we aim to advance this field, in particular white-box testing approaches for neural networks, by identifying and addressing a key limitation of existing state-of-the-arts. We observe that the so-called neuron-selection strategy is a critical component of white-box testing and propose a new technique that effectively employs the strategy by continuously adapting it to the ongoing testing process. Experiments with real-world network models and datasets show that Adapt is remarkably more effective than existing testing techniques in terms of coverage and adversarial inputs found.<br/>
        <br />
        <a href="issta20main-id26-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_available_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Available</span></a>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_evaluated_reusable_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Reusable</span></a>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_evaluated_functional_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Functional</span></a>
          <span style="font-size: 80%; color: blue;"> 
            <img width="20" src="../images/award.svg" alt="" />
            ACM SIGSOFT Distinguished Paper Award</span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Chandra, Satish  </td>
  <td>
    <span onclick="toggle('issta20main-id33-p-chandrasatish')" title="Scaffle: Bug Localization on Millions of Files  --  Michael Pradel, Vijayaraghavan Murali, Rebecca Qian, Mateusz Machalica, Erik Meijer, and Satish Chandra" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Scaffle: Bug Localization ..."</span></small></a>
    </span>

    <span id="issta20main-id33-p-chandrasatish"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id33-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id33-p-chandrasatish')" 
      >
        <a id="issta20main-id33-p-titlechandrasatish" >
          <span style="font-size: 100%">
            Scaffle: Bug Localization on Millions of Files
          </span>
        </a>
      </span>
      <br />
      <a href="http://mp.binaervarianz.de/" target="_blank">Michael Pradel</a>, Vijayaraghavan Murali, Rebecca Qian, Mateusz Machalica, Erik Meijer, and Satish Chandra<br />
      <i><small>(University of Stuttgart, Germany; Facebook, USA)</small></i><br />
      <span id="issta20main-id33-p-abschandrasatish" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Despite all efforts to avoid bugs, software sometimes crashes in the field, leaving crash traces as the only information to localize the problem. Prior approaches on localizing where to fix the root cause of a crash do not scale well to ultra-large scale, heterogeneous code bases that contain millions of code files written in multiple programming languages. This paper presents Scaffle, the first scalable bug localization technique, which is based on the key insight to divide the problem into two easier sub-problems. First, a trained machine learning model predicts which lines of a raw crash trace are most informative for localizing the bug. Then, these lines are fed to an information retrieval-based search engine to retrieve file paths in the code base, predicting which file to change to address the crash. The approach does not make any assumptions about the format of a crash trace or the language that produces it. We evaluate Scaffle with tens of thousands of crash traces produced by a large-scale industrial code base at Facebook that contains millions of possible bug locations and that powers tools used by billions of people. The results show that the approach correctly predicts the file to fix for 40% to 60% (50% to 70%) of all crash traces within the top-1 (top-5) predictions. Moreover, Scaffle improves over several baseline approaches, including an existing classification-based approach, a scalable variant of existing information retrieval-based approaches, and a set of hand-tuned, industrially deployed heuristics.<br/>
        <br />
        <a href="issta20main-id33-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Chen, Bihuan  </td>
  <td>
    <span onclick="toggle('issta20main-id120-p-chenbihuan')" title="Patch Based Vulnerability Matching for Binary Programs  --  Yifei Xu, Zhengzi Xu, Bihuan Chen, Fu Song, Yang Liu, and Ting Liu" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Patch Based Vulnerability ..."</span></small></a>
    </span>

    <span id="issta20main-id120-p-chenbihuan"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id120-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id120-p-chenbihuan')" 
      >
        <a id="issta20main-id120-p-titlechenbihuan" >
          <span style="font-size: 100%">
            Patch Based Vulnerability Matching for Binary Programs
          </span>
        </a>
      </span>
      <br />
      Yifei Xu, Zhengzi Xu, Bihuan Chen, Fu Song, <a href="http://www.ntu.edu.sg/home/yangliu/" target="_blank">Yang Liu</a>, and Ting Liu<br />
      <i><small>(Xi&#39;an Jiaotong University, China; Nanyang Technological University, Singapore; Fudan University, China; ShanghaiTech University, China; Zhejiang University, China)</small></i><br />
      <span id="issta20main-id120-p-abschenbihuan" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              The binary-level function matching has been widely used to detect whether there are 1-day vulnerabilities in released programs. However, the high false positive is a challenge for current function matching solutions, since the vulnerable function is highly similar to its corresponding patched version. In this paper, the Binary X-Ray (BinXray), a patch based vulnerability matching approach, is proposed to identify the specific 1-day vulnerabilities in target programs  
accurately and effectively. In the preparing step, a basic block mapping algorithm is designed to extract the signature of a patch, by comparing the given vulnerable and patched programs. The signature is represented as a set of basic block traces. In the detection step, the patching semantics is applied to reduce irrelevant basic block traces to speed up the signature searching. The trace similarity is also designed to identify whether a target program is patched. In experiments, 12 real software projects related to 479 CVEs are collected. BinXray achieves 93.31% accuracy and the analysis time cost is only 296.17ms per function, outperforming the state-of-the-art works.<br/>
        <br />
        <a href="issta20main-id120-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Chen, Tao  </td>
  <td>
    <span onclick="toggle('issta20main-id38-p-chentao')" title="DeepSQLi: Deep Semantic Learning for Testing SQL Injection  --  Muyang Liu, Ke Li, and Tao Chen" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "DeepSQLi: Deep Semantic Learning ..."</span></small></a>
    </span>

    <span id="issta20main-id38-p-chentao"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id38-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id38-p-chentao')" 
      >
        <a id="issta20main-id38-p-titlechentao" >
          <span style="font-size: 100%">
            DeepSQLi: Deep Semantic Learning for Testing SQL Injection
          </span>
        </a>
      </span>
      <br />
      Muyang Liu, Ke Li, and Tao Chen<br />
      <i><small>(University of Electronic Science and Technology of China, China; University of Exeter, UK; Loughborough University, UK)</small></i><br />
      <span id="issta20main-id38-p-abschentao" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Security is unarguably the most serious concern for Web applications, to which SQL injection (SQLi) attack is one of the most devastating attacks. Automatically testing SQLi vulnerabilities is of ultimate importance, yet is unfortunately far from trivial to implement. This is because the existence of a huge, or potentially infinite, number of variants and semantic possibilities of SQL leading to SQLi attacks on various Web applications. In this paper, we propose a deep natural language processing based tool, dubbed DeepSQLi, to generate test cases for detecting SQLi vulnerabilities. Through adopting deep learning based neural language model and sequence of words prediction, DeepSQLi is equipped with the ability to learn the semantic knowledge embedded in SQLi attacks, allowing it to translate user inputs (or a test case) into a new test case, which is se- mantically related and potentially more sophisticated. Experiments are conducted to compare DeepSQLi with SQLmap, a state-of-the-art SQLi testing automation tool, on six real-world Web applications that are of different scales, characteristics and domains. Empirical results demonstrate the effectiveness and the remarkable superiority of DeepSQLi over SQLmap, such that more SQLi vulnerabilities can be identified by using a less number of test cases, whilst running much faster.<br/>
        <br />
        <a href="issta20main-id38-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Chen, Yuqi  </td>
  <td>
    <span onclick="toggle('issta20main-id40-p-chenyuqi')" title="Active Fuzzing for Testing and Securing Cyber-Physical Systems  --  Yuqi Chen, Bohan Xuan, Christopher M. Poskitt, Jun Sun, and Fan Zhang" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Active Fuzzing for Testing ..."</span></small></a>
    </span>

    <span id="issta20main-id40-p-chenyuqi"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id40-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id40-p-chenyuqi')" 
      >
        <a id="issta20main-id40-p-titlechenyuqi" >
          <span style="font-size: 100%">
            Active Fuzzing for Testing and Securing Cyber-Physical Systems
          </span>
        </a>
      </span>
      <br />
      Yuqi Chen, Bohan Xuan, Christopher M. Poskitt, Jun Sun, and Fan Zhang<br />
      <i><small>(Singapore Management University, Singapore; Zhejiang University, China; Zhejiang Lab, China; Alibaba-Zhejiang University Joint Institute of Frontier Technologies, China)</small></i><br />
      <span id="issta20main-id40-p-abschenyuqi" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Cyber-physical systems&#160;(CPSs) in critical infrastructure face a pervasive threat from attackers, motivating research into a variety of countermeasures for securing them. Assessing the effectiveness of these countermeasures is challenging, however, as realistic benchmarks of attacks are difficult to manually construct, blindly testing is ineffective due to the enormous search spaces and resource requirements, and intelligent fuzzing approaches require impractical amounts of data and network access. In this work, we propose <em>active fuzzing</em>, an automatic approach for finding test suites of packet-level CPS network attacks, targeting scenarios in which attackers can observe sensors and manipulate packets, but have no existing knowledge about the payload encodings. Our approach learns regression models for predicting sensor values that will result from sampled network packets, and uses these predictions to guide a search for payload manipulations (i.e.&#160;bit flips) most likely to drive the CPS into an unsafe state. Key to our solution is the use of <em>online active learning</em>, which iteratively updates the models by sampling payloads that are estimated to maximally improve them. We evaluate the efficacy of active fuzzing by implementing it for a water purification plant testbed, finding it can automatically discover a test suite of flow, pressure, and over/underflow attacks, all with substantially less time, data, and network access than the most comparable approach. Finally, we demonstrate that our prediction models can also be utilised as countermeasures themselves, implementing them as anomaly detectors and early warning systems.<br/>
        <br />
        <a href="issta20main-id40-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;"><a href="http://software.nju.edu.cn/zychen/">Chen, Zhenyu</a>  </td>
  <td>
    <span onclick="toggle('issta20main-id149-p-chenzhenyu')" title="DeepGini: Prioritizing Massive Tests to Enhance the Robustness of Deep Neural Networks  --  Yang Feng, Qingkai Shi, Xinyu Gao, Jun Wan, Chunrong Fang, and Zhenyu Chen" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "DeepGini: Prioritizing Massive ..."</span></small></a>
    </span>

    <span id="issta20main-id149-p-chenzhenyu"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id149-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id149-p-chenzhenyu')" 
      >
        <a id="issta20main-id149-p-titlechenzhenyu" >
          <span style="font-size: 100%">
            DeepGini: Prioritizing Massive Tests to Enhance the Robustness of Deep Neural Networks
          </span>
        </a>
      </span>
      <br />
      Yang Feng, Qingkai Shi, Xinyu Gao, Jun Wan, Chunrong Fang, and <a href="http://software.nju.edu.cn/zychen/" target="_blank">Zhenyu Chen</a><br />
      <i><small>(Nanjing University, China; Hong Kong University of Science and Technology, China; Ant Financial Services, China)</small></i><br />
      <span id="issta20main-id149-p-abschenzhenyu" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Deep neural networks (DNN) have been deployed in many software systems to assist in various classification tasks. In company with the fantastic effectiveness in classification, DNNs could also exhibit incorrect behaviors and result in accidents and losses. Therefore, testing techniques that can detect incorrect DNN behaviors and improve DNN quality are extremely necessary and critical. However, the testing oracle, which defines the correct output for a given input, is often not available in the automated testing. To obtain the oracle information, the testing tasks of DNN-based systems usually require expensive human efforts to label the testing data, which significantly slows down the process of quality assurance.  
<br/>

To mitigate this problem, we propose DeepGini, a test prioritization technique designed based on a statistical perspective of DNN. Such a statistical perspective allows us to reduce the problem of measuring misclassification probability to the problem of measuring set impurity, which allows us to quickly identify possibly-misclassified tests. To evaluate, we conduct an extensive empirical study on popular datasets and prevalent DNN models. The experimental results demonstrate that DeepGini outperforms existing coverage-based techniques in prioritizing tests regarding both effectiveness and efficiency. Meanwhile, we observe that the tests prioritized at the front by DeepGini are more effective in improving the DNN quality in comparison with the coverage-based techniques.<br/>
        <br />
        <a href="issta20main-id149-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
    <span onclick="toggle('issta20tool-id28-p-chenzhenyu')" title="Test Recommendation System Based on Slicing Coverage Filtering  --  Ruixiang Qian, Yuan Zhao, Duo Men, Yang Feng, Qingkai Shi, Yong Huang, and Zhenyu Chen" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20-TOOL: "Test Recommendation System ..."</span></small></a>
    </span>

    <span id="issta20tool-id28-p-chenzhenyu"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20tool-id28-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20tool-id28-p-chenzhenyu')" 
      >
        <a id="issta20tool-id28-p-titlechenzhenyu" >
          <span style="font-size: 100%">
            Test Recommendation System Based on Slicing Coverage Filtering
          </span>
        </a>
      </span>
      <br />
      Ruixiang Qian, Yuan Zhao, Duo Men, Yang Feng, Qingkai Shi, Yong Huang, and <a href="http://software.nju.edu.cn/zychen/" target="_blank">Zhenyu Chen</a><br />
      <i><small>(Nanjing University, China; Hong Kong University of Science and Technology, China; Mooctest, China)</small></i><br />
      <span id="issta20tool-id28-p-abschenzhenyu" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Software testing plays a crucial role in software lifecycle. As a basic approach of software testing, unit testing is one of the necessary skills for software practitioners. Since testers are required to understand the inner code of the software under test(SUT) while writing a test case, testers usually need to learn how to detect the bug within SUT effectively. When novice programmers started to learn writing unit tests, they will generally watch a video lesson or reading unit tests written by others. These learning approaches are either time-consuming or too hard for a novice. To solve these problems, we developed a system, named TeSRS, to assist novice programmers to learn unit testing. TeSRS is a test recommendation system which can effectively assist test novice in learning unit testing. Utilizing program slice technique, TeSRS has gotten an enormous amount of test snippets from superior crowdsourcing test scripts. Depending on these test snippets, TeSRS provides novices a easier way for unit test learning. To sum up, TeSRS can help test novices (1) obtain high level design ideas of unit test case and (2) improve capabilities(e.g. branch coverage rate and mutation coverage rate) of their test scripts. TeSRS has built a scalable corpus composed of over 8000 test snippets from more than 25 test problems. Its stable performance shows effectiveness in unit test learning. <br/>Demo video can be found at <a>https://youtu.be/xvrLdvU8zFA</a><br/>
        <br />
        <a href="issta20tool-id28-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
      <a href="https://www.youtube.com/watch?v=xvrLdvU8zFA"><img width="15" src="../images/video.png" alt="" /><span style="font-size: 90%"> Video</span></a>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Chen, Zhong  </td>
  <td>
    <span onclick="toggle('issta20tool-id11-p-chenzhong')" title="EShield: Protect Smart Contracts against Reverse Engineering  --  Wentian Yan, Jianbo Gao, Zhenhao Wu, Yue Li, Zhi Guan, Qingshan Li, and Zhong Chen" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20-TOOL: "EShield: Protect Smart Contracts ..."</span></small></a>
    </span>

    <span id="issta20tool-id11-p-chenzhong"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20tool-id11-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20tool-id11-p-chenzhong')" 
      >
        <a id="issta20tool-id11-p-titlechenzhong" >
          <span style="font-size: 100%">
            EShield: Protect Smart Contracts against Reverse Engineering
          </span>
        </a>
      </span>
      <br />
      Wentian Yan, Jianbo Gao, Zhenhao Wu, Yue Li, Zhi Guan, Qingshan Li, and Zhong Chen<br />
      <i><small>(Peking University, China; Boya Blockchain, China)</small></i><br />
      <span id="issta20tool-id11-p-abschenzhong" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Smart contracts are the back-end programs of blockchain-based applications and the execution results are deterministic and publicly visible. Developers are unwilling to release source code of some smart contracts to generate randomness or for security reasons, however, attackers still can use reverse engineering tools to decompile and analyze the code. In this paper, we propose EShield, an automated security enhancement tool for protecting smart contracts against reverse engineering. EShield replaces original instructions of operating jump addresses with anti-patterns to interfere with control flow recovery from bytecode. We have implemented four methods in EShield and conducted an experiment on over 20k smart contracts. The evaluation results show that all the protected smart contracts are resistant to three different reverse engineering tools with little extra gas cost.<br/>
        <br />
        <a href="issta20tool-id11-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Choma Neto, João  </td>
  <td>
    <span onclick="toggle('issta20doc-p5-p-chomanetojoao')" title="Automatic Support for the Identification of Infeasible Testing Requirements  --  João Choma Neto" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20-DOC: "Automatic Support for the ..."</span></small></a>
    </span>

    <span id="issta20doc-p5-p-chomanetojoao"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20doc-p5-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20doc-p5-p-chomanetojoao')" 
      >
        <a id="issta20doc-p5-p-titlechomanetojoao" >
          <span style="font-size: 100%">
            Automatic Support for the Identification of Infeasible Testing Requirements
          </span>
        </a>
      </span>
      <br />
      João Choma Neto<br />
      <i><small>(University of São Paulo, Brazil)</small></i><br />
      <span id="issta20doc-p5-p-abschomanetojoao" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Software testing activity is imperative to improve software quality. However, finding a set of test cases satisfies a given test criterion, is not a trivial task because the overall input domain is very large, and different test sets can be derived, with different effectiveness. In the context of structural testing, the non-executability is a feature present in most programs, increasing cost and effort of testing activity. When concurrent programs are tested, new challenges arise, mainly related to the non-determinism. Non-determinism can result in different possible test outputs for the same test input, which makes the problem of non-executability more complex, requiring treatment.  
In this sense, our project intends to define an approach to support automatic identification of infeasible testing requirements.  
Hence, this proposal aims to identify properties which cause infeasible testing requirements and automate their application. Due to complexity of the problem, we will apply search-based algorithms in the automation of concurrent and sequential programs treatment.<br/>
        <br />
        <a href="issta20doc-p5-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Choudhary, Rutvik  </td>
  <td>
    <span onclick="toggle('issta20main-id159-p-choudharyrutvik')" title="Detecting Flaky Tests in Probabilistic and Machine Learning Applications  --  Saikat Dutta, August Shi, Rutvik Choudhary, Zhekun Zhang, Aryaman Jain, and Sasa Misailovic" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Detecting Flaky Tests in Probabilistic ..."</span></small></a>
    </span>

    <span id="issta20main-id159-p-choudharyrutvik"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id159-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id159-p-choudharyrutvik')" 
      >
        <a id="issta20main-id159-p-titlechoudharyrutvik" >
          <span style="font-size: 100%">
            Detecting Flaky Tests in Probabilistic and Machine Learning Applications
          </span>
        </a>
      </span>
      <br />
      Saikat Dutta, <a href="http://mir.cs.illinois.edu/~awshi2/" target="_blank">August Shi</a>, Rutvik Choudhary, Zhekun Zhang, Aryaman Jain, and Sasa Misailovic<br />
      <i><small>(University of Illinois at Urbana-Champaign, USA)</small></i><br />
      <span id="issta20main-id159-p-abschoudharyrutvik" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Probabilistic programming systems and machine learning frameworks like Pyro, PyMC3, TensorFlow, and PyTorch provide scalable and efficient primitives for inference and training. However, such operations are non-deterministic. Hence, it is challenging for developers to write tests for applications that depend on such frameworks, often resulting in flaky tests &#8211; tests which fail non-deterministically when run on the same version of code.  
<br/>

In this paper, we conduct the first extensive study of flaky tests in this domain. In particular, we study the projects that depend on four frameworks: Pyro, PyMC3, TensorFlow-Probability, and  
PyTorch. We identify 75 bug reports/commits that deal with flaky tests, and we categorize the common causes and fixes for them. This study provides developers with useful insights on dealing with flaky tests in this domain.  
<br/>

Motivated by our study, we develop a technique, FLASH, to systematically detect flaky tests due to assertions passing and failing in different runs on the same code. These assertions fail due to differences in the sequence of random numbers in different runs of the same test. FLASH exposes such failures, and our evaluation on 20 projects results in 11 previously-unknown flaky tests that we reported to developers.<br/>
        <br />
        <a href="issta20main-id159-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Coley, Matthew  </td>
  <td>
    <span onclick="toggle('issta20main-id166-p-coleymatthew')" title="Debugging the Performance of Maven’s Test Isolation: Experience Report  --  Pengyu Nie, Ahmet Celik, Matthew Coley, Aleksandar Milicevic, Jonathan Bell, and Milos Gligoric" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Debugging the Performance ..."</span></small></a>
    </span>

    <span id="issta20main-id166-p-coleymatthew"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id166-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id166-p-coleymatthew')" 
      >
        <a id="issta20main-id166-p-titlecoleymatthew" >
          <span style="font-size: 100%">
            Debugging the Performance of Maven’s Test Isolation: Experience Report
          </span>
        </a>
      </span>
      <br />
      Pengyu Nie, Ahmet Celik, Matthew Coley, <a href="https://aleksandarmilicevic.github.io/" target="_blank">Aleksandar Milicevic</a>, Jonathan Bell, and <a href="http://users.ece.utexas.edu/~gligoric/" target="_blank">Milos Gligoric</a><br />
      <i><small>(University of Texas at Austin, USA; Facebook, USA; George Mason University, USA; Microsoft, USA)</small></i><br />
      <span id="issta20main-id166-p-abscoleymatthew" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Testing is the most common approach used in industry for checking software correctness. Developers frequently practice reliable testing-executing individual tests in isolation from each other-to avoid test failures caused by test-order dependencies and shared state pollution (e.g., when tests mutate static fields). A common way of doing this is by running each test as a separate process. Unfortunately, this is known to introduce substantial overhead. This experience report describes our efforts to better understand the sources of this overhead and to create a system to confirm the minimal overhead possible. We found that different build systems use different mechanisms for communicating between these multiple processes, and that because of this design decision, running tests with some build systems could be faster than with others. Through this inquiry we discovered a significant performance bug in Apache Maven&#8217;s test running code, which slowed down test execution by on average 350 milliseconds per-test when compared to a competing build system, Ant. When used for testing real projects, this can result in a significant reduction in testing time. We submitted a patch for this bug which has been integrated into the Apache Maven build system, and describe our ongoing efforts to improve Maven&#8217;s test execution tooling.<br/>
        <br />
        <a href="issta20main-id166-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Coppa, Emilio  </td>
  <td>
    <span onclick="toggle('issta20main-id31-p-coppaemilio')" title="WEIZZ: Automatic Grey-Box Fuzzing for Structured Binary Formats  --  Andrea Fioraldi, Daniele Cono D'Elia, and Emilio Coppa" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "WEIZZ: Automatic Grey-Box ..."</span></small></a>
    </span>

    <span id="issta20main-id31-p-coppaemilio"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id31-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id31-p-coppaemilio')" 
      >
        <a id="issta20main-id31-p-titlecoppaemilio" >
          <span style="font-size: 100%">
            WEIZZ: Automatic Grey-Box Fuzzing for Structured Binary Formats
          </span>
        </a>
      </span>
      <br />
      Andrea Fioraldi, Daniele Cono D'Elia, and Emilio Coppa<br />
      <i><small>(Sapienza University of Rome, Italy)</small></i><br />
      <span id="issta20main-id31-p-abscoppaemilio" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Fuzzing technologies have evolved at a fast pace in recent years, revealing bugs in programs with ever increasing depth and speed. Applications working with complex formats are however more difficult to take on, as inputs need to meet certain format-specific characteristics to get through the initial parsing stage and reach deeper behaviors of the program.  
<br/>

Unlike prior proposals based on manually written format specifications, we propose a technique to automatically generate and mutate inputs for unknown chunk-based binary formats. We identify dependencies between input bytes and comparison instructions, and use them to assign tags that characterize the processing logic of the program. Tags become the building block for structure-aware mutations involving chunks and fields of the input.  
<br/>

Our technique can perform comparably to structure-aware fuzzing proposals that require human assistance. Our prototype implementation WEIZZ revealed 16 unknown bugs in widely used programs.<br/>
        <br />
        <a href="issta20main-id31-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
      <a href="https://github.com/andreafioraldi/weizz-fuzzer"><img width="15" src="../images/tool.png" alt="" /><span style="font-size: 90%"> Info</span></a>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Cygan, Artur  </td>
  <td>
    <span onclick="toggle('issta20tool-id13-p-cyganartur')" title="Echidna: Effective, Usable, and Fast Fuzzing for Smart Contracts  --  Gustavo Grieco, Will Song, Artur Cygan, Josselin Feist, and Alex Groce" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20-TOOL: "Echidna: Effective, Usable, ..."</span></small></a>
    </span>

    <span id="issta20tool-id13-p-cyganartur"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20tool-id13-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20tool-id13-p-cyganartur')" 
      >
        <a id="issta20tool-id13-p-titlecyganartur" >
          <span style="font-size: 100%">
            Echidna: Effective, Usable, and Fast Fuzzing for Smart Contracts
          </span>
        </a>
      </span>
      <br />
      Gustavo Grieco, Will Song, Artur Cygan, Josselin Feist, and <a href="http://www.cs.cmu.edu/~agroce" target="_blank">Alex Groce</a><br />
      <i><small>(Trail of Bits, USA; Northern Arizona University, USA)</small></i><br />
      <span id="issta20tool-id13-p-abscyganartur" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Ethereum smart contracts---autonomous programs that run on a blockchain---often control transactions of financial and intellectual property. Because of the critical role they play, smart contracts need complete, comprehensive, and effective test generation. This paper introduces an open-source smart contract fuzzer called Echidna that makes it easy to automatically generate tests to detect violations in assertions and custom properties. Echidna is easy to install and does not require a complex configuration or deployment of contracts to a local blockchain. It offers responsive feedback, captures many property violations, and its default settings are calibrated based on experimental data. To date, Echidna has been used in more than 10 large paid security audits, and feedback from those audits has driven the features and user experience of Echidna, both in terms of practical usability (e.g., smart contract frameworks like Truffle and Embark) and test generation strategies. Echidna aims to be good at finding real bugs in smart contracts, with minimal user effort and maximal speed.<br/>
        <br />
        <a href="issta20tool-id13-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
      <a href="https://github.com/crytic/echidna"><img width="15" src="../images/tool.png" alt="" /><span style="font-size: 90%"> Info</span></a>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;"><a id="D"> </a>D'Elia, Daniele Cono
  </td>
  <td>
    <span onclick="toggle('issta20main-id31-p-deliadanielecono')" title="WEIZZ: Automatic Grey-Box Fuzzing for Structured Binary Formats  --  Andrea Fioraldi, Daniele Cono D'Elia, and Emilio Coppa" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "WEIZZ: Automatic Grey-Box ..."</span></small></a>
    </span>

    <span id="issta20main-id31-p-deliadanielecono"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id31-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id31-p-deliadanielecono')" 
      >
        <a id="issta20main-id31-p-titledeliadanielecono" >
          <span style="font-size: 100%">
            WEIZZ: Automatic Grey-Box Fuzzing for Structured Binary Formats
          </span>
        </a>
      </span>
      <br />
      Andrea Fioraldi, Daniele Cono D'Elia, and Emilio Coppa<br />
      <i><small>(Sapienza University of Rome, Italy)</small></i><br />
      <span id="issta20main-id31-p-absdeliadanielecono" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Fuzzing technologies have evolved at a fast pace in recent years, revealing bugs in programs with ever increasing depth and speed. Applications working with complex formats are however more difficult to take on, as inputs need to meet certain format-specific characteristics to get through the initial parsing stage and reach deeper behaviors of the program.  
<br/>

Unlike prior proposals based on manually written format specifications, we propose a technique to automatically generate and mutate inputs for unknown chunk-based binary formats. We identify dependencies between input bytes and comparison instructions, and use them to assign tags that characterize the processing logic of the program. Tags become the building block for structure-aware mutations involving chunks and fields of the input.  
<br/>

Our technique can perform comparably to structure-aware fuzzing proposals that require human assistance. Our prototype implementation WEIZZ revealed 16 unknown bugs in widely used programs.<br/>
        <br />
        <a href="issta20main-id31-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
      <a href="https://github.com/andreafioraldi/weizz-fuzzer"><img width="15" src="../images/tool.png" alt="" /><span style="font-size: 90%"> Info</span></a>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Deng, Xuan  </td>
  <td>
    <span onclick="toggle('issta20main-id128-p-dengxuan')" title="Discovering Discrepancies in Numerical Libraries  --  Jackson Vanover, Xuan Deng, and Cindy Rubio-González" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Discovering Discrepancies ..."</span></small></a>
    </span>

    <span id="issta20main-id128-p-dengxuan"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id128-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id128-p-dengxuan')" 
      >
        <a id="issta20main-id128-p-titledengxuan" >
          <span style="font-size: 100%">
            Discovering Discrepancies in Numerical Libraries
          </span>
        </a>
      </span>
      <br />
      Jackson Vanover, Xuan Deng, and Cindy Rubio-González<br />
      <i><small>(University of California at Davis, USA)</small></i><br />
      <span id="issta20main-id128-p-absdengxuan" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Numerical libraries constitute the building blocks for software  
applications that perform numerical calculations. Thus, it is  
paramount that such libraries provide accurate and consistent results.  
To that end, this paper addresses the problem of finding discrepancies  
between synonymous functions in different numerical libraries as a  
means of identifying incorrect behavior. Our approach automatically  
finds such synonymous functions, synthesizes testing drivers, and  
executes differential tests to discover meaningful discrepancies  
across numerical libraries. We implement our approach in a tool named  
FPDiff, and provide an evaluation on four popular numerical libraries:  
GNU Scientific Library (GSL), SciPy, mpmath, and jmat. FPDiff finds  
a total of 126 equivalence classes with a 95.8% precision  
and 79% recall, and discovers 655 instances in which  
an input produces a set of disagreeing outputs between function  
synonyms, 150 of which we found to represent  
125 unique bugs. We have reported all bugs to library  
maintainers; so far, 30 bugs have been fixed, 9  
have been found to be previously known, and 25 more  
have been acknowledged by developers.<br/>
        <br />
        <a href="issta20main-id128-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_available_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Available</span></a>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_evaluated_reusable_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Reusable</span></a>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_evaluated_functional_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Functional</span></a>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Dong, Jin Song  </td>
  <td>
    <span onclick="toggle('issta20main-id134-p-dongjinsong')" title="Recovering Fitness Gradients for Interprocedural Boolean Flags in Search-Based Testing  --  Yun Lin, Jun Sun, Gordon Fraser, Ziheng Xiu, Ting Liu, and Jin Song Dong" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Recovering Fitness Gradients ..."</span></small></a>
    </span>

    <span id="issta20main-id134-p-dongjinsong"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id134-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id134-p-dongjinsong')" 
      >
        <a id="issta20main-id134-p-titledongjinsong" >
          <span style="font-size: 100%">
            Recovering Fitness Gradients for Interprocedural Boolean Flags in Search-Based Testing
          </span>
        </a>
      </span>
      <br />
      <a href="http://linyun.info/" target="_blank">Yun Lin</a>, Jun Sun, Gordon Fraser, Ziheng Xiu, Ting Liu, and Jin Song Dong<br />
      <i><small>(National University of Singapore, Singapore; Singapore Management University, Singapore; University of Passau, Germany; Xi&#39;an Jiaotong University, China)</small></i><br />
      <span id="issta20main-id134-p-absdongjinsong" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              In Search-based Software Testing (SBST), test generation is guided by fitness functions that estimate how close a test case is to reach an uncovered test goal (e.g., branch). A popular fitness function estimates how close conditional statements are to evaluating to true or false, i.e., the branch distance. However, when conditions read Boolean variables (e.g., if(x &amp;&amp; y)), the branch distance provides no gradient for the search, since a Boolean can either be true or false. This flag problem can be addressed by transforming individual procedures such that Boolean flags are replaced with numeric comparisons that provide better guidance for the search. Unfortunately, defining a semantics-preserving transformation that is applicable in an interprocedural case, where Boolean flags are passed around as parameters and return values, is a daunting task. Thus, it is not yet supported by modern test generators. <br/>This work is based on the insight that fitness gradients can be recovered by using runtime information: Given an uncovered interprocedural flag branch, our approach (1) calculates context-sensitive branch distance for all control flows potentially returning the required flag in the called method, and (2) recursively aggregates these distances into a continuous value. We implemented our approach on top of the EvoSuite framework for Java, and empirically compared it with state-of-the-art testability transformations on non-trivial methods suffering from interprocedural flag problems, sampled from open source Java projects. Our experiment demonstrates that our approach achieves higher coverage on the subject methods with statistical significance and acceptable runtime overheads.<br/>
        <br />
        <a href="issta20main-id134-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;"><a href="http://www.tcse.cn/~wsdou/">Dou, Wensheng</a>  </td>
  <td>
    <span onclick="toggle('issta20main-id141-p-douwensheng')" title="Learning to Detect Table Clones in Spreadsheets  --  Yakun Zhang, Wensheng Dou, Jiaxin Zhu, Liang Xu, Zhiyong Zhou, Jun Wei, Dan Ye, and Bo Yang" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Learning to Detect Table Clones ..."</span></small></a>
    </span>

    <span id="issta20main-id141-p-douwensheng"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id141-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id141-p-douwensheng')" 
      >
        <a id="issta20main-id141-p-titledouwensheng" >
          <span style="font-size: 100%">
            Learning to Detect Table Clones in Spreadsheets
          </span>
        </a>
      </span>
      <br />
      Yakun Zhang, <a href="http://www.tcse.cn/~wsdou/" target="_blank">Wensheng Dou</a>, Jiaxin Zhu, Liang Xu, Zhiyong Zhou, Jun Wei, Dan Ye, and Bo Yang<br />
      <i><small>(Institute of Software at Chinese Academy of Sciences, China; Jinling Institute of Technology, China; North China University of Technology, China)</small></i><br />
      <span id="issta20main-id141-p-absdouwensheng" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              In order to speed up spreadsheet development productivity, end users can create a spreadsheet table by copying and modifying an existing one. These two tables share the similar computational semantics, and form a table clone. End users may modify the tables in a table clone, e.g., adding new rows and deleting columns, thus introducing structure changes into the table clone. Our empirical study on real-world spreadsheets shows that about 58.5% of table clones involve structure changes. However, existing table clone detection approaches in spreadsheets can only detect table clones with the same structures. Therefore, many table clones with structure changes cannot be detected. <br/>We observe that, although the tables in a table clone may be modified, they usually share the similar structures and formats, e.g., headers, formulas and background colors. Based on this observation, we propose <em>LTC</em> (<em>L</em>earning to detect <em>T</em>able <em>C</em>lones), to automatically detect table clones with or without structure changes. LTC utilizes the structure and format information from labeled table clones and non table clones to train a binary classifier. LTC first identifies tables in spreadsheets, and then uses the trained binary classifier to judge whether every two tables can form a table clone. Our experiments on real-world spreadsheets from the EUSES and Enron corpora show that, LTC can achieve a precision of 97.8% and recall of 92.1% in table clone detection, significantly outperforming the state-of-the-art technique (a precision of 37.5% and recall of 11.1%).<br/>
        <br />
        <a href="issta20main-id141-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
    <span onclick="toggle('issta20main-id139-p-douwensheng')" title="Detecting Cache-Related Bugs in Spark Applications  --  Hui Li, Dong Wang, Tianze Huang, Yu Gao, Wensheng Dou, Lijie Xu, Wei Wang, Jun Wei, and Hua Zhong" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Detecting Cache-Related Bugs ..."</span></small></a>
    </span>

    <span id="issta20main-id139-p-douwensheng"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id139-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id139-p-douwensheng')" 
      >
        <a id="issta20main-id139-p-titledouwensheng" >
          <span style="font-size: 100%">
            Detecting Cache-Related Bugs in Spark Applications
          </span>
        </a>
      </span>
      <br />
      Hui Li, Dong Wang, Tianze Huang, Yu Gao, <a href="http://www.tcse.cn/~wsdou/" target="_blank">Wensheng Dou</a>, Lijie Xu, Wei Wang, Jun Wei, and Hua Zhong<br />
      <i><small>(Institute of Software at Chinese Academy of Sciences, China; University of Chinese Academy of Sciences, China; Beijing University of Posts and Telecommunications, China)</small></i><br />
      <span id="issta20main-id139-p-absdouwensheng" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Apache Spark has been widely used to build big data applications. Spark utilizes the abstraction of Resilient Distributed Dataset (RDD) to store and retrieve large-scale data. To reduce duplicate computation of an RDD, Spark can cache the RDD in memory and then reuse it later, thus improving performance. Spark relies on application developers to enforce caching decisions by using <em>persist</em>() and <em>unpersist</em>() APIs, e.g., <em>which</em> RDD is persisted and <em>when</em> the RDD is persisted / unpersisted. Incorrect RDD caching decisions can cause duplicate computations, or waste precious memory resource, thus introducing serious performance degradation in Spark applications. In this paper, we propose <em>CacheCheck</em>, to automatically detect cache-related bugs in Spark applications. We summarize six cache-related bug patterns in Spark applications, and then dynamically detect cache-related bugs by analyzing the execution traces of Spark applications. We evaluate CacheCheck on six real-world Spark applications. The experimental result shows that CacheCheck detects 72 previously unknown cache-related bugs, and 28 of them have been fixed by developers.<br/>
        <br />
        <a href="issta20main-id139-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_available_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Available</span></a>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_evaluated_reusable_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Reusable</span></a>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_evaluated_functional_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Functional</span></a>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Dutta, Saikat  </td>
  <td>
    <span onclick="toggle('issta20main-id159-p-duttasaikat')" title="Detecting Flaky Tests in Probabilistic and Machine Learning Applications  --  Saikat Dutta, August Shi, Rutvik Choudhary, Zhekun Zhang, Aryaman Jain, and Sasa Misailovic" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Detecting Flaky Tests in Probabilistic ..."</span></small></a>
    </span>

    <span id="issta20main-id159-p-duttasaikat"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id159-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id159-p-duttasaikat')" 
      >
        <a id="issta20main-id159-p-titleduttasaikat" >
          <span style="font-size: 100%">
            Detecting Flaky Tests in Probabilistic and Machine Learning Applications
          </span>
        </a>
      </span>
      <br />
      Saikat Dutta, <a href="http://mir.cs.illinois.edu/~awshi2/" target="_blank">August Shi</a>, Rutvik Choudhary, Zhekun Zhang, Aryaman Jain, and Sasa Misailovic<br />
      <i><small>(University of Illinois at Urbana-Champaign, USA)</small></i><br />
      <span id="issta20main-id159-p-absduttasaikat" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Probabilistic programming systems and machine learning frameworks like Pyro, PyMC3, TensorFlow, and PyTorch provide scalable and efficient primitives for inference and training. However, such operations are non-deterministic. Hence, it is challenging for developers to write tests for applications that depend on such frameworks, often resulting in flaky tests &#8211; tests which fail non-deterministically when run on the same version of code.  
<br/>

In this paper, we conduct the first extensive study of flaky tests in this domain. In particular, we study the projects that depend on four frameworks: Pyro, PyMC3, TensorFlow-Probability, and  
PyTorch. We identify 75 bug reports/commits that deal with flaky tests, and we categorize the common causes and fixes for them. This study provides developers with useful insights on dealing with flaky tests in this domain.  
<br/>

Motivated by our study, we develop a technique, FLASH, to systematically detect flaky tests due to assertions passing and failing in different runs on the same code. These assertions fail due to differences in the sequence of random numbers in different runs of the same test. FLASH exposes such failures, and our evaluation on 20 projects results in 11 previously-unknown flaky tests that we reported to developers.<br/>
        <br />
        <a href="issta20main-id159-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Dwyer, Matthew B.  </td>
  <td>
    <span onclick="toggle('issta20main-id108-p-dwyermatthewb')" title="Feasible and Stressful Trajectory Generation for Mobile Robots  --  Carl Hildebrandt, Sebastian Elbaum, Nicola Bezzo, and Matthew B. Dwyer" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Feasible and Stressful Trajectory ..."</span></small></a>
    </span>

    <span id="issta20main-id108-p-dwyermatthewb"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id108-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id108-p-dwyermatthewb')" 
      >
        <a id="issta20main-id108-p-titledwyermatthewb" >
          <span style="font-size: 100%">
            Feasible and Stressful Trajectory Generation for Mobile Robots
          </span>
        </a>
      </span>
      <br />
      Carl Hildebrandt, Sebastian Elbaum, Nicola Bezzo, and Matthew B. Dwyer<br />
      <i><small>(University of Virginia, USA)</small></i><br />
      <span id="issta20main-id108-p-absdwyermatthewb" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              While executing nominal tests on mobile robots is required for their validation, such tests may overlook faults that arise under trajectories that accentuate certain aspects of the robot&#39;s behavior. Uncovering such stressful trajectories is challenging as the input space for these systems, as they move, is extremely large, and the relation between a planned trajectory and its potential to induce stress can be subtle. To address this challenge we propose a framework that 1) integrates kinematic and dynamic physical models of the robot into the automated trajectory generation in order to generate valid trajectories, and 2) incorporates a parameterizable scoring model to efficiently generate physically valid yet stressful trajectories for a broad range of mobile robots. We evaluate our approach on four variants of a state-of-the-art quadrotor in a racing simulator. We find that, for non-trivial length trajectories, the incorporation of the kinematic and dynamic model is crucial to generate any valid trajectory, and that the approach with the best hand-crafted scoring model and with a trained scoring model can cause on average a 55.9% and 41.3% more stress than a random selection among valid trajectories. A follow-up study shows that the approach was able to induce similar stress on a deployed commercial quadrotor, with trajectories that deviated up to 6m from the intended ones.<br/>
        <br />
        <a href="issta20main-id108-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
      <a href="https://hildebrandt-carl.github.io/RobotTestGenerationArtifact/"><img width="15" src="../images/tool.png" alt="" /><span style="font-size: 90%"> Info</span></a>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_available_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Available</span></a>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_evaluated_reusable_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Reusable</span></a>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_evaluated_functional_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Functional</span></a>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;"><a id="E"> </a>Eichberg, Michael
  </td>
  <td>
    <span onclick="toggle('issta20main-id78-p-eichbergmichael')" title="A Programming Model for Semi-implicit Parallelization of Static Analyses  --  Dominik Helm, Florian Kübler, Jan Thomas Kölzer, Philipp Haller, Michael Eichberg, Guido Salvaneschi, and Mira Mezini" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "A Programming Model for Semi-implicit ..."</span></small></a>
    </span>

    <span id="issta20main-id78-p-eichbergmichael"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id78-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id78-p-eichbergmichael')" 
      >
        <a id="issta20main-id78-p-titleeichbergmichael" >
          <span style="font-size: 100%">
            A Programming Model for Semi-implicit Parallelization of Static Analyses
          </span>
        </a>
      </span>
      <br />
      Dominik Helm, Florian Kübler, Jan Thomas Kölzer, Philipp Haller, Michael Eichberg, Guido Salvaneschi, and Mira Mezini<br />
      <i><small>(TU Darmstadt, Germany; KTH, Sweden)</small></i><br />
      <span id="issta20main-id78-p-abseichbergmichael" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Parallelization of static analyses is necessary to scale to real-world programs, but it is a complex and difficult task and, therefore, often only done manually for selected high-profile analyses. In this paper, we propose a programming model for semi-implicit parallelization of static analyses which is inspired by reactive programming. Reusing the domain-expert knowledge on how to parallelize anal-  
yses encoded in the programming framework, developers do not need to think about parallelization and concurrency issues on their own. The programming model supports stateful computations, only requires monotonic computations over lattices, and is independent of specific analyses. Our evaluation shows the applicability of the programming model to different analyses and the importance of user-selected scheduling strategies. We implemented an IFDS solver that was able to outperform a state-of-the-art, specialized parallel IFDS solver both in absolute performance and scalability.<br/>
        <br />
        <a href="issta20main-id78-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Elbaum, Sebastian  </td>
  <td>
    <span onclick="toggle('issta20main-id108-p-elbaumsebastian')" title="Feasible and Stressful Trajectory Generation for Mobile Robots  --  Carl Hildebrandt, Sebastian Elbaum, Nicola Bezzo, and Matthew B. Dwyer" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Feasible and Stressful Trajectory ..."</span></small></a>
    </span>

    <span id="issta20main-id108-p-elbaumsebastian"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id108-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id108-p-elbaumsebastian')" 
      >
        <a id="issta20main-id108-p-titleelbaumsebastian" >
          <span style="font-size: 100%">
            Feasible and Stressful Trajectory Generation for Mobile Robots
          </span>
        </a>
      </span>
      <br />
      Carl Hildebrandt, Sebastian Elbaum, Nicola Bezzo, and Matthew B. Dwyer<br />
      <i><small>(University of Virginia, USA)</small></i><br />
      <span id="issta20main-id108-p-abselbaumsebastian" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              While executing nominal tests on mobile robots is required for their validation, such tests may overlook faults that arise under trajectories that accentuate certain aspects of the robot&#39;s behavior. Uncovering such stressful trajectories is challenging as the input space for these systems, as they move, is extremely large, and the relation between a planned trajectory and its potential to induce stress can be subtle. To address this challenge we propose a framework that 1) integrates kinematic and dynamic physical models of the robot into the automated trajectory generation in order to generate valid trajectories, and 2) incorporates a parameterizable scoring model to efficiently generate physically valid yet stressful trajectories for a broad range of mobile robots. We evaluate our approach on four variants of a state-of-the-art quadrotor in a racing simulator. We find that, for non-trivial length trajectories, the incorporation of the kinematic and dynamic model is crucial to generate any valid trajectory, and that the approach with the best hand-crafted scoring model and with a trained scoring model can cause on average a 55.9% and 41.3% more stress than a random selection among valid trajectories. A follow-up study shows that the approach was able to induce similar stress on a deployed commercial quadrotor, with trajectories that deviated up to 6m from the intended ones.<br/>
        <br />
        <a href="issta20main-id108-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
      <a href="https://hildebrandt-carl.github.io/RobotTestGenerationArtifact/"><img width="15" src="../images/tool.png" alt="" /><span style="font-size: 90%"> Info</span></a>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_available_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Available</span></a>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_evaluated_reusable_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Reusable</span></a>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_evaluated_functional_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Functional</span></a>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;"><a href="https://homes.cs.washington.edu/~mernst/">Ernst, Michael D.</a>  </td>
  <td>
    <span onclick="toggle('issta20main-id57-p-ernstmichaeld')" title="Dependent-Test-Aware Regression Testing Techniques  --  Wing Lam, August Shi, Reed Oei, Sai Zhang, Michael D. Ernst, and Tao Xie" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Dependent-Test-Aware Regression ..."</span></small></a>
    </span>

    <span id="issta20main-id57-p-ernstmichaeld"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id57-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id57-p-ernstmichaeld')" 
      >
        <a id="issta20main-id57-p-titleernstmichaeld" >
          <span style="font-size: 100%">
            Dependent-Test-Aware Regression Testing Techniques
          </span>
        </a>
      </span>
      <br />
      <a href="http://winglam2.web.engr.illinois.edu/" target="_blank">Wing Lam</a>, <a href="http://mir.cs.illinois.edu/~awshi2/" target="_blank">August Shi</a>, Reed Oei, Sai Zhang, <a href="https://homes.cs.washington.edu/~mernst/" target="_blank">Michael D. Ernst</a>, and <a href="http://taoxie.cs.illinois.edu/" target="_blank">Tao Xie</a><br />
      <i><small>(University of Illinois at Urbana-Champaign, USA; Google, USA; University of Washington, USA; Peking University, China)</small></i><br />
      <span id="issta20main-id57-p-absernstmichaeld" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Developers typically rely on regression testing techniques to ensure that their changes do not break existing functionality. Unfortunately, these techniques suffer from flaky tests, which can both pass and fail when run multiple times on the same version of code and tests. One prominent type of flaky tests is order-dependent (OD) tests, which are tests that pass when run in one order but fail when run in another order. Although OD tests may cause flaky-test failures, OD tests can help developers run their tests faster by allowing them to share resources. We propose to make regression testing techniques dependent-test-aware to reduce flaky-test failures.  
<br/>

To understand the necessity of dependent-test-aware regression testing techniques, we conduct the first study on the impact of OD tests on three regression testing techniques: test prioritization, test selection, and test parallelization. In particular, we implement 4 test prioritization, 6 test selection, and 2 test parallelization algorithms, and we evaluate them on 11 Java modules with OD tests. When we run the orders produced by the traditional, dependent-test-unaware regression testing algorithms, 82% of human-written test suites and 100% of automatically-generated test suites with OD tests have at least one flaky-test failure.  
<br/>

We develop a general approach for enhancing regression testing algorithms to make them dependent-test-aware, and apply our approach to 12 algorithms. Compared to traditional, unenhanced regression testing algorithms, the enhanced algorithms use provided test dependencies to produce orders with different permutations or extra tests. Our evaluation shows that, in comparison to the orders produced by unenhanced algorithms, the orders produced by enhanced algorithms (1) have overall 80% fewer flaky-test failures due to OD tests, and (2) may add extra tests but run only 1% slower on average. Our results suggest that enhancing regression testing algorithms to be dependent-test-aware can substantially reduce flaky-test failures with only a minor slowdown to run the tests.<br/>
        <br />
        <a href="issta20main-id57-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;"><a id="F"> </a>Fan, Gang
  </td>
  <td>
    <span onclick="toggle('issta20main-id145-p-fangang')" title="Escaping Dependency Hell: Finding Build Dependency Errors with the Unified Dependency Graph  --  Gang Fan, Chengpeng Wang, Rongxin Wu, Xiao Xiao, Qingkai Shi, and Charles Zhang" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Escaping Dependency Hell: ..."</span></small></a>
    </span>

    <span id="issta20main-id145-p-fangang"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id145-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id145-p-fangang')" 
      >
        <a id="issta20main-id145-p-titlefangang" >
          <span style="font-size: 100%">
            Escaping Dependency Hell: Finding Build Dependency Errors with the Unified Dependency Graph
          </span>
        </a>
      </span>
      <br />
      Gang Fan, Chengpeng Wang, Rongxin Wu, Xiao Xiao, Qingkai Shi, and Charles Zhang<br />
      <i><small>(Hong Kong University of Science and Technology, China; Xiamen University, China; Sourcebrella, China)</small></i><br />
      <span id="issta20main-id145-p-absfangang" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Modern software projects rely on build systems and build scripts to assemble executable artifacts correctly and efficiently. However, developing build scripts is error-prone. Dependency-related errors in build scripts, mainly including missing dependencies and redundant dependencies, are common in various kinds of software projects. These errors lead to build failures, incorrect build results or poor performance in incremental or parallel builds. To detect such errors, various techniques are proposed and suffer from low efficiency and high false positive problems, due to the deficiency of the underlying dependency graphs. In this work, we design a new dependency graph, the unified dependency graph (UDG), which leverages both static and dynamic information to uniformly encode the declared and actual dependencies between build targets and files. The construction of UDG facilitates the efficient and precise detection of dependency errors via simple graph traversals. We implement the proposed approach as a tool, VeriBuild, and evaluate it on forty-two well-maintained open-source projects. The experimental results show that, without losing precision, VeriBuild incurs 58.2% less overhead than the state-of-the-art approach. By the time of writing, 398 detected dependency issues have been confirmed by the developers.<br/>
        <br />
        <a href="issta20main-id145-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Fang, Chunrong  </td>
  <td>
    <span onclick="toggle('issta20main-id140-p-fangchunrong')" title="Functional Code Clone Detection with Syntax and Semantics Fusion Learning  --  Chunrong Fang, Zixi Liu, Yangyang Shi, Jeff Huang, and Qingkai Shi" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Functional Code Clone Detection ..."</span></small></a>
    </span>

    <span id="issta20main-id140-p-fangchunrong"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id140-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id140-p-fangchunrong')" 
      >
        <a id="issta20main-id140-p-titlefangchunrong" >
          <span style="font-size: 100%">
            Functional Code Clone Detection with Syntax and Semantics Fusion Learning
          </span>
        </a>
      </span>
      <br />
      Chunrong Fang, Zixi Liu, Yangyang Shi, Jeff Huang, and Qingkai Shi<br />
      <i><small>(Nanjing University, China; Texas A&#38;M University, USA; Hong Kong University of Science and Technology, China)</small></i><br />
      <span id="issta20main-id140-p-absfangchunrong" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Clone detection of source code is among the most fundamental software engineering techniques. Despite intensive research in the past decade, existing techniques are still unsatisfactory in detecting &quot;functional&quot; code clones. In particular, existing techniques cannot efficiently extract syntax and semantics information from source code. In this paper, we propose a novel joint code representation that applies fusion embedding techniques to learn hidden syntactic and semantic features of source codes. Besides, we introduce a new granularity for functional code clone detection. Our approach regards the connected methods with caller-callee relationships as a functionality and the method without any caller-callee relationship with other methods represents a single functionality. Then we train a supervised deep learning model to detect functional code clones. We conduct evaluations on a large dataset of C++ programs and the experimental results show that fusion learning can significantly outperform the state-of-the-art techniques in detecting functional code clones.<br/>
        <br />
        <a href="issta20main-id140-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_available_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Available</span></a>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_evaluated_reusable_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Reusable</span></a>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_evaluated_functional_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Functional</span></a>
    </span>
    <span onclick="toggle('issta20main-id149-p-fangchunrong')" title="DeepGini: Prioritizing Massive Tests to Enhance the Robustness of Deep Neural Networks  --  Yang Feng, Qingkai Shi, Xinyu Gao, Jun Wan, Chunrong Fang, and Zhenyu Chen" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "DeepGini: Prioritizing Massive ..."</span></small></a>
    </span>

    <span id="issta20main-id149-p-fangchunrong"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id149-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id149-p-fangchunrong')" 
      >
        <a id="issta20main-id149-p-titlefangchunrong" >
          <span style="font-size: 100%">
            DeepGini: Prioritizing Massive Tests to Enhance the Robustness of Deep Neural Networks
          </span>
        </a>
      </span>
      <br />
      Yang Feng, Qingkai Shi, Xinyu Gao, Jun Wan, Chunrong Fang, and <a href="http://software.nju.edu.cn/zychen/" target="_blank">Zhenyu Chen</a><br />
      <i><small>(Nanjing University, China; Hong Kong University of Science and Technology, China; Ant Financial Services, China)</small></i><br />
      <span id="issta20main-id149-p-absfangchunrong" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Deep neural networks (DNN) have been deployed in many software systems to assist in various classification tasks. In company with the fantastic effectiveness in classification, DNNs could also exhibit incorrect behaviors and result in accidents and losses. Therefore, testing techniques that can detect incorrect DNN behaviors and improve DNN quality are extremely necessary and critical. However, the testing oracle, which defines the correct output for a given input, is often not available in the automated testing. To obtain the oracle information, the testing tasks of DNN-based systems usually require expensive human efforts to label the testing data, which significantly slows down the process of quality assurance.  
<br/>

To mitigate this problem, we propose DeepGini, a test prioritization technique designed based on a statistical perspective of DNN. Such a statistical perspective allows us to reduce the problem of measuring misclassification probability to the problem of measuring set impurity, which allows us to quickly identify possibly-misclassified tests. To evaluate, we conduct an extensive empirical study on popular datasets and prevalent DNN models. The experimental results demonstrate that DeepGini outperforms existing coverage-based techniques in prioritizing tests regarding both effectiveness and efficiency. Meanwhile, we observe that the tests prioritized at the front by DeepGini are more effective in improving the DNN quality in comparison with the coverage-based techniques.<br/>
        <br />
        <a href="issta20main-id149-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Feist, Josselin  </td>
  <td>
    <span onclick="toggle('issta20tool-id13-p-feistjosselin')" title="Echidna: Effective, Usable, and Fast Fuzzing for Smart Contracts  --  Gustavo Grieco, Will Song, Artur Cygan, Josselin Feist, and Alex Groce" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20-TOOL: "Echidna: Effective, Usable, ..."</span></small></a>
    </span>

    <span id="issta20tool-id13-p-feistjosselin"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20tool-id13-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20tool-id13-p-feistjosselin')" 
      >
        <a id="issta20tool-id13-p-titlefeistjosselin" >
          <span style="font-size: 100%">
            Echidna: Effective, Usable, and Fast Fuzzing for Smart Contracts
          </span>
        </a>
      </span>
      <br />
      Gustavo Grieco, Will Song, Artur Cygan, Josselin Feist, and <a href="http://www.cs.cmu.edu/~agroce" target="_blank">Alex Groce</a><br />
      <i><small>(Trail of Bits, USA; Northern Arizona University, USA)</small></i><br />
      <span id="issta20tool-id13-p-absfeistjosselin" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Ethereum smart contracts---autonomous programs that run on a blockchain---often control transactions of financial and intellectual property. Because of the critical role they play, smart contracts need complete, comprehensive, and effective test generation. This paper introduces an open-source smart contract fuzzer called Echidna that makes it easy to automatically generate tests to detect violations in assertions and custom properties. Echidna is easy to install and does not require a complex configuration or deployment of contracts to a local blockchain. It offers responsive feedback, captures many property violations, and its default settings are calibrated based on experimental data. To date, Echidna has been used in more than 10 large paid security audits, and feedback from those audits has driven the features and user experience of Echidna, both in terms of practical usability (e.g., smart contract frameworks like Truffle and Embark) and test generation strategies. Echidna aims to be good at finding real bugs in smart contracts, with minimal user effort and maximal speed.<br/>
        <br />
        <a href="issta20tool-id13-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
      <a href="https://github.com/crytic/echidna"><img width="15" src="../images/tool.png" alt="" /><span style="font-size: 90%"> Info</span></a>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Feng, Yang  </td>
  <td>
    <span onclick="toggle('issta20main-id149-p-fengyang')" title="DeepGini: Prioritizing Massive Tests to Enhance the Robustness of Deep Neural Networks  --  Yang Feng, Qingkai Shi, Xinyu Gao, Jun Wan, Chunrong Fang, and Zhenyu Chen" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "DeepGini: Prioritizing Massive ..."</span></small></a>
    </span>

    <span id="issta20main-id149-p-fengyang"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id149-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id149-p-fengyang')" 
      >
        <a id="issta20main-id149-p-titlefengyang" >
          <span style="font-size: 100%">
            DeepGini: Prioritizing Massive Tests to Enhance the Robustness of Deep Neural Networks
          </span>
        </a>
      </span>
      <br />
      Yang Feng, Qingkai Shi, Xinyu Gao, Jun Wan, Chunrong Fang, and <a href="http://software.nju.edu.cn/zychen/" target="_blank">Zhenyu Chen</a><br />
      <i><small>(Nanjing University, China; Hong Kong University of Science and Technology, China; Ant Financial Services, China)</small></i><br />
      <span id="issta20main-id149-p-absfengyang" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Deep neural networks (DNN) have been deployed in many software systems to assist in various classification tasks. In company with the fantastic effectiveness in classification, DNNs could also exhibit incorrect behaviors and result in accidents and losses. Therefore, testing techniques that can detect incorrect DNN behaviors and improve DNN quality are extremely necessary and critical. However, the testing oracle, which defines the correct output for a given input, is often not available in the automated testing. To obtain the oracle information, the testing tasks of DNN-based systems usually require expensive human efforts to label the testing data, which significantly slows down the process of quality assurance.  
<br/>

To mitigate this problem, we propose DeepGini, a test prioritization technique designed based on a statistical perspective of DNN. Such a statistical perspective allows us to reduce the problem of measuring misclassification probability to the problem of measuring set impurity, which allows us to quickly identify possibly-misclassified tests. To evaluate, we conduct an extensive empirical study on popular datasets and prevalent DNN models. The experimental results demonstrate that DeepGini outperforms existing coverage-based techniques in prioritizing tests regarding both effectiveness and efficiency. Meanwhile, we observe that the tests prioritized at the front by DeepGini are more effective in improving the DNN quality in comparison with the coverage-based techniques.<br/>
        <br />
        <a href="issta20main-id149-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
    <span onclick="toggle('issta20tool-id28-p-fengyang')" title="Test Recommendation System Based on Slicing Coverage Filtering  --  Ruixiang Qian, Yuan Zhao, Duo Men, Yang Feng, Qingkai Shi, Yong Huang, and Zhenyu Chen" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20-TOOL: "Test Recommendation System ..."</span></small></a>
    </span>

    <span id="issta20tool-id28-p-fengyang"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20tool-id28-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20tool-id28-p-fengyang')" 
      >
        <a id="issta20tool-id28-p-titlefengyang" >
          <span style="font-size: 100%">
            Test Recommendation System Based on Slicing Coverage Filtering
          </span>
        </a>
      </span>
      <br />
      Ruixiang Qian, Yuan Zhao, Duo Men, Yang Feng, Qingkai Shi, Yong Huang, and <a href="http://software.nju.edu.cn/zychen/" target="_blank">Zhenyu Chen</a><br />
      <i><small>(Nanjing University, China; Hong Kong University of Science and Technology, China; Mooctest, China)</small></i><br />
      <span id="issta20tool-id28-p-absfengyang" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Software testing plays a crucial role in software lifecycle. As a basic approach of software testing, unit testing is one of the necessary skills for software practitioners. Since testers are required to understand the inner code of the software under test(SUT) while writing a test case, testers usually need to learn how to detect the bug within SUT effectively. When novice programmers started to learn writing unit tests, they will generally watch a video lesson or reading unit tests written by others. These learning approaches are either time-consuming or too hard for a novice. To solve these problems, we developed a system, named TeSRS, to assist novice programmers to learn unit testing. TeSRS is a test recommendation system which can effectively assist test novice in learning unit testing. Utilizing program slice technique, TeSRS has gotten an enormous amount of test snippets from superior crowdsourcing test scripts. Depending on these test snippets, TeSRS provides novices a easier way for unit test learning. To sum up, TeSRS can help test novices (1) obtain high level design ideas of unit test case and (2) improve capabilities(e.g. branch coverage rate and mutation coverage rate) of their test scripts. TeSRS has built a scalable corpus composed of over 8000 test snippets from more than 25 test problems. Its stable performance shows effectiveness in unit test learning. <br/>Demo video can be found at <a>https://youtu.be/xvrLdvU8zFA</a><br/>
        <br />
        <a href="issta20tool-id28-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
      <a href="https://www.youtube.com/watch?v=xvrLdvU8zFA"><img width="15" src="../images/video.png" alt="" /><span style="font-size: 90%"> Video</span></a>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Fioraldi, Andrea  </td>
  <td>
    <span onclick="toggle('issta20main-id31-p-fioraldiandrea')" title="WEIZZ: Automatic Grey-Box Fuzzing for Structured Binary Formats  --  Andrea Fioraldi, Daniele Cono D'Elia, and Emilio Coppa" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "WEIZZ: Automatic Grey-Box ..."</span></small></a>
    </span>

    <span id="issta20main-id31-p-fioraldiandrea"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id31-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id31-p-fioraldiandrea')" 
      >
        <a id="issta20main-id31-p-titlefioraldiandrea" >
          <span style="font-size: 100%">
            WEIZZ: Automatic Grey-Box Fuzzing for Structured Binary Formats
          </span>
        </a>
      </span>
      <br />
      Andrea Fioraldi, Daniele Cono D'Elia, and Emilio Coppa<br />
      <i><small>(Sapienza University of Rome, Italy)</small></i><br />
      <span id="issta20main-id31-p-absfioraldiandrea" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Fuzzing technologies have evolved at a fast pace in recent years, revealing bugs in programs with ever increasing depth and speed. Applications working with complex formats are however more difficult to take on, as inputs need to meet certain format-specific characteristics to get through the initial parsing stage and reach deeper behaviors of the program.  
<br/>

Unlike prior proposals based on manually written format specifications, we propose a technique to automatically generate and mutate inputs for unknown chunk-based binary formats. We identify dependencies between input bytes and comparison instructions, and use them to assign tags that characterize the processing logic of the program. Tags become the building block for structure-aware mutations involving chunks and fields of the input.  
<br/>

Our technique can perform comparably to structure-aware fuzzing proposals that require human assistance. Our prototype implementation WEIZZ revealed 16 unknown bugs in widely used programs.<br/>
        <br />
        <a href="issta20main-id31-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
      <a href="https://github.com/andreafioraldi/weizz-fuzzer"><img width="15" src="../images/tool.png" alt="" /><span style="font-size: 90%"> Info</span></a>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Fourtounis, George  </td>
  <td>
    <span onclick="toggle('issta20main-id167-p-fourtounisgeorge')" title="Identifying Java Calls in Native Code via Binary Scanning  --  George Fourtounis, Leonidas Triantafyllou, and Yannis Smaragdakis" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Identifying Java Calls in ..."</span></small></a>
    </span>

    <span id="issta20main-id167-p-fourtounisgeorge"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id167-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id167-p-fourtounisgeorge')" 
      >
        <a id="issta20main-id167-p-titlefourtounisgeorge" >
          <span style="font-size: 100%">
            Identifying Java Calls in Native Code via Binary Scanning
          </span>
        </a>
      </span>
      <br />
      George Fourtounis, Leonidas Triantafyllou, and Yannis Smaragdakis<br />
      <i><small>(University of Athens, Greece)</small></i><br />
      <span id="issta20main-id167-p-absfourtounisgeorge" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Current Java static analyzers, operating either on the source or bytecode level, exhibit unsoundness for programs that contain native code. We show that the Java Native Interface (JNI) specification, which is used by Java programs to interoperate with Java code, is principled enough to permit static reasoning about the effects of native code on program execution when it comes to call-backs. Our approach consists of disassembling native binaries, recovering static symbol information that corresponds to Java method signatures, and producing a model for statically exercising these native call-backs with appropriate mock objects. The approach manages to recover virtually all Java calls in native code, for both Android and Java desktop applications&#8212;(a) achieving 100% native-to-application call-graph recall on large Android applications (Chrome, Instagram) and (b) capturing the full native call-back behavior of the XCorpus suite programs.<br/>
        <br />
        <a href="issta20main-id167-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
      <a href="https://zenodo.org/record/3833964"><img width="15" src="../images/tool.png" alt="" /><span style="font-size: 90%"> Info</span></a>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_available_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Available</span></a>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_evaluated_functional_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Functional</span></a>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Fraser, Gordon  </td>
  <td>
    <span onclick="toggle('issta20main-id134-p-frasergordon')" title="Recovering Fitness Gradients for Interprocedural Boolean Flags in Search-Based Testing  --  Yun Lin, Jun Sun, Gordon Fraser, Ziheng Xiu, Ting Liu, and Jin Song Dong" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Recovering Fitness Gradients ..."</span></small></a>
    </span>

    <span id="issta20main-id134-p-frasergordon"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id134-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id134-p-frasergordon')" 
      >
        <a id="issta20main-id134-p-titlefrasergordon" >
          <span style="font-size: 100%">
            Recovering Fitness Gradients for Interprocedural Boolean Flags in Search-Based Testing
          </span>
        </a>
      </span>
      <br />
      <a href="http://linyun.info/" target="_blank">Yun Lin</a>, Jun Sun, Gordon Fraser, Ziheng Xiu, Ting Liu, and Jin Song Dong<br />
      <i><small>(National University of Singapore, Singapore; Singapore Management University, Singapore; University of Passau, Germany; Xi&#39;an Jiaotong University, China)</small></i><br />
      <span id="issta20main-id134-p-absfrasergordon" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              In Search-based Software Testing (SBST), test generation is guided by fitness functions that estimate how close a test case is to reach an uncovered test goal (e.g., branch). A popular fitness function estimates how close conditional statements are to evaluating to true or false, i.e., the branch distance. However, when conditions read Boolean variables (e.g., if(x &amp;&amp; y)), the branch distance provides no gradient for the search, since a Boolean can either be true or false. This flag problem can be addressed by transforming individual procedures such that Boolean flags are replaced with numeric comparisons that provide better guidance for the search. Unfortunately, defining a semantics-preserving transformation that is applicable in an interprocedural case, where Boolean flags are passed around as parameters and return values, is a daunting task. Thus, it is not yet supported by modern test generators. <br/>This work is based on the insight that fitness gradients can be recovered by using runtime information: Given an uncovered interprocedural flag branch, our approach (1) calculates context-sensitive branch distance for all control flows potentially returning the required flag in the called method, and (2) recursively aggregates these distances into a continuous value. We implemented our approach on top of the EvoSuite framework for Java, and empirically compared it with state-of-the-art testability transformations on non-trivial methods suffering from interprocedural flag problems, sampled from open source Java projects. Our experiment demonstrates that our approach achieves higher coverage on the subject methods with statistical significance and acceptable runtime overheads.<br/>
        <br />
        <a href="issta20main-id134-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;"><a id="G"> </a>Gad, Ahmed
  </td>
  <td>
    <span onclick="toggle('issta20main-id27-p-gadahmed')" title="Scalable Build Service System with Smart Scheduling Service  --  Kaiyuan Wang, Greg Tener, Vijay Gullapalli, Xin Huang, Ahmed Gad, and Daniel Rall" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Scalable Build Service System ..."</span></small></a>
    </span>

    <span id="issta20main-id27-p-gadahmed"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id27-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id27-p-gadahmed')" 
      >
        <a id="issta20main-id27-p-titlegadahmed" >
          <span style="font-size: 100%">
            Scalable Build Service System with Smart Scheduling Service
          </span>
        </a>
      </span>
      <br />
      Kaiyuan Wang, Greg Tener, Vijay Gullapalli, Xin Huang, Ahmed Gad, and Daniel Rall<br />
      <i><small>(Google, USA)</small></i><br />
      <span id="issta20main-id27-p-absgadahmed" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Build automation is critical for developers to check if their code compiles, passes all tests and is safe to deploy to the server. Many companies adopt Continuous Integration (CI) services to make sure that the code changes from multiple developers can be safely merged at the head of the project. Internally, CI triggers builds to make sure that the new code change compiles and passes the tests. For any large company which has a monolithic code repository and thousands of developers, it is hard to make sure that all code changes are safe to submit in a timely manner. The reason is that each code change may involve multiple builds, and the company needs to run millions of builds every day to guarantee developers&#8217; productivity.  
<br/>

Google is one of those large companies that need a scalable build service to support developers&#8217; work. More than 100,000 code changes are submitted to our repository on average each day, including changes from either human users or automated tools. More than 15 million builds are executed on average each day. In this paper, we first describe an overview of our scalable build service architecture. Then, we discuss more details about how we make build scheduling decisions. Finally, we discuss some experience in the scalability of the build service system and the performance of the build scheduling service.<br/>
        <br />
        <a href="issta20main-id27-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Gallagher, John P.  </td>
  <td>
    <span onclick="toggle('issta20main-id2-p-gallagherjohnp')" title="Detecting and Diagnosing Energy Issues for Mobile Applications  --  Xueliang Li, Yuming Yang, Yepang Liu, John P. Gallagher, and Kaishun Wu" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Detecting and Diagnosing Energy ..."</span></small></a>
    </span>

    <span id="issta20main-id2-p-gallagherjohnp"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id2-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id2-p-gallagherjohnp')" 
      >
        <a id="issta20main-id2-p-titlegallagherjohnp" >
          <span style="font-size: 100%">
            Detecting and Diagnosing Energy Issues for Mobile Applications
          </span>
        </a>
      </span>
      <br />
      Xueliang Li, Yuming Yang, Yepang Liu, John P. Gallagher, and Kaishun Wu<br />
      <i><small>(Shenzhen University, China; Southern University of Science and Technology, China; Roskilde University, Denmark; IMDEA Software Institute, Spain)</small></i><br />
      <span id="issta20main-id2-p-absgallagherjohnp" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Energy efficiency is an important criterion to judge the quality of mobile apps, but one third of our randomly sampled apps suffer from energy issues that can quickly drain battery power. To understand these issues, we conducted an empirical study on 27 well-maintained apps such as Chrome and Firefox, whose issue tracking systems are publicly accessible. Our study revealed that the main root causes of energy issues include unnecessary workload and excessively frequent operations. Surprisingly, these issues are beyond the application of present technology on energy issue detection. We also found that 25.0% of energy issues can only manifest themselves under specific contexts such as poor network performance, but such contexts are again neglected by present technology. In this paper, we propose a novel testing framework for detecting energy issues in real-world mobile apps. Our framework examines apps with well-designed input sequences and runtime contexts. To identify the root causes mentioned above, we employed a machine learning algorithm to cluster the workloads and further evaluate their necessity. For the issues concealed by the specific contexts, we carefully set up several execution contexts to catch them. More importantly, we designed leading edge technology, e.g. pre-designing input sequences with potential energy overuse and tuning tests on-the-fly, to achieve high efficacy in detecting energy issues. A large-scale evaluation shows that 91.6% issues detected in our experiments were previously unknown to developers. On average, these issues double the energy costs of the apps. Our testing technique achieves a low number of false positives.<br/>
        <br />
        <a href="issta20main-id2-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Gao, Jianbo  </td>
  <td>
    <span onclick="toggle('issta20tool-id11-p-gaojianbo')" title="EShield: Protect Smart Contracts against Reverse Engineering  --  Wentian Yan, Jianbo Gao, Zhenhao Wu, Yue Li, Zhi Guan, Qingshan Li, and Zhong Chen" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20-TOOL: "EShield: Protect Smart Contracts ..."</span></small></a>
    </span>

    <span id="issta20tool-id11-p-gaojianbo"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20tool-id11-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20tool-id11-p-gaojianbo')" 
      >
        <a id="issta20tool-id11-p-titlegaojianbo" >
          <span style="font-size: 100%">
            EShield: Protect Smart Contracts against Reverse Engineering
          </span>
        </a>
      </span>
      <br />
      Wentian Yan, Jianbo Gao, Zhenhao Wu, Yue Li, Zhi Guan, Qingshan Li, and Zhong Chen<br />
      <i><small>(Peking University, China; Boya Blockchain, China)</small></i><br />
      <span id="issta20tool-id11-p-absgaojianbo" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Smart contracts are the back-end programs of blockchain-based applications and the execution results are deterministic and publicly visible. Developers are unwilling to release source code of some smart contracts to generate randomness or for security reasons, however, attackers still can use reverse engineering tools to decompile and analyze the code. In this paper, we propose EShield, an automated security enhancement tool for protecting smart contracts against reverse engineering. EShield replaces original instructions of operating jump addresses with anti-patterns to interfere with control flow recovery from bytecode. We have implemented four methods in EShield and conducted an experiment on over 20k smart contracts. The evaluation results show that all the protected smart contracts are resistant to three different reverse engineering tools with little extra gas cost.<br/>
        <br />
        <a href="issta20tool-id11-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Gao, Xinyu  </td>
  <td>
    <span onclick="toggle('issta20main-id149-p-gaoxinyu')" title="DeepGini: Prioritizing Massive Tests to Enhance the Robustness of Deep Neural Networks  --  Yang Feng, Qingkai Shi, Xinyu Gao, Jun Wan, Chunrong Fang, and Zhenyu Chen" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "DeepGini: Prioritizing Massive ..."</span></small></a>
    </span>

    <span id="issta20main-id149-p-gaoxinyu"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id149-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id149-p-gaoxinyu')" 
      >
        <a id="issta20main-id149-p-titlegaoxinyu" >
          <span style="font-size: 100%">
            DeepGini: Prioritizing Massive Tests to Enhance the Robustness of Deep Neural Networks
          </span>
        </a>
      </span>
      <br />
      Yang Feng, Qingkai Shi, Xinyu Gao, Jun Wan, Chunrong Fang, and <a href="http://software.nju.edu.cn/zychen/" target="_blank">Zhenyu Chen</a><br />
      <i><small>(Nanjing University, China; Hong Kong University of Science and Technology, China; Ant Financial Services, China)</small></i><br />
      <span id="issta20main-id149-p-absgaoxinyu" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Deep neural networks (DNN) have been deployed in many software systems to assist in various classification tasks. In company with the fantastic effectiveness in classification, DNNs could also exhibit incorrect behaviors and result in accidents and losses. Therefore, testing techniques that can detect incorrect DNN behaviors and improve DNN quality are extremely necessary and critical. However, the testing oracle, which defines the correct output for a given input, is often not available in the automated testing. To obtain the oracle information, the testing tasks of DNN-based systems usually require expensive human efforts to label the testing data, which significantly slows down the process of quality assurance.  
<br/>

To mitigate this problem, we propose DeepGini, a test prioritization technique designed based on a statistical perspective of DNN. Such a statistical perspective allows us to reduce the problem of measuring misclassification probability to the problem of measuring set impurity, which allows us to quickly identify possibly-misclassified tests. To evaluate, we conduct an extensive empirical study on popular datasets and prevalent DNN models. The experimental results demonstrate that DeepGini outperforms existing coverage-based techniques in prioritizing tests regarding both effectiveness and efficiency. Meanwhile, we observe that the tests prioritized at the front by DeepGini are more effective in improving the DNN quality in comparison with the coverage-based techniques.<br/>
        <br />
        <a href="issta20main-id149-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Gao, Yu  </td>
  <td>
    <span onclick="toggle('issta20main-id139-p-gaoyu')" title="Detecting Cache-Related Bugs in Spark Applications  --  Hui Li, Dong Wang, Tianze Huang, Yu Gao, Wensheng Dou, Lijie Xu, Wei Wang, Jun Wei, and Hua Zhong" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Detecting Cache-Related Bugs ..."</span></small></a>
    </span>

    <span id="issta20main-id139-p-gaoyu"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id139-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id139-p-gaoyu')" 
      >
        <a id="issta20main-id139-p-titlegaoyu" >
          <span style="font-size: 100%">
            Detecting Cache-Related Bugs in Spark Applications
          </span>
        </a>
      </span>
      <br />
      Hui Li, Dong Wang, Tianze Huang, Yu Gao, <a href="http://www.tcse.cn/~wsdou/" target="_blank">Wensheng Dou</a>, Lijie Xu, Wei Wang, Jun Wei, and Hua Zhong<br />
      <i><small>(Institute of Software at Chinese Academy of Sciences, China; University of Chinese Academy of Sciences, China; Beijing University of Posts and Telecommunications, China)</small></i><br />
      <span id="issta20main-id139-p-absgaoyu" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Apache Spark has been widely used to build big data applications. Spark utilizes the abstraction of Resilient Distributed Dataset (RDD) to store and retrieve large-scale data. To reduce duplicate computation of an RDD, Spark can cache the RDD in memory and then reuse it later, thus improving performance. Spark relies on application developers to enforce caching decisions by using <em>persist</em>() and <em>unpersist</em>() APIs, e.g., <em>which</em> RDD is persisted and <em>when</em> the RDD is persisted / unpersisted. Incorrect RDD caching decisions can cause duplicate computations, or waste precious memory resource, thus introducing serious performance degradation in Spark applications. In this paper, we propose <em>CacheCheck</em>, to automatically detect cache-related bugs in Spark applications. We summarize six cache-related bug patterns in Spark applications, and then dynamically detect cache-related bugs by analyzing the execution traces of Spark applications. We evaluate CacheCheck on six real-world Spark applications. The experimental result shows that CacheCheck detects 72 previously unknown cache-related bugs, and 28 of them have been fixed by developers.<br/>
        <br />
        <a href="issta20main-id139-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_available_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Available</span></a>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_evaluated_reusable_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Reusable</span></a>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_evaluated_functional_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Functional</span></a>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Ghaleb, Asem  </td>
  <td>
    <span onclick="toggle('issta20main-id58-p-ghalebasem')" title="How Effective Are Smart Contract Analysis Tools? Evaluating Smart Contract Static Analysis Tools using Bug Injection  --  Asem Ghaleb and Karthik Pattabiraman" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "How Effective Are Smart Contract ..."</span></small></a>
    </span>

    <span id="issta20main-id58-p-ghalebasem"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id58-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id58-p-ghalebasem')" 
      >
        <a id="issta20main-id58-p-titleghalebasem" >
          <span style="font-size: 100%">
            How Effective Are Smart Contract Analysis Tools? Evaluating Smart Contract Static Analysis Tools using Bug Injection
          </span>
        </a>
      </span>
      <br />
      Asem Ghaleb and <a href="http://blogs.ubc.ca/karthik/" target="_blank">Karthik Pattabiraman</a><br />
      <i><small>(University of British Columbia, Canada)</small></i><br />
      <span id="issta20main-id58-p-absghalebasem" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Security attacks targeting smart contracts have been on the rise, which have led to financial loss and erosion of trust. Therefore, it is important to enable developers to discover security vulnerabilities in smart contracts before deployment. A number of static analysis tools have been developed for finding security bugs in smart contracts. However, despite the numerous bug-finding tools, there is no systematic approach to evaluate the proposed tools and gauge their effectiveness. This paper proposes SolidiFI, an automated and systematic approach for evaluating smart contracts&#8217; static analysis tools. SolidiFI is based on injecting bugs (i.e., code defects) into all potential locations in a smart contract to introduce targeted security vulnerabilities. SolidiFI then checks the generated buggy contract using the static analysis tools, and identifies the bugs that the tools are unable to detect (false-negatives) along with identifying the bugs reported as false-positives. SolidiFI is used to evaluate six widely-used static analysis tools, namely, Oyente, Securify, Mythril, SmartCheck, Manticore and Slither, using a set of 50 contracts injected by 9369 distinct bugs. It finds several instances of bugs that are not detected by the evaluated tools despite their claims of being able to detect such bugs, and all the tools report many false positives.<br/>
        <br />
        <a href="issta20main-id58-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
      <a href="https://github.com/DependableSystemsLab/SolidiFI"><img width="15" src="../images/tool.png" alt="" /><span style="font-size: 90%"> Info</span></a>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_available_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Available</span></a>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_evaluated_functional_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Functional</span></a>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Ghanbari, Ali  </td>
  <td>
    <span onclick="toggle('issta20main-id22-p-ghanbariali')" title="Can Automated Program Repair Refine Fault Localization? A Unified Debugging Approach  --  Yiling Lou, Ali Ghanbari, Xia Li, Lingming Zhang, Haotian Zhang, Dan Hao, and Lu Zhang" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Can Automated Program Repair ..."</span></small></a>
    </span>

    <span id="issta20main-id22-p-ghanbariali"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id22-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id22-p-ghanbariali')" 
      >
        <a id="issta20main-id22-p-titleghanbariali" >
          <span style="font-size: 100%">
            Can Automated Program Repair Refine Fault Localization? A Unified Debugging Approach
          </span>
        </a>
      </span>
      <br />
      Yiling Lou, Ali Ghanbari, Xia Li, Lingming Zhang, Haotian Zhang, Dan Hao, and Lu Zhang<br />
      <i><small>(Peking University, China; University of Texas at Dallas, USA; Ant Financial Services, China)</small></i><br />
      <span id="issta20main-id22-p-absghanbariali" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              A large body of research efforts have been dedicated to automated software debugging, including both automated fault localization and program repair. However, existing fault localization techniques have limited effectiveness on real-world software systems while even the most advanced program repair techniques can only fix a small ratio of real-world bugs. Although fault localization and program repair are inherently connected, their only existing connection in the literature is that program repair techniques usually use off-the-shelf fault localization techniques (e.g., Ochiai) to determine the potential candidate statements/elements for patching. In this work, we propose the unified debugging approach to unify the two areas in the other direction for the first time, i.e., can program repair in turn help with fault localization? In this way, we not only open a new dimension for more powerful fault localization, but also extend the application scope of program repair to all possible bugs (not only the bugs that can be directly automatically fixed). We have designed ProFL to leverage patch-execution results (from program repair) as the feedback information for fault localization. The experimental results on the widely used Defects4J benchmark show that the basic ProFL can already at least localize 37.61% more bugs within Top-1 than state-of-the-art spectrum and mutation based fault localization. Furthermore, ProFL can boost state-of-the-art fault localization via both unsupervised and supervised learning. Meanwhile, we have demonstrated ProFL&#39;s effectiveness under different settings and through a case study within Alipay, a popular online payment system with over 1 billion global users.<br/>
        <br />
        <a href="issta20main-id22-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_available_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Available</span></a>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_evaluated_reusable_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Reusable</span></a>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_evaluated_functional_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Functional</span></a>
    </span>
    <span onclick="toggle('issta20tool-id1-p-ghanbariali')" title="ObjSim: Lightweight Automatic Patch Prioritization via Object Similarity  --  Ali Ghanbari" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20-TOOL: "ObjSim: Lightweight Automatic ..."</span></small></a>
    </span>

    <span id="issta20tool-id1-p-ghanbariali"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20tool-id1-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20tool-id1-p-ghanbariali')" 
      >
        <a id="issta20tool-id1-p-titleghanbariali" >
          <span style="font-size: 100%">
            ObjSim: Lightweight Automatic Patch Prioritization via Object Similarity
          </span>
        </a>
      </span>
      <br />
      Ali Ghanbari<br />
      <i><small>(University of Texas at Dallas, USA)</small></i><br />
      <span id="issta20tool-id1-p-absghanbariali" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              In the context of test case based automatic program repair (APR), patches that pass all the test cases but fail to fix the bug are called overfitted patches. Currently, patches generated by APR tools get inspected manually by the users to find and adopt genuine fixes. Being a laborious activity hindering widespread adoption of APR, automatic identification of overfitted patches has lately been the topic of active research. This paper presents engineering details of ObjSim: a fully automatic, lightweight similarity-based patch prioritization tool for JVM-based languages. The tool works by comparing the system state at the exit point(s) of patched method before and after patching and prioritizing patches that result in state that is more similar to that of original, unpatched version on passing tests while less similar on failing ones. Our experiments with patches generated by the recent APR tool PraPR for fixable bugs from Defects4J v1.4.0 show that ObjSim prioritizes 16.67% more genuine fixes in top-1 place. A demo video of the tool is located at https://bit.ly/2K8gnYV.<br/>
        <br />
        <a href="issta20tool-id1-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
      <a href="https://bit.ly/2K8gnYV"><img width="15" src="../images/video.png" alt="" /><span style="font-size: 90%"> Video</span></a>
      <a href="https://github.com/ali-ghanbari/objsim"><img width="15" src="../images/tool.png" alt="" /><span style="font-size: 90%"> Info</span></a>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;"><a href="http://users.ece.utexas.edu/~gligoric/">Gligoric, Milos</a>  </td>
  <td>
    <span onclick="toggle('issta20main-id166-p-gligoricmilos')" title="Debugging the Performance of Maven’s Test Isolation: Experience Report  --  Pengyu Nie, Ahmet Celik, Matthew Coley, Aleksandar Milicevic, Jonathan Bell, and Milos Gligoric" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Debugging the Performance ..."</span></small></a>
    </span>

    <span id="issta20main-id166-p-gligoricmilos"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id166-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id166-p-gligoricmilos')" 
      >
        <a id="issta20main-id166-p-titlegligoricmilos" >
          <span style="font-size: 100%">
            Debugging the Performance of Maven’s Test Isolation: Experience Report
          </span>
        </a>
      </span>
      <br />
      Pengyu Nie, Ahmet Celik, Matthew Coley, <a href="https://aleksandarmilicevic.github.io/" target="_blank">Aleksandar Milicevic</a>, Jonathan Bell, and <a href="http://users.ece.utexas.edu/~gligoric/" target="_blank">Milos Gligoric</a><br />
      <i><small>(University of Texas at Austin, USA; Facebook, USA; George Mason University, USA; Microsoft, USA)</small></i><br />
      <span id="issta20main-id166-p-absgligoricmilos" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Testing is the most common approach used in industry for checking software correctness. Developers frequently practice reliable testing-executing individual tests in isolation from each other-to avoid test failures caused by test-order dependencies and shared state pollution (e.g., when tests mutate static fields). A common way of doing this is by running each test as a separate process. Unfortunately, this is known to introduce substantial overhead. This experience report describes our efforts to better understand the sources of this overhead and to create a system to confirm the minimal overhead possible. We found that different build systems use different mechanisms for communicating between these multiple processes, and that because of this design decision, running tests with some build systems could be faster than with others. Through this inquiry we discovered a significant performance bug in Apache Maven&#8217;s test running code, which slowed down test execution by on average 350 milliseconds per-test when compared to a competing build system, Ant. When used for testing real projects, this can result in a significant reduction in testing time. We submitted a patch for this bug which has been integrated into the Apache Maven build system, and describe our ongoing efforts to improve Maven&#8217;s test execution tooling.<br/>
        <br />
        <a href="issta20main-id166-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Godefroid, Patrice  </td>
  <td>
    <span onclick="toggle('issta20main-id90-p-godefroidpatrice')" title="Differential Regression Testing for REST APIs  --  Patrice Godefroid, Daniel Lehmann, and Marina Polishchuk" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Differential Regression Testing ..."</span></small></a>
    </span>

    <span id="issta20main-id90-p-godefroidpatrice"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id90-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id90-p-godefroidpatrice')" 
      >
        <a id="issta20main-id90-p-titlegodefroidpatrice" >
          <span style="font-size: 100%">
            Differential Regression Testing for REST APIs
          </span>
        </a>
      </span>
      <br />
      Patrice Godefroid, Daniel Lehmann, and Marina Polishchuk<br />
      <i><small>(Microsoft Research, USA; University of Stuttgart, Germany)</small></i><br />
      <span id="issta20main-id90-p-absgodefroidpatrice" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Cloud services are programmatically accessed through REST APIs. Since REST APIs are constantly evolving, an important problem is how to prevent breaking changes of APIs, while supporting several different versions. To find such breaking changes in an automated way, we introduce differential regression testing for REST APIs.  
Our approach is based on two observations. First, breaking changes in REST APIs involve two software components, namely the client and the service. As such, there are also two types of regressions: regressions in the API specification, i.e., in the contract between the client and the service, and regressions in the service itself, i.e., previously working requests are &quot;broken&quot; in later versions of the service. Finding both kinds of regressions involves testing along two dimensions: when the service changes and when the specification changes.  
Second, to detect such bugs automatically, we employ differential testing. That is, we compare the behavior of different versions on the same inputs against each other, and find regressions in the observed differences. For generating inputs (sequences of HTTP requests) to services, we use RESTler, a stateful fuzzer for REST APIs. Comparing the outputs (HTTP responses) of a cloud service involves several challenges, like abstracting over minor differences, handling out-of-order requests, and non-determinism.  
Differential regression testing across 17 different versions of the widely-used Azure networking APIs deployed between 2016 and 2019 detected 14 regressions in total, 5 of those in the official API specifications and 9 regressions in the services themselves.<br/>
        <br />
        <a href="issta20main-id90-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Gopinath, Rahul  </td>
  <td>
    <span onclick="toggle('issta20main-id136-p-gopinathrahul')" title="Abstracting Failure-Inducing Inputs  --  Rahul Gopinath, Alexander Kampmann, Nikolas Havrikov, Ezekiel O. Soremekun, and Andreas Zeller" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Abstracting Failure-Inducing ..."</span></small></a>
    </span>

    <span id="issta20main-id136-p-gopinathrahul"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id136-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id136-p-gopinathrahul')" 
      >
        <a id="issta20main-id136-p-titlegopinathrahul" >
          <span style="font-size: 100%">
            Abstracting Failure-Inducing Inputs
          </span>
        </a>
      </span>
      <br />
      Rahul Gopinath, Alexander Kampmann, Nikolas Havrikov, Ezekiel O. Soremekun, and Andreas Zeller<br />
      <i><small>(CISPA, Germany)</small></i><br />
      <span id="issta20main-id136-p-absgopinathrahul" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              A program fails. Under which circumstances does the failure occur? Starting with a single failure-inducing input (&quot;The input ((4)) fails&quot;) and an input grammar, the DDSET algorithm uses systematic tests to automatically generalize the input to an abstract failure-inducing input that contains both (concrete) terminal symbols and (abstract) nonterminal symbols from the grammar&#8212;for instance, &quot;((&#60;expr&#62;))&quot;, which represents any expression &#60;expr&#62; in double parentheses. Such an abstract failure-inducing input can be used (1) as a debugging diagnostic, characterizing the circumstances under which a failure occurs (&quot;The error occurs whenever an expression is enclosed in double parentheses&quot;); (2) as a producer of additional failure-inducing tests to help design and validate fixes and repair candidates (&quot;The inputs ((1)), ((3 * 4)), and many more also fail&quot;). In its evaluation on real-world bugs in JavaScript, Clojure, Lua, and UNIX command line utilities, DDSET&#8217;s abstract failure-inducing inputs provided to-the-point diagnostics, and precise producers for further failure inducing inputs.<br/>
        <br />
        <a href="issta20main-id136-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
      <a href="https://github.com/vrthra/ddset"><img width="15" src="../images/tool.png" alt="" /><span style="font-size: 90%"> Info</span></a>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_available_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Available</span></a>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_evaluated_reusable_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Reusable</span></a>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_evaluated_functional_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Functional</span></a>
          <span style="font-size: 80%; color: blue;"> 
            <img width="20" src="../images/award.svg" alt="" />
            ACM SIGSOFT Distinguished Paper Award</span>
    </span>
    <span onclick="toggle('issta20main-id130-p-gopinathrahul')" title="Learning Input Tokens for Effective Fuzzing  --  Björn Mathis, Rahul Gopinath, and Andreas Zeller" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Learning Input Tokens for ..."</span></small></a>
    </span>

    <span id="issta20main-id130-p-gopinathrahul"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id130-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id130-p-gopinathrahul')" 
      >
        <a id="issta20main-id130-p-titlegopinathrahul" >
          <span style="font-size: 100%">
            Learning Input Tokens for Effective Fuzzing
          </span>
        </a>
      </span>
      <br />
      Björn Mathis, Rahul Gopinath, and Andreas Zeller<br />
      <i><small>(CISPA, Germany)</small></i><br />
      <span id="issta20main-id130-p-absgopinathrahul" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Modern fuzzing tools like AFL operate at a lexical level: They explore the input space of tested programs one byte after another. For inputs with complex syntactical properties, this is very inefficient, as keywords and other tokens have to be composed one character at a time. Fuzzers thus allow to specify dictionaries listing possible tokens the input can be composed from; such dictionaries speed up fuzzers dramatically. Also, fuzzers make use of dynamic tainting to track input tokens and infer values that are expected in the input validation phase. Unfortunately, such tokens are usually implicitly converted to program specific values which causes a loss of the taints attached to the input data in the lexical phase.  
In this paper, we present a technique to extend dynamic tainting to not only track explicit data flows but also taint implicitly converted data without suffering from taint explosion. This extension makes it possible to augment existing techniques and automatically infer a set of tokens and seed inputs for the input language of a program given nothing but the source code. Specifically targeting the lexical analysis of an input processor, our lFuzzer test generator systematically explores branches of the lexical analysis, producing a set of tokens that fully cover all decisions seen. The resulting set of tokens can be directly used as a dictionary for fuzzing. Along with the token extraction seed inputs are generated which give further fuzzing processes a head start. In our experiments, the lFuzzer-AFL combination achieves up to 17% more coverage on complex input formats like json, lisp, tinyC, and JavaScript compared to AFL.<br/>
        <br />
        <a href="issta20main-id130-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_available_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Available</span></a>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_evaluated_functional_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Functional</span></a>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Grieco, Gustavo  </td>
  <td>
    <span onclick="toggle('issta20tool-id13-p-griecogustavo')" title="Echidna: Effective, Usable, and Fast Fuzzing for Smart Contracts  --  Gustavo Grieco, Will Song, Artur Cygan, Josselin Feist, and Alex Groce" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20-TOOL: "Echidna: Effective, Usable, ..."</span></small></a>
    </span>

    <span id="issta20tool-id13-p-griecogustavo"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20tool-id13-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20tool-id13-p-griecogustavo')" 
      >
        <a id="issta20tool-id13-p-titlegriecogustavo" >
          <span style="font-size: 100%">
            Echidna: Effective, Usable, and Fast Fuzzing for Smart Contracts
          </span>
        </a>
      </span>
      <br />
      Gustavo Grieco, Will Song, Artur Cygan, Josselin Feist, and <a href="http://www.cs.cmu.edu/~agroce" target="_blank">Alex Groce</a><br />
      <i><small>(Trail of Bits, USA; Northern Arizona University, USA)</small></i><br />
      <span id="issta20tool-id13-p-absgriecogustavo" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Ethereum smart contracts---autonomous programs that run on a blockchain---often control transactions of financial and intellectual property. Because of the critical role they play, smart contracts need complete, comprehensive, and effective test generation. This paper introduces an open-source smart contract fuzzer called Echidna that makes it easy to automatically generate tests to detect violations in assertions and custom properties. Echidna is easy to install and does not require a complex configuration or deployment of contracts to a local blockchain. It offers responsive feedback, captures many property violations, and its default settings are calibrated based on experimental data. To date, Echidna has been used in more than 10 large paid security audits, and feedback from those audits has driven the features and user experience of Echidna, both in terms of practical usability (e.g., smart contract frameworks like Truffle and Embark) and test generation strategies. Echidna aims to be good at finding real bugs in smart contracts, with minimal user effort and maximal speed.<br/>
        <br />
        <a href="issta20tool-id13-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
      <a href="https://github.com/crytic/echidna"><img width="15" src="../images/tool.png" alt="" /><span style="font-size: 90%"> Info</span></a>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;"><a href="http://www.cs.cmu.edu/~agroce">Groce, Alex</a>  </td>
  <td>
    <span onclick="toggle('issta20tool-id13-p-grocealex')" title="Echidna: Effective, Usable, and Fast Fuzzing for Smart Contracts  --  Gustavo Grieco, Will Song, Artur Cygan, Josselin Feist, and Alex Groce" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20-TOOL: "Echidna: Effective, Usable, ..."</span></small></a>
    </span>

    <span id="issta20tool-id13-p-grocealex"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20tool-id13-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20tool-id13-p-grocealex')" 
      >
        <a id="issta20tool-id13-p-titlegrocealex" >
          <span style="font-size: 100%">
            Echidna: Effective, Usable, and Fast Fuzzing for Smart Contracts
          </span>
        </a>
      </span>
      <br />
      Gustavo Grieco, Will Song, Artur Cygan, Josselin Feist, and <a href="http://www.cs.cmu.edu/~agroce" target="_blank">Alex Groce</a><br />
      <i><small>(Trail of Bits, USA; Northern Arizona University, USA)</small></i><br />
      <span id="issta20tool-id13-p-absgrocealex" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Ethereum smart contracts---autonomous programs that run on a blockchain---often control transactions of financial and intellectual property. Because of the critical role they play, smart contracts need complete, comprehensive, and effective test generation. This paper introduces an open-source smart contract fuzzer called Echidna that makes it easy to automatically generate tests to detect violations in assertions and custom properties. Echidna is easy to install and does not require a complex configuration or deployment of contracts to a local blockchain. It offers responsive feedback, captures many property violations, and its default settings are calibrated based on experimental data. To date, Echidna has been used in more than 10 large paid security audits, and feedback from those audits has driven the features and user experience of Echidna, both in terms of practical usability (e.g., smart contract frameworks like Truffle and Embark) and test generation strategies. Echidna aims to be good at finding real bugs in smart contracts, with minimal user effort and maximal speed.<br/>
        <br />
        <a href="issta20tool-id13-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
      <a href="https://github.com/crytic/echidna"><img width="15" src="../images/tool.png" alt="" /><span style="font-size: 90%"> Info</span></a>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Guan, Zhi  </td>
  <td>
    <span onclick="toggle('issta20tool-id11-p-guanzhi')" title="EShield: Protect Smart Contracts against Reverse Engineering  --  Wentian Yan, Jianbo Gao, Zhenhao Wu, Yue Li, Zhi Guan, Qingshan Li, and Zhong Chen" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20-TOOL: "EShield: Protect Smart Contracts ..."</span></small></a>
    </span>

    <span id="issta20tool-id11-p-guanzhi"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20tool-id11-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20tool-id11-p-guanzhi')" 
      >
        <a id="issta20tool-id11-p-titleguanzhi" >
          <span style="font-size: 100%">
            EShield: Protect Smart Contracts against Reverse Engineering
          </span>
        </a>
      </span>
      <br />
      Wentian Yan, Jianbo Gao, Zhenhao Wu, Yue Li, Zhi Guan, Qingshan Li, and Zhong Chen<br />
      <i><small>(Peking University, China; Boya Blockchain, China)</small></i><br />
      <span id="issta20tool-id11-p-absguanzhi" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Smart contracts are the back-end programs of blockchain-based applications and the execution results are deterministic and publicly visible. Developers are unwilling to release source code of some smart contracts to generate randomness or for security reasons, however, attackers still can use reverse engineering tools to decompile and analyze the code. In this paper, we propose EShield, an automated security enhancement tool for protecting smart contracts against reverse engineering. EShield replaces original instructions of operating jump addresses with anti-patterns to interfere with control flow recovery from bytecode. We have implemented four methods in EShield and conducted an experiment on over 20k smart contracts. The evaluation results show that all the protected smart contracts are resistant to three different reverse engineering tools with little extra gas cost.<br/>
        <br />
        <a href="issta20tool-id11-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Gullapalli, Vijay  </td>
  <td>
    <span onclick="toggle('issta20main-id27-p-gullapallivijay')" title="Scalable Build Service System with Smart Scheduling Service  --  Kaiyuan Wang, Greg Tener, Vijay Gullapalli, Xin Huang, Ahmed Gad, and Daniel Rall" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Scalable Build Service System ..."</span></small></a>
    </span>

    <span id="issta20main-id27-p-gullapallivijay"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id27-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id27-p-gullapallivijay')" 
      >
        <a id="issta20main-id27-p-titlegullapallivijay" >
          <span style="font-size: 100%">
            Scalable Build Service System with Smart Scheduling Service
          </span>
        </a>
      </span>
      <br />
      Kaiyuan Wang, Greg Tener, Vijay Gullapalli, Xin Huang, Ahmed Gad, and Daniel Rall<br />
      <i><small>(Google, USA)</small></i><br />
      <span id="issta20main-id27-p-absgullapallivijay" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Build automation is critical for developers to check if their code compiles, passes all tests and is safe to deploy to the server. Many companies adopt Continuous Integration (CI) services to make sure that the code changes from multiple developers can be safely merged at the head of the project. Internally, CI triggers builds to make sure that the new code change compiles and passes the tests. For any large company which has a monolithic code repository and thousands of developers, it is hard to make sure that all code changes are safe to submit in a timely manner. The reason is that each code change may involve multiple builds, and the company needs to run millions of builds every day to guarantee developers&#8217; productivity.  
<br/>

Google is one of those large companies that need a scalable build service to support developers&#8217; work. More than 100,000 code changes are submitted to our repository on average each day, including changes from either human users or automated tools. More than 15 million builds are executed on average each day. In this paper, we first describe an overview of our scalable build service architecture. Then, we discuss more details about how we make build scheduling decisions. Finally, we discuss some experience in the scalability of the build service system and the performance of the build scheduling service.<br/>
        <br />
        <a href="issta20main-id27-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Guo, Chao  </td>
  <td>
    <span onclick="toggle('issta20tool-id7-p-guochao')" title="Crowdsourced Requirements Generation for Automatic Testing via Knowledge Graph  --  Chao Guo, Tieke He, Wei Yuan, Yue Guo, and Rui Hao" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20-TOOL: "Crowdsourced Requirements ..."</span></small></a>
    </span>

    <span id="issta20tool-id7-p-guochao"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20tool-id7-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20tool-id7-p-guochao')" 
      >
        <a id="issta20tool-id7-p-titleguochao" >
          <span style="font-size: 100%">
            Crowdsourced Requirements Generation for Automatic Testing via Knowledge Graph
          </span>
        </a>
      </span>
      <br />
      Chao Guo, Tieke He, Wei Yuan, Yue Guo, and Rui Hao<br />
      <i><small>(Nanjing University, China)</small></i><br />
      <span id="issta20tool-id7-p-absguochao" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Crowdsourced testing provides an effective way to deal with the problem of Android system fragmentation, as well as the application scenario diversity faced by Android testing. The generation of test requirements is a significant part of crowdsourced testing. However, manually generating crowdsourced testing requirements is tedious, which requires the issuers to have the domain knowledge of the Android application under test. To solve these problems, we have developed a tool named KARA, short for Knowledge Graph Aided Crowdsourced Requirements Generation for Android Testing. KARA first analyzes the result of automatic testing on the Android application, through which the operation sequences can be obtained. Then, the knowledge graph of the target application is constructed in a manner of pay-as-you-go. Finally, KARA utilizes knowledge graph and the automatic testing result to generate crowdsourced testing requirements with domain knowledge. Experiments prove that the test requirements generated by KARA are well understandable, and KARA can improve the quality of crowdsourced testing. The demo video can be found at https://youtu.be/kE-dOiekWWM.<br/>
        <br />
        <a href="issta20tool-id7-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Guo, Yue  </td>
  <td>
    <span onclick="toggle('issta20tool-id7-p-guoyue')" title="Crowdsourced Requirements Generation for Automatic Testing via Knowledge Graph  --  Chao Guo, Tieke He, Wei Yuan, Yue Guo, and Rui Hao" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20-TOOL: "Crowdsourced Requirements ..."</span></small></a>
    </span>

    <span id="issta20tool-id7-p-guoyue"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20tool-id7-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20tool-id7-p-guoyue')" 
      >
        <a id="issta20tool-id7-p-titleguoyue" >
          <span style="font-size: 100%">
            Crowdsourced Requirements Generation for Automatic Testing via Knowledge Graph
          </span>
        </a>
      </span>
      <br />
      Chao Guo, Tieke He, Wei Yuan, Yue Guo, and Rui Hao<br />
      <i><small>(Nanjing University, China)</small></i><br />
      <span id="issta20tool-id7-p-absguoyue" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Crowdsourced testing provides an effective way to deal with the problem of Android system fragmentation, as well as the application scenario diversity faced by Android testing. The generation of test requirements is a significant part of crowdsourced testing. However, manually generating crowdsourced testing requirements is tedious, which requires the issuers to have the domain knowledge of the Android application under test. To solve these problems, we have developed a tool named KARA, short for Knowledge Graph Aided Crowdsourced Requirements Generation for Android Testing. KARA first analyzes the result of automatic testing on the Android application, through which the operation sequences can be obtained. Then, the knowledge graph of the target application is constructed in a manner of pay-as-you-go. Finally, KARA utilizes knowledge graph and the automatic testing result to generate crowdsourced testing requirements with domain knowledge. Experiments prove that the test requirements generated by KARA are well understandable, and KARA can improve the quality of crowdsourced testing. The demo video can be found at https://youtu.be/kE-dOiekWWM.<br/>
        <br />
        <a href="issta20tool-id7-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Guo, Zichen  </td>
  <td>
    <span onclick="toggle('issta20tool-id8-p-guozichen')" title="TauJud: Test Augmentation of Machine Learning in Judicial Documents  --  Zichen Guo, Jiawei Liu, Tieke He, Zhuoyang Li, and Peitian Zhangzhu" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20-TOOL: "TauJud: Test Augmentation ..."</span></small></a>
    </span>

    <span id="issta20tool-id8-p-guozichen"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20tool-id8-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20tool-id8-p-guozichen')" 
      >
        <a id="issta20tool-id8-p-titleguozichen" >
          <span style="font-size: 100%">
            TauJud: Test Augmentation of Machine Learning in Judicial Documents
          </span>
        </a>
      </span>
      <br />
      Zichen Guo, Jiawei Liu, Tieke He, Zhuoyang Li, and Peitian Zhangzhu<br />
      <i><small>(Nanjing University, China)</small></i><br />
      <span id="issta20tool-id8-p-absguozichen" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              The booming of big data makes the adoption of machine learning ubiquitous in the legal field. As we all know, a large amount of test data can better reflect the performance of the model, so the test data must be naturally expanded. In order to solve the high cost problem of labeling data in natural language processing, people in the industry have improved the performance of text classification tasks through simple data amplification techniques. However, the data amplification requirements in the judgment documents are interpretable and logical, as observed from CAIL2018 test data with over 200,000 judicial documents. Therefore, we have designed a test augmentation tool called TauJud specifically for generating more effective test data with uniform distribution over time and location for model evaluation and save time in marking data. The demo can be found at https://github.com/governormars/TauJud.<br/>
        <br />
        <a href="issta20tool-id8-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;"><a id="H"> </a>Haller, Philipp
  </td>
  <td>
    <span onclick="toggle('issta20main-id78-p-hallerphilipp')" title="A Programming Model for Semi-implicit Parallelization of Static Analyses  --  Dominik Helm, Florian Kübler, Jan Thomas Kölzer, Philipp Haller, Michael Eichberg, Guido Salvaneschi, and Mira Mezini" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "A Programming Model for Semi-implicit ..."</span></small></a>
    </span>

    <span id="issta20main-id78-p-hallerphilipp"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id78-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id78-p-hallerphilipp')" 
      >
        <a id="issta20main-id78-p-titlehallerphilipp" >
          <span style="font-size: 100%">
            A Programming Model for Semi-implicit Parallelization of Static Analyses
          </span>
        </a>
      </span>
      <br />
      Dominik Helm, Florian Kübler, Jan Thomas Kölzer, Philipp Haller, Michael Eichberg, Guido Salvaneschi, and Mira Mezini<br />
      <i><small>(TU Darmstadt, Germany; KTH, Sweden)</small></i><br />
      <span id="issta20main-id78-p-abshallerphilipp" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Parallelization of static analyses is necessary to scale to real-world programs, but it is a complex and difficult task and, therefore, often only done manually for selected high-profile analyses. In this paper, we propose a programming model for semi-implicit parallelization of static analyses which is inspired by reactive programming. Reusing the domain-expert knowledge on how to parallelize anal-  
yses encoded in the programming framework, developers do not need to think about parallelization and concurrency issues on their own. The programming model supports stateful computations, only requires monotonic computations over lattices, and is independent of specific analyses. Our evaluation shows the applicability of the programming model to different analyses and the importance of user-selected scheduling strategies. We implemented an IFDS solver that was able to outperform a state-of-the-art, specialized parallel IFDS solver both in absolute performance and scalability.<br/>
        <br />
        <a href="issta20main-id78-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Hao, Dan  </td>
  <td>
    <span onclick="toggle('issta20main-id22-p-haodan')" title="Can Automated Program Repair Refine Fault Localization? A Unified Debugging Approach  --  Yiling Lou, Ali Ghanbari, Xia Li, Lingming Zhang, Haotian Zhang, Dan Hao, and Lu Zhang" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Can Automated Program Repair ..."</span></small></a>
    </span>

    <span id="issta20main-id22-p-haodan"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id22-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id22-p-haodan')" 
      >
        <a id="issta20main-id22-p-titlehaodan" >
          <span style="font-size: 100%">
            Can Automated Program Repair Refine Fault Localization? A Unified Debugging Approach
          </span>
        </a>
      </span>
      <br />
      Yiling Lou, Ali Ghanbari, Xia Li, Lingming Zhang, Haotian Zhang, Dan Hao, and Lu Zhang<br />
      <i><small>(Peking University, China; University of Texas at Dallas, USA; Ant Financial Services, China)</small></i><br />
      <span id="issta20main-id22-p-abshaodan" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              A large body of research efforts have been dedicated to automated software debugging, including both automated fault localization and program repair. However, existing fault localization techniques have limited effectiveness on real-world software systems while even the most advanced program repair techniques can only fix a small ratio of real-world bugs. Although fault localization and program repair are inherently connected, their only existing connection in the literature is that program repair techniques usually use off-the-shelf fault localization techniques (e.g., Ochiai) to determine the potential candidate statements/elements for patching. In this work, we propose the unified debugging approach to unify the two areas in the other direction for the first time, i.e., can program repair in turn help with fault localization? In this way, we not only open a new dimension for more powerful fault localization, but also extend the application scope of program repair to all possible bugs (not only the bugs that can be directly automatically fixed). We have designed ProFL to leverage patch-execution results (from program repair) as the feedback information for fault localization. The experimental results on the widely used Defects4J benchmark show that the basic ProFL can already at least localize 37.61% more bugs within Top-1 than state-of-the-art spectrum and mutation based fault localization. Furthermore, ProFL can boost state-of-the-art fault localization via both unsupervised and supervised learning. Meanwhile, we have demonstrated ProFL&#39;s effectiveness under different settings and through a case study within Alipay, a popular online payment system with over 1 billion global users.<br/>
        <br />
        <a href="issta20main-id22-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_available_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Available</span></a>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_evaluated_reusable_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Reusable</span></a>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_evaluated_functional_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Functional</span></a>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Hao, Rui  </td>
  <td>
    <span onclick="toggle('issta20tool-id7-p-haorui')" title="Crowdsourced Requirements Generation for Automatic Testing via Knowledge Graph  --  Chao Guo, Tieke He, Wei Yuan, Yue Guo, and Rui Hao" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20-TOOL: "Crowdsourced Requirements ..."</span></small></a>
    </span>

    <span id="issta20tool-id7-p-haorui"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20tool-id7-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20tool-id7-p-haorui')" 
      >
        <a id="issta20tool-id7-p-titlehaorui" >
          <span style="font-size: 100%">
            Crowdsourced Requirements Generation for Automatic Testing via Knowledge Graph
          </span>
        </a>
      </span>
      <br />
      Chao Guo, Tieke He, Wei Yuan, Yue Guo, and Rui Hao<br />
      <i><small>(Nanjing University, China)</small></i><br />
      <span id="issta20tool-id7-p-abshaorui" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Crowdsourced testing provides an effective way to deal with the problem of Android system fragmentation, as well as the application scenario diversity faced by Android testing. The generation of test requirements is a significant part of crowdsourced testing. However, manually generating crowdsourced testing requirements is tedious, which requires the issuers to have the domain knowledge of the Android application under test. To solve these problems, we have developed a tool named KARA, short for Knowledge Graph Aided Crowdsourced Requirements Generation for Android Testing. KARA first analyzes the result of automatic testing on the Android application, through which the operation sequences can be obtained. Then, the knowledge graph of the target application is constructed in a manner of pay-as-you-go. Finally, KARA utilizes knowledge graph and the automatic testing result to generate crowdsourced testing requirements with domain knowledge. Experiments prove that the test requirements generated by KARA are well understandable, and KARA can improve the quality of crowdsourced testing. The demo video can be found at https://youtu.be/kE-dOiekWWM.<br/>
        <br />
        <a href="issta20tool-id7-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Havrikov, Nikolas  </td>
  <td>
    <span onclick="toggle('issta20main-id136-p-havrikovnikolas')" title="Abstracting Failure-Inducing Inputs  --  Rahul Gopinath, Alexander Kampmann, Nikolas Havrikov, Ezekiel O. Soremekun, and Andreas Zeller" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Abstracting Failure-Inducing ..."</span></small></a>
    </span>

    <span id="issta20main-id136-p-havrikovnikolas"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id136-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id136-p-havrikovnikolas')" 
      >
        <a id="issta20main-id136-p-titlehavrikovnikolas" >
          <span style="font-size: 100%">
            Abstracting Failure-Inducing Inputs
          </span>
        </a>
      </span>
      <br />
      Rahul Gopinath, Alexander Kampmann, Nikolas Havrikov, Ezekiel O. Soremekun, and Andreas Zeller<br />
      <i><small>(CISPA, Germany)</small></i><br />
      <span id="issta20main-id136-p-abshavrikovnikolas" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              A program fails. Under which circumstances does the failure occur? Starting with a single failure-inducing input (&quot;The input ((4)) fails&quot;) and an input grammar, the DDSET algorithm uses systematic tests to automatically generalize the input to an abstract failure-inducing input that contains both (concrete) terminal symbols and (abstract) nonterminal symbols from the grammar&#8212;for instance, &quot;((&#60;expr&#62;))&quot;, which represents any expression &#60;expr&#62; in double parentheses. Such an abstract failure-inducing input can be used (1) as a debugging diagnostic, characterizing the circumstances under which a failure occurs (&quot;The error occurs whenever an expression is enclosed in double parentheses&quot;); (2) as a producer of additional failure-inducing tests to help design and validate fixes and repair candidates (&quot;The inputs ((1)), ((3 * 4)), and many more also fail&quot;). In its evaluation on real-world bugs in JavaScript, Clojure, Lua, and UNIX command line utilities, DDSET&#8217;s abstract failure-inducing inputs provided to-the-point diagnostics, and precise producers for further failure inducing inputs.<br/>
        <br />
        <a href="issta20main-id136-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
      <a href="https://github.com/vrthra/ddset"><img width="15" src="../images/tool.png" alt="" /><span style="font-size: 90%"> Info</span></a>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_available_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Available</span></a>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_evaluated_reusable_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Reusable</span></a>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_evaluated_functional_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Functional</span></a>
          <span style="font-size: 80%; color: blue;"> 
            <img width="20" src="../images/award.svg" alt="" />
            ACM SIGSOFT Distinguished Paper Award</span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">He, Tieke  </td>
  <td>
    <span onclick="toggle('issta20tool-id7-p-hetieke')" title="Crowdsourced Requirements Generation for Automatic Testing via Knowledge Graph  --  Chao Guo, Tieke He, Wei Yuan, Yue Guo, and Rui Hao" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20-TOOL: "Crowdsourced Requirements ..."</span></small></a>
    </span>

    <span id="issta20tool-id7-p-hetieke"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20tool-id7-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20tool-id7-p-hetieke')" 
      >
        <a id="issta20tool-id7-p-titlehetieke" >
          <span style="font-size: 100%">
            Crowdsourced Requirements Generation for Automatic Testing via Knowledge Graph
          </span>
        </a>
      </span>
      <br />
      Chao Guo, Tieke He, Wei Yuan, Yue Guo, and Rui Hao<br />
      <i><small>(Nanjing University, China)</small></i><br />
      <span id="issta20tool-id7-p-abshetieke" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Crowdsourced testing provides an effective way to deal with the problem of Android system fragmentation, as well as the application scenario diversity faced by Android testing. The generation of test requirements is a significant part of crowdsourced testing. However, manually generating crowdsourced testing requirements is tedious, which requires the issuers to have the domain knowledge of the Android application under test. To solve these problems, we have developed a tool named KARA, short for Knowledge Graph Aided Crowdsourced Requirements Generation for Android Testing. KARA first analyzes the result of automatic testing on the Android application, through which the operation sequences can be obtained. Then, the knowledge graph of the target application is constructed in a manner of pay-as-you-go. Finally, KARA utilizes knowledge graph and the automatic testing result to generate crowdsourced testing requirements with domain knowledge. Experiments prove that the test requirements generated by KARA are well understandable, and KARA can improve the quality of crowdsourced testing. The demo video can be found at https://youtu.be/kE-dOiekWWM.<br/>
        <br />
        <a href="issta20tool-id7-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
    <span onclick="toggle('issta20tool-id8-p-hetieke')" title="TauJud: Test Augmentation of Machine Learning in Judicial Documents  --  Zichen Guo, Jiawei Liu, Tieke He, Zhuoyang Li, and Peitian Zhangzhu" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20-TOOL: "TauJud: Test Augmentation ..."</span></small></a>
    </span>

    <span id="issta20tool-id8-p-hetieke"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20tool-id8-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20tool-id8-p-hetieke')" 
      >
        <a id="issta20tool-id8-p-titlehetieke" >
          <span style="font-size: 100%">
            TauJud: Test Augmentation of Machine Learning in Judicial Documents
          </span>
        </a>
      </span>
      <br />
      Zichen Guo, Jiawei Liu, Tieke He, Zhuoyang Li, and Peitian Zhangzhu<br />
      <i><small>(Nanjing University, China)</small></i><br />
      <span id="issta20tool-id8-p-abshetieke" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              The booming of big data makes the adoption of machine learning ubiquitous in the legal field. As we all know, a large amount of test data can better reflect the performance of the model, so the test data must be naturally expanded. In order to solve the high cost problem of labeling data in natural language processing, people in the industry have improved the performance of text classification tasks through simple data amplification techniques. However, the data amplification requirements in the judgment documents are interpretable and logical, as observed from CAIL2018 test data with over 200,000 judicial documents. Therefore, we have designed a test augmentation tool called TauJud specifically for generating more effective test data with uniform distribution over time and location for model evaluation and save time in marking data. The demo can be found at https://github.com/governormars/TauJud.<br/>
        <br />
        <a href="issta20tool-id8-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">He, Xiao  </td>
  <td>
    <span onclick="toggle('issta20main-id76-p-hexiao')" title="Testing High Performance Numerical Simulation Programs: Experience, Lessons Learned, and Open Issues  --  Xiao He, Xingwei Wang, Jia Shi, and Yi Liu" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Testing High Performance Numerical ..."</span></small></a>
    </span>

    <span id="issta20main-id76-p-hexiao"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id76-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id76-p-hexiao')" 
      >
        <a id="issta20main-id76-p-titlehexiao" >
          <span style="font-size: 100%">
            Testing High Performance Numerical Simulation Programs: Experience, Lessons Learned, and Open Issues
          </span>
        </a>
      </span>
      <br />
      Xiao He, Xingwei Wang, Jia Shi, and Yi Liu<br />
      <i><small>(University of Science and Technology Beijing, China; CNCERT/CC, China)</small></i><br />
      <span id="issta20main-id76-p-abshexiao" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              High performance numerical simulation programs are widely used to simulate actual physical processes on high performance computers for the analysis of various physical and engineering problems. They are usually regarded as non-testable due to their high complexity. This paper reports our real experience and lessons learned from testing five simulation programs that will be used to design and analyze nuclear power plants. We applied five testing approaches and found 33 bugs. We found that property-based testing and metamorphic testing are two effective methods. Nevertheless, we suffered from the lack of domain knowledge, the high test costs, the shortage of test cases, severe oracle issues, and inadequate automation support. Consequently, the five programs are not exhaustively tested from the perspective of software testing, and many existing software testing techniques and tools are not fully applicable due to scalability and portability issues. We need more collaboration and communication with other communities to promote the research and application of software testing techniques.<br/>
        <br />
        <a href="issta20main-id76-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Helm, Dominik  </td>
  <td>
    <span onclick="toggle('issta20main-id78-p-helmdominik')" title="A Programming Model for Semi-implicit Parallelization of Static Analyses  --  Dominik Helm, Florian Kübler, Jan Thomas Kölzer, Philipp Haller, Michael Eichberg, Guido Salvaneschi, and Mira Mezini" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "A Programming Model for Semi-implicit ..."</span></small></a>
    </span>

    <span id="issta20main-id78-p-helmdominik"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id78-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id78-p-helmdominik')" 
      >
        <a id="issta20main-id78-p-titlehelmdominik" >
          <span style="font-size: 100%">
            A Programming Model for Semi-implicit Parallelization of Static Analyses
          </span>
        </a>
      </span>
      <br />
      Dominik Helm, Florian Kübler, Jan Thomas Kölzer, Philipp Haller, Michael Eichberg, Guido Salvaneschi, and Mira Mezini<br />
      <i><small>(TU Darmstadt, Germany; KTH, Sweden)</small></i><br />
      <span id="issta20main-id78-p-abshelmdominik" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Parallelization of static analyses is necessary to scale to real-world programs, but it is a complex and difficult task and, therefore, often only done manually for selected high-profile analyses. In this paper, we propose a programming model for semi-implicit parallelization of static analyses which is inspired by reactive programming. Reusing the domain-expert knowledge on how to parallelize anal-  
yses encoded in the programming framework, developers do not need to think about parallelization and concurrency issues on their own. The programming model supports stateful computations, only requires monotonic computations over lattices, and is independent of specific analyses. Our evaluation shows the applicability of the programming model to different analyses and the importance of user-selected scheduling strategies. We implemented an IFDS solver that was able to outperform a state-of-the-art, specialized parallel IFDS solver both in absolute performance and scalability.<br/>
        <br />
        <a href="issta20main-id78-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Hildebrandt, Carl  </td>
  <td>
    <span onclick="toggle('issta20main-id108-p-hildebrandtcarl')" title="Feasible and Stressful Trajectory Generation for Mobile Robots  --  Carl Hildebrandt, Sebastian Elbaum, Nicola Bezzo, and Matthew B. Dwyer" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Feasible and Stressful Trajectory ..."</span></small></a>
    </span>

    <span id="issta20main-id108-p-hildebrandtcarl"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id108-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id108-p-hildebrandtcarl')" 
      >
        <a id="issta20main-id108-p-titlehildebrandtcarl" >
          <span style="font-size: 100%">
            Feasible and Stressful Trajectory Generation for Mobile Robots
          </span>
        </a>
      </span>
      <br />
      Carl Hildebrandt, Sebastian Elbaum, Nicola Bezzo, and Matthew B. Dwyer<br />
      <i><small>(University of Virginia, USA)</small></i><br />
      <span id="issta20main-id108-p-abshildebrandtcarl" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              While executing nominal tests on mobile robots is required for their validation, such tests may overlook faults that arise under trajectories that accentuate certain aspects of the robot&#39;s behavior. Uncovering such stressful trajectories is challenging as the input space for these systems, as they move, is extremely large, and the relation between a planned trajectory and its potential to induce stress can be subtle. To address this challenge we propose a framework that 1) integrates kinematic and dynamic physical models of the robot into the automated trajectory generation in order to generate valid trajectories, and 2) incorporates a parameterizable scoring model to efficiently generate physically valid yet stressful trajectories for a broad range of mobile robots. We evaluate our approach on four variants of a state-of-the-art quadrotor in a racing simulator. We find that, for non-trivial length trajectories, the incorporation of the kinematic and dynamic model is crucial to generate any valid trajectory, and that the approach with the best hand-crafted scoring model and with a trained scoring model can cause on average a 55.9% and 41.3% more stress than a random selection among valid trajectories. A follow-up study shows that the approach was able to induce similar stress on a deployed commercial quadrotor, with trajectories that deviated up to 6m from the intended ones.<br/>
        <br />
        <a href="issta20main-id108-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
      <a href="https://hildebrandt-carl.github.io/RobotTestGenerationArtifact/"><img width="15" src="../images/tool.png" alt="" /><span style="font-size: 90%"> Info</span></a>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_available_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Available</span></a>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_evaluated_reusable_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Reusable</span></a>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_evaluated_functional_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Functional</span></a>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Huang, An  </td>
  <td>
    <span onclick="toggle('issta20main-id155-p-huangan')" title="Reinforcement Learning Based Curiosity-Driven Testing of Android Applications  --  Minxue Pan, An Huang, Guoxin Wang, Tian Zhang, and Xuandong Li" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Reinforcement Learning Based ..."</span></small></a>
    </span>

    <span id="issta20main-id155-p-huangan"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id155-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id155-p-huangan')" 
      >
        <a id="issta20main-id155-p-titlehuangan" >
          <span style="font-size: 100%">
            Reinforcement Learning Based Curiosity-Driven Testing of Android Applications
          </span>
        </a>
      </span>
      <br />
      Minxue Pan, An Huang, Guoxin Wang, Tian Zhang, and Xuandong Li<br />
      <i><small>(Nanjing University, China)</small></i><br />
      <span id="issta20main-id155-p-abshuangan" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Mobile applications play an important role in our daily life, while it still remains a challenge to guarantee their correctness. Model-based and systematic approaches have been applied to Android GUI testing. However, they do not show significant advantages over random approaches because of limitations such as imprecise models and poor scalability. In this paper, we propose Q-testing, a reinforcement learning based approach which benefits from both random and model-based approaches to automated testing of Android applications. Q-testing explores the Android apps with a curiosity-driven strategy that utilizes a memory set to record part of previously visited states and guides the testing towards unfamiliar functionalities. A state comparison module, which is a neural network trained by plenty of collected samples, is novelly employed to divide different states at the granularity of functional scenarios. It can determine the reinforcement learning reward in Q-testing and help the curiosity-driven strategy explore different functionalities efficiently. We conduct experiments on 50 open-source applications where Q-testing outperforms the state-of-the-art and state-of-practice Android GUI testing tools in terms of code coverage and fault detection. So far, 22 of our reported faults have been confirmed, among which 7 have been fixed.<br/>
        <br />
        <a href="issta20main-id155-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
          <span style="font-size: 80%; color: blue;"> 
            <img width="20" src="../images/award.svg" alt="" />
            ACM SIGSOFT Distinguished Paper Award</span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Huang, Heqing  </td>
  <td>
    <span onclick="toggle('issta20main-id21-p-huangheqing')" title="Fast Bit-Vector Satisfiability  --  Peisen Yao, Qingkai Shi, Heqing Huang, and Charles Zhang" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Fast Bit-Vector Satisfiability ..."</span></small></a>
    </span>

    <span id="issta20main-id21-p-huangheqing"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id21-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id21-p-huangheqing')" 
      >
        <a id="issta20main-id21-p-titlehuangheqing" >
          <span style="font-size: 100%">
            Fast Bit-Vector Satisfiability
          </span>
        </a>
      </span>
      <br />
      Peisen Yao, Qingkai Shi, Heqing Huang, and Charles Zhang<br />
      <i><small>(Hong Kong University of Science and Technology, China)</small></i><br />
      <span id="issta20main-id21-p-abshuangheqing" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              SMT solving is often a major source of cost in a broad range of techniques such as symbolic program analysis.  
Thus, speeding up SMT solving is still an urgent requirement.  
A dominant approach, which is known as eager SMT solving, is to reduce a first-order formula to a pure Boolean formula, which is handed to an expensive SAT solver to determine the satisfiability.  
We observe that the SAT solver can utilize the knowledge in the first-order formula to boost its solving efficiency.  
Unfortunately, despite much progress, it is still not clear how to make use of the knowledge in an eager SMT solver.  
This paper addresses the problem by introducing a new and fast method,  
which utilizes the interval and data-dependence information learned from the first-order formulas.  
<br/>

We have implemented the approach as a tool called Trident and evaluated it on three symbolic analyzers (Angr, Qsym, and Pinpoint).  
The experimental results, based on seven million SMT solving instances generated for thirty real-world software systems, show that Trident significantly reduces the total solving time from 2.9X to 7.9X over three state-of-the-art SMT solvers (Z3, CVC4, and Boolector),  
without sacrificing the number of solved instances.  
We also demonstrate that Trident achieves  
end-to-end speedups for three program analysis clients by 1.9X, 1.6X, and 2.4X, respectively.<br/>
        <br />
        <a href="issta20main-id21-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Huang, Jeff  </td>
  <td>
    <span onclick="toggle('issta20main-id140-p-huangjeff')" title="Functional Code Clone Detection with Syntax and Semantics Fusion Learning  --  Chunrong Fang, Zixi Liu, Yangyang Shi, Jeff Huang, and Qingkai Shi" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Functional Code Clone Detection ..."</span></small></a>
    </span>

    <span id="issta20main-id140-p-huangjeff"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id140-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id140-p-huangjeff')" 
      >
        <a id="issta20main-id140-p-titlehuangjeff" >
          <span style="font-size: 100%">
            Functional Code Clone Detection with Syntax and Semantics Fusion Learning
          </span>
        </a>
      </span>
      <br />
      Chunrong Fang, Zixi Liu, Yangyang Shi, Jeff Huang, and Qingkai Shi<br />
      <i><small>(Nanjing University, China; Texas A&#38;M University, USA; Hong Kong University of Science and Technology, China)</small></i><br />
      <span id="issta20main-id140-p-abshuangjeff" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Clone detection of source code is among the most fundamental software engineering techniques. Despite intensive research in the past decade, existing techniques are still unsatisfactory in detecting &quot;functional&quot; code clones. In particular, existing techniques cannot efficiently extract syntax and semantics information from source code. In this paper, we propose a novel joint code representation that applies fusion embedding techniques to learn hidden syntactic and semantic features of source codes. Besides, we introduce a new granularity for functional code clone detection. Our approach regards the connected methods with caller-callee relationships as a functionality and the method without any caller-callee relationship with other methods represents a single functionality. Then we train a supervised deep learning model to detect functional code clones. We conduct evaluations on a large dataset of C++ programs and the experimental results show that fusion learning can significantly outperform the state-of-the-art techniques in detecting functional code clones.<br/>
        <br />
        <a href="issta20main-id140-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_available_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Available</span></a>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_evaluated_reusable_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Reusable</span></a>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_evaluated_functional_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Functional</span></a>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Huang, Tianze  </td>
  <td>
    <span onclick="toggle('issta20main-id139-p-huangtianze')" title="Detecting Cache-Related Bugs in Spark Applications  --  Hui Li, Dong Wang, Tianze Huang, Yu Gao, Wensheng Dou, Lijie Xu, Wei Wang, Jun Wei, and Hua Zhong" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Detecting Cache-Related Bugs ..."</span></small></a>
    </span>

    <span id="issta20main-id139-p-huangtianze"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id139-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id139-p-huangtianze')" 
      >
        <a id="issta20main-id139-p-titlehuangtianze" >
          <span style="font-size: 100%">
            Detecting Cache-Related Bugs in Spark Applications
          </span>
        </a>
      </span>
      <br />
      Hui Li, Dong Wang, Tianze Huang, Yu Gao, <a href="http://www.tcse.cn/~wsdou/" target="_blank">Wensheng Dou</a>, Lijie Xu, Wei Wang, Jun Wei, and Hua Zhong<br />
      <i><small>(Institute of Software at Chinese Academy of Sciences, China; University of Chinese Academy of Sciences, China; Beijing University of Posts and Telecommunications, China)</small></i><br />
      <span id="issta20main-id139-p-abshuangtianze" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Apache Spark has been widely used to build big data applications. Spark utilizes the abstraction of Resilient Distributed Dataset (RDD) to store and retrieve large-scale data. To reduce duplicate computation of an RDD, Spark can cache the RDD in memory and then reuse it later, thus improving performance. Spark relies on application developers to enforce caching decisions by using <em>persist</em>() and <em>unpersist</em>() APIs, e.g., <em>which</em> RDD is persisted and <em>when</em> the RDD is persisted / unpersisted. Incorrect RDD caching decisions can cause duplicate computations, or waste precious memory resource, thus introducing serious performance degradation in Spark applications. In this paper, we propose <em>CacheCheck</em>, to automatically detect cache-related bugs in Spark applications. We summarize six cache-related bug patterns in Spark applications, and then dynamically detect cache-related bugs by analyzing the execution traces of Spark applications. We evaluate CacheCheck on six real-world Spark applications. The experimental result shows that CacheCheck detects 72 previously unknown cache-related bugs, and 28 of them have been fixed by developers.<br/>
        <br />
        <a href="issta20main-id139-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_available_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Available</span></a>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_evaluated_reusable_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Reusable</span></a>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_evaluated_functional_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Functional</span></a>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Huang, Xin  </td>
  <td>
    <span onclick="toggle('issta20main-id27-p-huangxin')" title="Scalable Build Service System with Smart Scheduling Service  --  Kaiyuan Wang, Greg Tener, Vijay Gullapalli, Xin Huang, Ahmed Gad, and Daniel Rall" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Scalable Build Service System ..."</span></small></a>
    </span>

    <span id="issta20main-id27-p-huangxin"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id27-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id27-p-huangxin')" 
      >
        <a id="issta20main-id27-p-titlehuangxin" >
          <span style="font-size: 100%">
            Scalable Build Service System with Smart Scheduling Service
          </span>
        </a>
      </span>
      <br />
      Kaiyuan Wang, Greg Tener, Vijay Gullapalli, Xin Huang, Ahmed Gad, and Daniel Rall<br />
      <i><small>(Google, USA)</small></i><br />
      <span id="issta20main-id27-p-abshuangxin" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Build automation is critical for developers to check if their code compiles, passes all tests and is safe to deploy to the server. Many companies adopt Continuous Integration (CI) services to make sure that the code changes from multiple developers can be safely merged at the head of the project. Internally, CI triggers builds to make sure that the new code change compiles and passes the tests. For any large company which has a monolithic code repository and thousands of developers, it is hard to make sure that all code changes are safe to submit in a timely manner. The reason is that each code change may involve multiple builds, and the company needs to run millions of builds every day to guarantee developers&#8217; productivity.  
<br/>

Google is one of those large companies that need a scalable build service to support developers&#8217; work. More than 100,000 code changes are submitted to our repository on average each day, including changes from either human users or automated tools. More than 15 million builds are executed on average each day. In this paper, we first describe an overview of our scalable build service architecture. Then, we discuss more details about how we make build scheduling decisions. Finally, we discuss some experience in the scalability of the build service system and the performance of the build scheduling service.<br/>
        <br />
        <a href="issta20main-id27-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Huang, Yong  </td>
  <td>
    <span onclick="toggle('issta20tool-id28-p-huangyong')" title="Test Recommendation System Based on Slicing Coverage Filtering  --  Ruixiang Qian, Yuan Zhao, Duo Men, Yang Feng, Qingkai Shi, Yong Huang, and Zhenyu Chen" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20-TOOL: "Test Recommendation System ..."</span></small></a>
    </span>

    <span id="issta20tool-id28-p-huangyong"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20tool-id28-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20tool-id28-p-huangyong')" 
      >
        <a id="issta20tool-id28-p-titlehuangyong" >
          <span style="font-size: 100%">
            Test Recommendation System Based on Slicing Coverage Filtering
          </span>
        </a>
      </span>
      <br />
      Ruixiang Qian, Yuan Zhao, Duo Men, Yang Feng, Qingkai Shi, Yong Huang, and <a href="http://software.nju.edu.cn/zychen/" target="_blank">Zhenyu Chen</a><br />
      <i><small>(Nanjing University, China; Hong Kong University of Science and Technology, China; Mooctest, China)</small></i><br />
      <span id="issta20tool-id28-p-abshuangyong" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Software testing plays a crucial role in software lifecycle. As a basic approach of software testing, unit testing is one of the necessary skills for software practitioners. Since testers are required to understand the inner code of the software under test(SUT) while writing a test case, testers usually need to learn how to detect the bug within SUT effectively. When novice programmers started to learn writing unit tests, they will generally watch a video lesson or reading unit tests written by others. These learning approaches are either time-consuming or too hard for a novice. To solve these problems, we developed a system, named TeSRS, to assist novice programmers to learn unit testing. TeSRS is a test recommendation system which can effectively assist test novice in learning unit testing. Utilizing program slice technique, TeSRS has gotten an enormous amount of test snippets from superior crowdsourcing test scripts. Depending on these test snippets, TeSRS provides novices a easier way for unit test learning. To sum up, TeSRS can help test novices (1) obtain high level design ideas of unit test case and (2) improve capabilities(e.g. branch coverage rate and mutation coverage rate) of their test scripts. TeSRS has built a scalable corpus composed of over 8000 test snippets from more than 25 test problems. Its stable performance shows effectiveness in unit test learning. <br/>Demo video can be found at <a>https://youtu.be/xvrLdvU8zFA</a><br/>
        <br />
        <a href="issta20tool-id28-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
      <a href="https://www.youtube.com/watch?v=xvrLdvU8zFA"><img width="15" src="../images/video.png" alt="" /><span style="font-size: 90%"> Video</span></a>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;"><a id="J"> </a>Jain, Aryaman
  </td>
  <td>
    <span onclick="toggle('issta20main-id159-p-jainaryaman')" title="Detecting Flaky Tests in Probabilistic and Machine Learning Applications  --  Saikat Dutta, August Shi, Rutvik Choudhary, Zhekun Zhang, Aryaman Jain, and Sasa Misailovic" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Detecting Flaky Tests in Probabilistic ..."</span></small></a>
    </span>

    <span id="issta20main-id159-p-jainaryaman"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id159-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id159-p-jainaryaman')" 
      >
        <a id="issta20main-id159-p-titlejainaryaman" >
          <span style="font-size: 100%">
            Detecting Flaky Tests in Probabilistic and Machine Learning Applications
          </span>
        </a>
      </span>
      <br />
      Saikat Dutta, <a href="http://mir.cs.illinois.edu/~awshi2/" target="_blank">August Shi</a>, Rutvik Choudhary, Zhekun Zhang, Aryaman Jain, and Sasa Misailovic<br />
      <i><small>(University of Illinois at Urbana-Champaign, USA)</small></i><br />
      <span id="issta20main-id159-p-absjainaryaman" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Probabilistic programming systems and machine learning frameworks like Pyro, PyMC3, TensorFlow, and PyTorch provide scalable and efficient primitives for inference and training. However, such operations are non-deterministic. Hence, it is challenging for developers to write tests for applications that depend on such frameworks, often resulting in flaky tests &#8211; tests which fail non-deterministically when run on the same version of code.  
<br/>

In this paper, we conduct the first extensive study of flaky tests in this domain. In particular, we study the projects that depend on four frameworks: Pyro, PyMC3, TensorFlow-Probability, and  
PyTorch. We identify 75 bug reports/commits that deal with flaky tests, and we categorize the common causes and fixes for them. This study provides developers with useful insights on dealing with flaky tests in this domain.  
<br/>

Motivated by our study, we develop a technique, FLASH, to systematically detect flaky tests due to assertions passing and failing in different runs on the same code. These assertions fail due to differences in the sequence of random numbers in different runs of the same test. FLASH exposes such failures, and our evaluation on 20 projects results in 11 previously-unknown flaky tests that we reported to developers.<br/>
        <br />
        <a href="issta20main-id159-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Jiang, Muhui  </td>
  <td>
    <span onclick="toggle('issta20main-id47-p-jiangmuhui')" title="An Empirical Study on ARM Disassembly Tools  --  Muhui Jiang, Yajin Zhou, Xiapu Luo, Ruoyu Wang, Yang Liu, and Kui Ren" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "An Empirical Study on ARM ..."</span></small></a>
    </span>

    <span id="issta20main-id47-p-jiangmuhui"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id47-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id47-p-jiangmuhui')" 
      >
        <a id="issta20main-id47-p-titlejiangmuhui" >
          <span style="font-size: 100%">
            An Empirical Study on ARM Disassembly Tools
          </span>
        </a>
      </span>
      <br />
      Muhui Jiang, Yajin Zhou, <a href="http://www4.comp.polyu.edu.hk/~csxluo/" target="_blank">Xiapu Luo</a>, Ruoyu Wang, <a href="http://www.ntu.edu.sg/home/yangliu/" target="_blank">Yang Liu</a>, and Kui Ren<br />
      <i><small>(Hong Kong Polytechnic University, China; Zhejiang University, China; Arizona State University, USA; Nanyang Technological University, Singapore)</small></i><br />
      <span id="issta20main-id47-p-absjiangmuhui" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              With the increasing popularity of embedded devices, ARM is becoming the dominant architecture for them. In the meanwhile, there is a pressing need to perform security assessments for these devices. Due to different types of peripherals, it is challenging to dynamically run the firmware of these devices in an emulated environment. Therefore, the static analysis is still commonly used. Existing work usually leverages off-the-shelf tools to disassemble stripped ARM binaries and (implicitly) assume that reliable disassembling binaries and function recognition are solved problems. However, whether this assumption really holds is unknown. <br/>In this paper, we conduct the first comprehensive study on ARM disassembly tools. Specifically, we build 1,896 ARM binaries (including 248 obfuscated ones) with different compilers, compiling options, and obfuscation methods. We then evaluate them using eight state-of-the-art ARM disassembly tools (including both commercial and noncommercial ones) on their capabilities to locate instructions and function boundaries. These two are fundamental ones, which are leveraged to build other primitives. Our work reveals some observations that have not been systematically summarized and/or confirmed. For instance, we find that the existence of both ARM and Thumb instruction sets, and the reuse of the BL instruction for both function calls and branches bring serious challenges to disassembly tools. Our evaluation sheds light on the limitations of state-of-the-art disassembly tools and points out potential directions for improvement. To engage the community, we release the data set, and the related scripts at https://github.com/valour01/arm_disasssembler_study.<br/>
        <br />
        <a href="issta20main-id47-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Jiang, Yanjie  </td>
  <td>
    <span onclick="toggle('issta20main-id19-p-jiangyanjie')" title="Automated Classification of Actions in Bug Reports of Mobile Apps  --  Hui Liu, Mingzhu Shen, Jiahao Jin, and Yanjie Jiang" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Automated Classification of ..."</span></small></a>
    </span>

    <span id="issta20main-id19-p-jiangyanjie"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id19-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id19-p-jiangyanjie')" 
      >
        <a id="issta20main-id19-p-titlejiangyanjie" >
          <span style="font-size: 100%">
            Automated Classification of Actions in Bug Reports of Mobile Apps
          </span>
        </a>
      </span>
      <br />
      Hui Liu, Mingzhu Shen, Jiahao Jin, and Yanjie Jiang<br />
      <i><small>(Beijing Institute of Technology, China)</small></i><br />
      <span id="issta20main-id19-p-absjiangyanjie" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              When users encounter problems with mobile apps, they may commit such problems to developers as bug reports. To facilitate the processing of bug reports, researchers proposed approaches to validate the reported issues automatically according to the <em>steps to reproduce</em> specified in bug reports. Although such approaches have achieved high success rate in reproducing the reported issues, they often rely on a predefined vocabulary to identify and classify actions in bug reports. However, such manually constructed vocabulary and classification have significant limitations. It is challenging for the vocabulary to cover all potential action words because users may describe the same action with different words. Besides that, classification of actions solely based on the action words could be inaccurate because the same action word, appearing in different contexts, may have different meaning and thus belongs to different action categories. To this end, in this paper we propose an automated approach, called <em>MaCa</em>, to identify and classify action words in Mobile apps&#8217; bug reports. For a given bug report, it first identifies action words based on natural language processing. For each of the resulting action words, <em>MaCa</em> extracts its contexts, i.e., its enclosing segment, the associated UI target, and the type of its target element by both natural language processing and static analysis of the associated app. The action word and its contexts are then fed into a machine learning based classifier that predicts the category of the given action word in the given context. To train the classifier, we manually labelled 1,202 actions words from 525 bug reports that are associated with 207 apps. Our evaluation results on manually labelled data suggested that <em>MaCa</em> was accurate with high accuracy varying from 95% to 96.7%. We also investigated to what extent <em>MaCa</em> could further improve existing approaches (i.e., Yakusu and ReCDroid) in reproducing bug reports. Our evaluation results suggested that integrating <em>MaCa</em> into existing approaches significantly improved the success rates of ReCDroid and Yakusu by 22.7% = (69.2%-56.4%)/56.4% and 22.9%= (62.7%-51%)/51%, respectively.<br/>
        <br />
        <a href="issta20main-id19-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Jin, Jiahao  </td>
  <td>
    <span onclick="toggle('issta20main-id19-p-jinjiahao')" title="Automated Classification of Actions in Bug Reports of Mobile Apps  --  Hui Liu, Mingzhu Shen, Jiahao Jin, and Yanjie Jiang" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Automated Classification of ..."</span></small></a>
    </span>

    <span id="issta20main-id19-p-jinjiahao"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id19-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id19-p-jinjiahao')" 
      >
        <a id="issta20main-id19-p-titlejinjiahao" >
          <span style="font-size: 100%">
            Automated Classification of Actions in Bug Reports of Mobile Apps
          </span>
        </a>
      </span>
      <br />
      Hui Liu, Mingzhu Shen, Jiahao Jin, and Yanjie Jiang<br />
      <i><small>(Beijing Institute of Technology, China)</small></i><br />
      <span id="issta20main-id19-p-absjinjiahao" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              When users encounter problems with mobile apps, they may commit such problems to developers as bug reports. To facilitate the processing of bug reports, researchers proposed approaches to validate the reported issues automatically according to the <em>steps to reproduce</em> specified in bug reports. Although such approaches have achieved high success rate in reproducing the reported issues, they often rely on a predefined vocabulary to identify and classify actions in bug reports. However, such manually constructed vocabulary and classification have significant limitations. It is challenging for the vocabulary to cover all potential action words because users may describe the same action with different words. Besides that, classification of actions solely based on the action words could be inaccurate because the same action word, appearing in different contexts, may have different meaning and thus belongs to different action categories. To this end, in this paper we propose an automated approach, called <em>MaCa</em>, to identify and classify action words in Mobile apps&#8217; bug reports. For a given bug report, it first identifies action words based on natural language processing. For each of the resulting action words, <em>MaCa</em> extracts its contexts, i.e., its enclosing segment, the associated UI target, and the type of its target element by both natural language processing and static analysis of the associated app. The action word and its contexts are then fed into a machine learning based classifier that predicts the category of the given action word in the given context. To train the classifier, we manually labelled 1,202 actions words from 525 bug reports that are associated with 207 apps. Our evaluation results on manually labelled data suggested that <em>MaCa</em> was accurate with high accuracy varying from 95% to 96.7%. We also investigated to what extent <em>MaCa</em> could further improve existing approaches (i.e., Yakusu and ReCDroid) in reproducing bug reports. Our evaluation results suggested that integrating <em>MaCa</em> into existing approaches significantly improved the success rates of ReCDroid and Yakusu by 22.7% = (69.2%-56.4%)/56.4% and 22.9%= (62.7%-51%)/51%, respectively.<br/>
        <br />
        <a href="issta20main-id19-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;"><a id="K"> </a>Kadron, İsmet Burak
  </td>
  <td>
    <span onclick="toggle('issta20main-id101-p-kadronismetburak')" title="Feedback-Driven Side-Channel Analysis for Networked Applications  --  İsmet Burak Kadron, Nicolás Rosner, and Tevfik Bultan" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Feedback-Driven Side-Channel ..."</span></small></a>
    </span>

    <span id="issta20main-id101-p-kadronismetburak"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id101-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id101-p-kadronismetburak')" 
      >
        <a id="issta20main-id101-p-titlekadronismetburak" >
          <span style="font-size: 100%">
            Feedback-Driven Side-Channel Analysis for Networked Applications
          </span>
        </a>
      </span>
      <br />
      İsmet Burak Kadron, Nicolás Rosner, and <a href="http://www.cs.ucsb.edu/~bultan/" target="_blank">Tevfik Bultan</a><br />
      <i><small>(University of California at Santa Barbara, USA)</small></i><br />
      <span id="issta20main-id101-p-abskadronismetburak" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Information leakage in software systems is a problem of growing importance. Networked applications can leak sensitive information even when they use encryption. For example, some characteristics of network packets, such as their size, timing and direction, are visible even for encrypted traffic. Patterns in these characteristics can be leveraged as side channels to extract information about secret values accessed by the application. In this paper, we present a new tool called AutoFeed for detecting and quantifying information leakage due to side channels in networked software applications. AutoFeed profiles the target system and automatically explores the input space, explores the space of output features that may leak information, quantifies the information leakage, and identifies the top-leaking features.  
Given a set of input mutators and a small number of initial inputs provided by the user, AutoFeed iteratively mutates inputs and periodically updates its leakage estimations to identify the features that leak the greatest amount of information about the secret of interest. AutoFeed uses a feedback loop for incremental profiling, and a stopping criterion that terminates the analysis when the leakage estimation for the top-leaking features converges. AutoFeed also automatically assigns weights to mutators in order to focus the search of the input space on exploring dimensions that are relevant to the leakage quantification. Our experimental evaluation on the benchmarks shows that AutoFeed is effective in detecting and quantifying information leaks in networked applications.<br/>
        <br />
        <a href="issta20main-id101-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Kampmann, Alexander  </td>
  <td>
    <span onclick="toggle('issta20main-id136-p-kampmannalexander')" title="Abstracting Failure-Inducing Inputs  --  Rahul Gopinath, Alexander Kampmann, Nikolas Havrikov, Ezekiel O. Soremekun, and Andreas Zeller" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Abstracting Failure-Inducing ..."</span></small></a>
    </span>

    <span id="issta20main-id136-p-kampmannalexander"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id136-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id136-p-kampmannalexander')" 
      >
        <a id="issta20main-id136-p-titlekampmannalexander" >
          <span style="font-size: 100%">
            Abstracting Failure-Inducing Inputs
          </span>
        </a>
      </span>
      <br />
      Rahul Gopinath, Alexander Kampmann, Nikolas Havrikov, Ezekiel O. Soremekun, and Andreas Zeller<br />
      <i><small>(CISPA, Germany)</small></i><br />
      <span id="issta20main-id136-p-abskampmannalexander" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              A program fails. Under which circumstances does the failure occur? Starting with a single failure-inducing input (&quot;The input ((4)) fails&quot;) and an input grammar, the DDSET algorithm uses systematic tests to automatically generalize the input to an abstract failure-inducing input that contains both (concrete) terminal symbols and (abstract) nonterminal symbols from the grammar&#8212;for instance, &quot;((&#60;expr&#62;))&quot;, which represents any expression &#60;expr&#62; in double parentheses. Such an abstract failure-inducing input can be used (1) as a debugging diagnostic, characterizing the circumstances under which a failure occurs (&quot;The error occurs whenever an expression is enclosed in double parentheses&quot;); (2) as a producer of additional failure-inducing tests to help design and validate fixes and repair candidates (&quot;The inputs ((1)), ((3 * 4)), and many more also fail&quot;). In its evaluation on real-world bugs in JavaScript, Clojure, Lua, and UNIX command line utilities, DDSET&#8217;s abstract failure-inducing inputs provided to-the-point diagnostics, and precise producers for further failure inducing inputs.<br/>
        <br />
        <a href="issta20main-id136-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
      <a href="https://github.com/vrthra/ddset"><img width="15" src="../images/tool.png" alt="" /><span style="font-size: 90%"> Info</span></a>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_available_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Available</span></a>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_evaluated_reusable_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Reusable</span></a>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_evaluated_functional_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Functional</span></a>
          <span style="font-size: 80%; color: blue;"> 
            <img width="20" src="../images/award.svg" alt="" />
            ACM SIGSOFT Distinguished Paper Award</span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Kölzer, Jan Thomas  </td>
  <td>
    <span onclick="toggle('issta20main-id78-p-koelzerjanthomas')" title="A Programming Model for Semi-implicit Parallelization of Static Analyses  --  Dominik Helm, Florian Kübler, Jan Thomas Kölzer, Philipp Haller, Michael Eichberg, Guido Salvaneschi, and Mira Mezini" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "A Programming Model for Semi-implicit ..."</span></small></a>
    </span>

    <span id="issta20main-id78-p-koelzerjanthomas"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id78-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id78-p-koelzerjanthomas')" 
      >
        <a id="issta20main-id78-p-titlekoelzerjanthomas" >
          <span style="font-size: 100%">
            A Programming Model for Semi-implicit Parallelization of Static Analyses
          </span>
        </a>
      </span>
      <br />
      Dominik Helm, Florian Kübler, Jan Thomas Kölzer, Philipp Haller, Michael Eichberg, Guido Salvaneschi, and Mira Mezini<br />
      <i><small>(TU Darmstadt, Germany; KTH, Sweden)</small></i><br />
      <span id="issta20main-id78-p-abskoelzerjanthomas" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Parallelization of static analyses is necessary to scale to real-world programs, but it is a complex and difficult task and, therefore, often only done manually for selected high-profile analyses. In this paper, we propose a programming model for semi-implicit parallelization of static analyses which is inspired by reactive programming. Reusing the domain-expert knowledge on how to parallelize anal-  
yses encoded in the programming framework, developers do not need to think about parallelization and concurrency issues on their own. The programming model supports stateful computations, only requires monotonic computations over lattices, and is independent of specific analyses. Our evaluation shows the applicability of the programming model to different analyses and the importance of user-selected scheduling strategies. We implemented an IFDS solver that was able to outperform a state-of-the-art, specialized parallel IFDS solver both in absolute performance and scalability.<br/>
        <br />
        <a href="issta20main-id78-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Kübler, Florian  </td>
  <td>
    <span onclick="toggle('issta20main-id78-p-kueblerflorian')" title="A Programming Model for Semi-implicit Parallelization of Static Analyses  --  Dominik Helm, Florian Kübler, Jan Thomas Kölzer, Philipp Haller, Michael Eichberg, Guido Salvaneschi, and Mira Mezini" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "A Programming Model for Semi-implicit ..."</span></small></a>
    </span>

    <span id="issta20main-id78-p-kueblerflorian"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id78-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id78-p-kueblerflorian')" 
      >
        <a id="issta20main-id78-p-titlekueblerflorian" >
          <span style="font-size: 100%">
            A Programming Model for Semi-implicit Parallelization of Static Analyses
          </span>
        </a>
      </span>
      <br />
      Dominik Helm, Florian Kübler, Jan Thomas Kölzer, Philipp Haller, Michael Eichberg, Guido Salvaneschi, and Mira Mezini<br />
      <i><small>(TU Darmstadt, Germany; KTH, Sweden)</small></i><br />
      <span id="issta20main-id78-p-abskueblerflorian" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Parallelization of static analyses is necessary to scale to real-world programs, but it is a complex and difficult task and, therefore, often only done manually for selected high-profile analyses. In this paper, we propose a programming model for semi-implicit parallelization of static analyses which is inspired by reactive programming. Reusing the domain-expert knowledge on how to parallelize anal-  
yses encoded in the programming framework, developers do not need to think about parallelization and concurrency issues on their own. The programming model supports stateful computations, only requires monotonic computations over lattices, and is independent of specific analyses. Our evaluation shows the applicability of the programming model to different analyses and the importance of user-selected scheduling strategies. We implemented an IFDS solver that was able to outperform a state-of-the-art, specialized parallel IFDS solver both in absolute performance and scalability.<br/>
        <br />
        <a href="issta20main-id78-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;"><a id="L"> </a><a href="http://winglam2.web.engr.illinois.edu/">Lam, Wing</a>
  </td>
  <td>
    <span onclick="toggle('issta20main-id57-p-lamwing')" title="Dependent-Test-Aware Regression Testing Techniques  --  Wing Lam, August Shi, Reed Oei, Sai Zhang, Michael D. Ernst, and Tao Xie" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Dependent-Test-Aware Regression ..."</span></small></a>
    </span>

    <span id="issta20main-id57-p-lamwing"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id57-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id57-p-lamwing')" 
      >
        <a id="issta20main-id57-p-titlelamwing" >
          <span style="font-size: 100%">
            Dependent-Test-Aware Regression Testing Techniques
          </span>
        </a>
      </span>
      <br />
      <a href="http://winglam2.web.engr.illinois.edu/" target="_blank">Wing Lam</a>, <a href="http://mir.cs.illinois.edu/~awshi2/" target="_blank">August Shi</a>, Reed Oei, Sai Zhang, <a href="https://homes.cs.washington.edu/~mernst/" target="_blank">Michael D. Ernst</a>, and <a href="http://taoxie.cs.illinois.edu/" target="_blank">Tao Xie</a><br />
      <i><small>(University of Illinois at Urbana-Champaign, USA; Google, USA; University of Washington, USA; Peking University, China)</small></i><br />
      <span id="issta20main-id57-p-abslamwing" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Developers typically rely on regression testing techniques to ensure that their changes do not break existing functionality. Unfortunately, these techniques suffer from flaky tests, which can both pass and fail when run multiple times on the same version of code and tests. One prominent type of flaky tests is order-dependent (OD) tests, which are tests that pass when run in one order but fail when run in another order. Although OD tests may cause flaky-test failures, OD tests can help developers run their tests faster by allowing them to share resources. We propose to make regression testing techniques dependent-test-aware to reduce flaky-test failures.  
<br/>

To understand the necessity of dependent-test-aware regression testing techniques, we conduct the first study on the impact of OD tests on three regression testing techniques: test prioritization, test selection, and test parallelization. In particular, we implement 4 test prioritization, 6 test selection, and 2 test parallelization algorithms, and we evaluate them on 11 Java modules with OD tests. When we run the orders produced by the traditional, dependent-test-unaware regression testing algorithms, 82% of human-written test suites and 100% of automatically-generated test suites with OD tests have at least one flaky-test failure.  
<br/>

We develop a general approach for enhancing regression testing algorithms to make them dependent-test-aware, and apply our approach to 12 algorithms. Compared to traditional, unenhanced regression testing algorithms, the enhanced algorithms use provided test dependencies to produce orders with different permutations or extra tests. Our evaluation shows that, in comparison to the orders produced by unenhanced algorithms, the orders produced by enhanced algorithms (1) have overall 80% fewer flaky-test failures due to OD tests, and (2) may add extra tests but run only 1% slower on average. Our results suggest that enhancing regression testing algorithms to be dependent-test-aware can substantially reduce flaky-test failures with only a minor slowdown to run the tests.<br/>
        <br />
        <a href="issta20main-id57-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Lee, Dain  </td>
  <td>
    <span onclick="toggle('issta20main-id26-p-leedain')" title="Effective White-Box Testing of Deep Neural Networks with Adaptive Neuron-Selection Strategy  --  Seokhyun Lee, Sooyoung Cha, Dain Lee, and Hakjoo Oh" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Effective White-Box Testing ..."</span></small></a>
    </span>

    <span id="issta20main-id26-p-leedain"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id26-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id26-p-leedain')" 
      >
        <a id="issta20main-id26-p-titleleedain" >
          <span style="font-size: 100%">
            Effective White-Box Testing of Deep Neural Networks with Adaptive Neuron-Selection Strategy
          </span>
        </a>
      </span>
      <br />
      Seokhyun Lee, Sooyoung Cha, Dain Lee, and Hakjoo Oh<br />
      <i><small>(Korea University, South Korea)</small></i><br />
      <span id="issta20main-id26-p-absleedain" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              We present Adapt, a new white-box testing technique for deep neural networks. As deep neural networks are increasingly used in safety-first applications, testing their behavior systematically has become a critical problem. Accordingly, various testing techniques for deep neural networks have been proposed in recent years. However, neural network testing is still at an early stage and existing techniques are not yet sufficiently effective. In this paper, we aim to advance this field, in particular white-box testing approaches for neural networks, by identifying and addressing a key limitation of existing state-of-the-arts. We observe that the so-called neuron-selection strategy is a critical component of white-box testing and propose a new technique that effectively employs the strategy by continuously adapting it to the ongoing testing process. Experiments with real-world network models and datasets show that Adapt is remarkably more effective than existing testing techniques in terms of coverage and adversarial inputs found.<br/>
        <br />
        <a href="issta20main-id26-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_available_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Available</span></a>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_evaluated_reusable_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Reusable</span></a>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_evaluated_functional_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Functional</span></a>
          <span style="font-size: 80%; color: blue;"> 
            <img width="20" src="../images/award.svg" alt="" />
            ACM SIGSOFT Distinguished Paper Award</span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Lee, Seokhyun  </td>
  <td>
    <span onclick="toggle('issta20main-id26-p-leeseokhyun')" title="Effective White-Box Testing of Deep Neural Networks with Adaptive Neuron-Selection Strategy  --  Seokhyun Lee, Sooyoung Cha, Dain Lee, and Hakjoo Oh" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Effective White-Box Testing ..."</span></small></a>
    </span>

    <span id="issta20main-id26-p-leeseokhyun"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id26-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id26-p-leeseokhyun')" 
      >
        <a id="issta20main-id26-p-titleleeseokhyun" >
          <span style="font-size: 100%">
            Effective White-Box Testing of Deep Neural Networks with Adaptive Neuron-Selection Strategy
          </span>
        </a>
      </span>
      <br />
      Seokhyun Lee, Sooyoung Cha, Dain Lee, and Hakjoo Oh<br />
      <i><small>(Korea University, South Korea)</small></i><br />
      <span id="issta20main-id26-p-absleeseokhyun" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              We present Adapt, a new white-box testing technique for deep neural networks. As deep neural networks are increasingly used in safety-first applications, testing their behavior systematically has become a critical problem. Accordingly, various testing techniques for deep neural networks have been proposed in recent years. However, neural network testing is still at an early stage and existing techniques are not yet sufficiently effective. In this paper, we aim to advance this field, in particular white-box testing approaches for neural networks, by identifying and addressing a key limitation of existing state-of-the-arts. We observe that the so-called neuron-selection strategy is a critical component of white-box testing and propose a new technique that effectively employs the strategy by continuously adapting it to the ongoing testing process. Experiments with real-world network models and datasets show that Adapt is remarkably more effective than existing testing techniques in terms of coverage and adversarial inputs found.<br/>
        <br />
        <a href="issta20main-id26-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_available_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Available</span></a>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_evaluated_reusable_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Reusable</span></a>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_evaluated_functional_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Functional</span></a>
          <span style="font-size: 80%; color: blue;"> 
            <img width="20" src="../images/award.svg" alt="" />
            ACM SIGSOFT Distinguished Paper Award</span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Lehmann, Daniel  </td>
  <td>
    <span onclick="toggle('issta20main-id90-p-lehmanndaniel')" title="Differential Regression Testing for REST APIs  --  Patrice Godefroid, Daniel Lehmann, and Marina Polishchuk" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Differential Regression Testing ..."</span></small></a>
    </span>

    <span id="issta20main-id90-p-lehmanndaniel"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id90-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id90-p-lehmanndaniel')" 
      >
        <a id="issta20main-id90-p-titlelehmanndaniel" >
          <span style="font-size: 100%">
            Differential Regression Testing for REST APIs
          </span>
        </a>
      </span>
      <br />
      Patrice Godefroid, Daniel Lehmann, and Marina Polishchuk<br />
      <i><small>(Microsoft Research, USA; University of Stuttgart, Germany)</small></i><br />
      <span id="issta20main-id90-p-abslehmanndaniel" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Cloud services are programmatically accessed through REST APIs. Since REST APIs are constantly evolving, an important problem is how to prevent breaking changes of APIs, while supporting several different versions. To find such breaking changes in an automated way, we introduce differential regression testing for REST APIs.  
Our approach is based on two observations. First, breaking changes in REST APIs involve two software components, namely the client and the service. As such, there are also two types of regressions: regressions in the API specification, i.e., in the contract between the client and the service, and regressions in the service itself, i.e., previously working requests are &quot;broken&quot; in later versions of the service. Finding both kinds of regressions involves testing along two dimensions: when the service changes and when the specification changes.  
Second, to detect such bugs automatically, we employ differential testing. That is, we compare the behavior of different versions on the same inputs against each other, and find regressions in the observed differences. For generating inputs (sequences of HTTP requests) to services, we use RESTler, a stateful fuzzer for REST APIs. Comparing the outputs (HTTP responses) of a cloud service involves several challenges, like abstracting over minor differences, handling out-of-order requests, and non-determinism.  
Differential regression testing across 17 different versions of the widely-used Azure networking APIs deployed between 2016 and 2019 detected 14 regressions in total, 5 of those in the official API specifications and 9 regressions in the services themselves.<br/>
        <br />
        <a href="issta20main-id90-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Li, Hui  </td>
  <td>
    <span onclick="toggle('issta20main-id139-p-lihui')" title="Detecting Cache-Related Bugs in Spark Applications  --  Hui Li, Dong Wang, Tianze Huang, Yu Gao, Wensheng Dou, Lijie Xu, Wei Wang, Jun Wei, and Hua Zhong" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Detecting Cache-Related Bugs ..."</span></small></a>
    </span>

    <span id="issta20main-id139-p-lihui"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id139-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id139-p-lihui')" 
      >
        <a id="issta20main-id139-p-titlelihui" >
          <span style="font-size: 100%">
            Detecting Cache-Related Bugs in Spark Applications
          </span>
        </a>
      </span>
      <br />
      Hui Li, Dong Wang, Tianze Huang, Yu Gao, <a href="http://www.tcse.cn/~wsdou/" target="_blank">Wensheng Dou</a>, Lijie Xu, Wei Wang, Jun Wei, and Hua Zhong<br />
      <i><small>(Institute of Software at Chinese Academy of Sciences, China; University of Chinese Academy of Sciences, China; Beijing University of Posts and Telecommunications, China)</small></i><br />
      <span id="issta20main-id139-p-abslihui" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Apache Spark has been widely used to build big data applications. Spark utilizes the abstraction of Resilient Distributed Dataset (RDD) to store and retrieve large-scale data. To reduce duplicate computation of an RDD, Spark can cache the RDD in memory and then reuse it later, thus improving performance. Spark relies on application developers to enforce caching decisions by using <em>persist</em>() and <em>unpersist</em>() APIs, e.g., <em>which</em> RDD is persisted and <em>when</em> the RDD is persisted / unpersisted. Incorrect RDD caching decisions can cause duplicate computations, or waste precious memory resource, thus introducing serious performance degradation in Spark applications. In this paper, we propose <em>CacheCheck</em>, to automatically detect cache-related bugs in Spark applications. We summarize six cache-related bug patterns in Spark applications, and then dynamically detect cache-related bugs by analyzing the execution traces of Spark applications. We evaluate CacheCheck on six real-world Spark applications. The experimental result shows that CacheCheck detects 72 previously unknown cache-related bugs, and 28 of them have been fixed by developers.<br/>
        <br />
        <a href="issta20main-id139-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_available_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Available</span></a>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_evaluated_reusable_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Reusable</span></a>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_evaluated_functional_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Functional</span></a>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Li, Ke  </td>
  <td>
    <span onclick="toggle('issta20main-id38-p-like')" title="DeepSQLi: Deep Semantic Learning for Testing SQL Injection  --  Muyang Liu, Ke Li, and Tao Chen" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "DeepSQLi: Deep Semantic Learning ..."</span></small></a>
    </span>

    <span id="issta20main-id38-p-like"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id38-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id38-p-like')" 
      >
        <a id="issta20main-id38-p-titlelike" >
          <span style="font-size: 100%">
            DeepSQLi: Deep Semantic Learning for Testing SQL Injection
          </span>
        </a>
      </span>
      <br />
      Muyang Liu, Ke Li, and Tao Chen<br />
      <i><small>(University of Electronic Science and Technology of China, China; University of Exeter, UK; Loughborough University, UK)</small></i><br />
      <span id="issta20main-id38-p-abslike" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Security is unarguably the most serious concern for Web applications, to which SQL injection (SQLi) attack is one of the most devastating attacks. Automatically testing SQLi vulnerabilities is of ultimate importance, yet is unfortunately far from trivial to implement. This is because the existence of a huge, or potentially infinite, number of variants and semantic possibilities of SQL leading to SQLi attacks on various Web applications. In this paper, we propose a deep natural language processing based tool, dubbed DeepSQLi, to generate test cases for detecting SQLi vulnerabilities. Through adopting deep learning based neural language model and sequence of words prediction, DeepSQLi is equipped with the ability to learn the semantic knowledge embedded in SQLi attacks, allowing it to translate user inputs (or a test case) into a new test case, which is se- mantically related and potentially more sophisticated. Experiments are conducted to compare DeepSQLi with SQLmap, a state-of-the-art SQLi testing automation tool, on six real-world Web applications that are of different scales, characteristics and domains. Empirical results demonstrate the effectiveness and the remarkable superiority of DeepSQLi over SQLmap, such that more SQLi vulnerabilities can be identified by using a less number of test cases, whilst running much faster.<br/>
        <br />
        <a href="issta20main-id38-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Li, Qingshan  </td>
  <td>
    <span onclick="toggle('issta20tool-id11-p-liqingshan')" title="EShield: Protect Smart Contracts against Reverse Engineering  --  Wentian Yan, Jianbo Gao, Zhenhao Wu, Yue Li, Zhi Guan, Qingshan Li, and Zhong Chen" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20-TOOL: "EShield: Protect Smart Contracts ..."</span></small></a>
    </span>

    <span id="issta20tool-id11-p-liqingshan"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20tool-id11-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20tool-id11-p-liqingshan')" 
      >
        <a id="issta20tool-id11-p-titleliqingshan" >
          <span style="font-size: 100%">
            EShield: Protect Smart Contracts against Reverse Engineering
          </span>
        </a>
      </span>
      <br />
      Wentian Yan, Jianbo Gao, Zhenhao Wu, Yue Li, Zhi Guan, Qingshan Li, and Zhong Chen<br />
      <i><small>(Peking University, China; Boya Blockchain, China)</small></i><br />
      <span id="issta20tool-id11-p-absliqingshan" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Smart contracts are the back-end programs of blockchain-based applications and the execution results are deterministic and publicly visible. Developers are unwilling to release source code of some smart contracts to generate randomness or for security reasons, however, attackers still can use reverse engineering tools to decompile and analyze the code. In this paper, we propose EShield, an automated security enhancement tool for protecting smart contracts against reverse engineering. EShield replaces original instructions of operating jump addresses with anti-patterns to interfere with control flow recovery from bytecode. We have implemented four methods in EShield and conducted an experiment on over 20k smart contracts. The evaluation results show that all the protected smart contracts are resistant to three different reverse engineering tools with little extra gas cost.<br/>
        <br />
        <a href="issta20tool-id11-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Li, Xia  </td>
  <td>
    <span onclick="toggle('issta20main-id22-p-lixia')" title="Can Automated Program Repair Refine Fault Localization? A Unified Debugging Approach  --  Yiling Lou, Ali Ghanbari, Xia Li, Lingming Zhang, Haotian Zhang, Dan Hao, and Lu Zhang" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Can Automated Program Repair ..."</span></small></a>
    </span>

    <span id="issta20main-id22-p-lixia"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id22-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id22-p-lixia')" 
      >
        <a id="issta20main-id22-p-titlelixia" >
          <span style="font-size: 100%">
            Can Automated Program Repair Refine Fault Localization? A Unified Debugging Approach
          </span>
        </a>
      </span>
      <br />
      Yiling Lou, Ali Ghanbari, Xia Li, Lingming Zhang, Haotian Zhang, Dan Hao, and Lu Zhang<br />
      <i><small>(Peking University, China; University of Texas at Dallas, USA; Ant Financial Services, China)</small></i><br />
      <span id="issta20main-id22-p-abslixia" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              A large body of research efforts have been dedicated to automated software debugging, including both automated fault localization and program repair. However, existing fault localization techniques have limited effectiveness on real-world software systems while even the most advanced program repair techniques can only fix a small ratio of real-world bugs. Although fault localization and program repair are inherently connected, their only existing connection in the literature is that program repair techniques usually use off-the-shelf fault localization techniques (e.g., Ochiai) to determine the potential candidate statements/elements for patching. In this work, we propose the unified debugging approach to unify the two areas in the other direction for the first time, i.e., can program repair in turn help with fault localization? In this way, we not only open a new dimension for more powerful fault localization, but also extend the application scope of program repair to all possible bugs (not only the bugs that can be directly automatically fixed). We have designed ProFL to leverage patch-execution results (from program repair) as the feedback information for fault localization. The experimental results on the widely used Defects4J benchmark show that the basic ProFL can already at least localize 37.61% more bugs within Top-1 than state-of-the-art spectrum and mutation based fault localization. Furthermore, ProFL can boost state-of-the-art fault localization via both unsupervised and supervised learning. Meanwhile, we have demonstrated ProFL&#39;s effectiveness under different settings and through a case study within Alipay, a popular online payment system with over 1 billion global users.<br/>
        <br />
        <a href="issta20main-id22-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_available_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Available</span></a>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_evaluated_reusable_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Reusable</span></a>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_evaluated_functional_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Functional</span></a>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Li, Xuandong  </td>
  <td>
    <span onclick="toggle('issta20main-id155-p-lixuandong')" title="Reinforcement Learning Based Curiosity-Driven Testing of Android Applications  --  Minxue Pan, An Huang, Guoxin Wang, Tian Zhang, and Xuandong Li" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Reinforcement Learning Based ..."</span></small></a>
    </span>

    <span id="issta20main-id155-p-lixuandong"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id155-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id155-p-lixuandong')" 
      >
        <a id="issta20main-id155-p-titlelixuandong" >
          <span style="font-size: 100%">
            Reinforcement Learning Based Curiosity-Driven Testing of Android Applications
          </span>
        </a>
      </span>
      <br />
      Minxue Pan, An Huang, Guoxin Wang, Tian Zhang, and Xuandong Li<br />
      <i><small>(Nanjing University, China)</small></i><br />
      <span id="issta20main-id155-p-abslixuandong" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Mobile applications play an important role in our daily life, while it still remains a challenge to guarantee their correctness. Model-based and systematic approaches have been applied to Android GUI testing. However, they do not show significant advantages over random approaches because of limitations such as imprecise models and poor scalability. In this paper, we propose Q-testing, a reinforcement learning based approach which benefits from both random and model-based approaches to automated testing of Android applications. Q-testing explores the Android apps with a curiosity-driven strategy that utilizes a memory set to record part of previously visited states and guides the testing towards unfamiliar functionalities. A state comparison module, which is a neural network trained by plenty of collected samples, is novelly employed to divide different states at the granularity of functional scenarios. It can determine the reinforcement learning reward in Q-testing and help the curiosity-driven strategy explore different functionalities efficiently. We conduct experiments on 50 open-source applications where Q-testing outperforms the state-of-the-art and state-of-practice Android GUI testing tools in terms of code coverage and fault detection. So far, 22 of our reported faults have been confirmed, among which 7 have been fixed.<br/>
        <br />
        <a href="issta20main-id155-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
          <span style="font-size: 80%; color: blue;"> 
            <img width="20" src="../images/award.svg" alt="" />
            ACM SIGSOFT Distinguished Paper Award</span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Li, Xueliang  </td>
  <td>
    <span onclick="toggle('issta20main-id2-p-lixueliang')" title="Detecting and Diagnosing Energy Issues for Mobile Applications  --  Xueliang Li, Yuming Yang, Yepang Liu, John P. Gallagher, and Kaishun Wu" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Detecting and Diagnosing Energy ..."</span></small></a>
    </span>

    <span id="issta20main-id2-p-lixueliang"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id2-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id2-p-lixueliang')" 
      >
        <a id="issta20main-id2-p-titlelixueliang" >
          <span style="font-size: 100%">
            Detecting and Diagnosing Energy Issues for Mobile Applications
          </span>
        </a>
      </span>
      <br />
      Xueliang Li, Yuming Yang, Yepang Liu, John P. Gallagher, and Kaishun Wu<br />
      <i><small>(Shenzhen University, China; Southern University of Science and Technology, China; Roskilde University, Denmark; IMDEA Software Institute, Spain)</small></i><br />
      <span id="issta20main-id2-p-abslixueliang" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Energy efficiency is an important criterion to judge the quality of mobile apps, but one third of our randomly sampled apps suffer from energy issues that can quickly drain battery power. To understand these issues, we conducted an empirical study on 27 well-maintained apps such as Chrome and Firefox, whose issue tracking systems are publicly accessible. Our study revealed that the main root causes of energy issues include unnecessary workload and excessively frequent operations. Surprisingly, these issues are beyond the application of present technology on energy issue detection. We also found that 25.0% of energy issues can only manifest themselves under specific contexts such as poor network performance, but such contexts are again neglected by present technology. In this paper, we propose a novel testing framework for detecting energy issues in real-world mobile apps. Our framework examines apps with well-designed input sequences and runtime contexts. To identify the root causes mentioned above, we employed a machine learning algorithm to cluster the workloads and further evaluate their necessity. For the issues concealed by the specific contexts, we carefully set up several execution contexts to catch them. More importantly, we designed leading edge technology, e.g. pre-designing input sequences with potential energy overuse and tuning tests on-the-fly, to achieve high efficacy in detecting energy issues. A large-scale evaluation shows that 91.6% issues detected in our experiments were previously unknown to developers. On average, these issues double the energy costs of the apps. Our testing technique achieves a low number of false positives.<br/>
        <br />
        <a href="issta20main-id2-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Li, Yitong  </td>
  <td>
    <span onclick="toggle('issta20main-id96-p-liyitong')" title="CoCoNuT: Combining Context-Aware Neural Translation Models using Ensemble for Program Repair  --  Thibaud Lutellier, Hung Viet Pham, Lawrence Pang, Yitong Li, Moshi Wei, and Lin Tan" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "CoCoNuT: Combining Context-Aware ..."</span></small></a>
    </span>

    <span id="issta20main-id96-p-liyitong"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id96-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id96-p-liyitong')" 
      >
        <a id="issta20main-id96-p-titleliyitong" >
          <span style="font-size: 100%">
            CoCoNuT: Combining Context-Aware Neural Translation Models using Ensemble for Program Repair
          </span>
        </a>
      </span>
      <br />
      Thibaud Lutellier, Hung Viet Pham, Lawrence Pang, Yitong Li, Moshi Wei, and Lin Tan<br />
      <i><small>(University of Waterloo, Canada; Purdue University, USA)</small></i><br />
      <span id="issta20main-id96-p-absliyitong" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Automated generate-and-validate (GV) program repair techniques (APR) typically rely on hard-coded rules, thus only fixing bugs following specific fix patterns. These rules require a significant amount of manual effort to discover and it is hard to adapt these rules to different programming languages. <br/>To address these challenges, we propose a new G&amp;V technique&#8212;CoCoNuT, which uses ensemble learning on the combination of convolutional neural networks (CNNs) and a new context-aware neural machine translation (NMT) architecture to automatically fix bugs in multiple programming languages. To better represent the context of a bug, we introduce a new context-aware NMT architecture that represents the buggy source code and its surrounding context separately. CoCoNuT uses CNNs instead of recurrent neural networks (RNNs), since CNN layers can be stacked to extract hierarchical features and better model source code at different granularity levels (e.g., statements and functions). In addition, CoCoNuT takes advantage of the randomness in hyperparameter tuning to build multiple models that fix different bugs and combines these models using ensemble learning to fix more bugs. <br/>Our evaluation on six popular benchmarks for four programming languages (Java, C, Python, and JavaScript) shows that CoCoNuT correctly fixes (i.e., the first generated patch is semantically equivalent to the developer&#8217;s patch) 509 bugs, including 309 bugs that are fixed by none of the 27 techniques with which we compare.<br/>
        <br />
        <a href="issta20main-id96-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Li, Yue  </td>
  <td>
    <span onclick="toggle('issta20tool-id11-p-liyue')" title="EShield: Protect Smart Contracts against Reverse Engineering  --  Wentian Yan, Jianbo Gao, Zhenhao Wu, Yue Li, Zhi Guan, Qingshan Li, and Zhong Chen" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20-TOOL: "EShield: Protect Smart Contracts ..."</span></small></a>
    </span>

    <span id="issta20tool-id11-p-liyue"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20tool-id11-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20tool-id11-p-liyue')" 
      >
        <a id="issta20tool-id11-p-titleliyue" >
          <span style="font-size: 100%">
            EShield: Protect Smart Contracts against Reverse Engineering
          </span>
        </a>
      </span>
      <br />
      Wentian Yan, Jianbo Gao, Zhenhao Wu, Yue Li, Zhi Guan, Qingshan Li, and Zhong Chen<br />
      <i><small>(Peking University, China; Boya Blockchain, China)</small></i><br />
      <span id="issta20tool-id11-p-absliyue" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Smart contracts are the back-end programs of blockchain-based applications and the execution results are deterministic and publicly visible. Developers are unwilling to release source code of some smart contracts to generate randomness or for security reasons, however, attackers still can use reverse engineering tools to decompile and analyze the code. In this paper, we propose EShield, an automated security enhancement tool for protecting smart contracts against reverse engineering. EShield replaces original instructions of operating jump addresses with anti-patterns to interfere with control flow recovery from bytecode. We have implemented four methods in EShield and conducted an experiment on over 20k smart contracts. The evaluation results show that all the protected smart contracts are resistant to three different reverse engineering tools with little extra gas cost.<br/>
        <br />
        <a href="issta20tool-id11-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Li, Zhuoyang  </td>
  <td>
    <span onclick="toggle('issta20tool-id8-p-lizhuoyang')" title="TauJud: Test Augmentation of Machine Learning in Judicial Documents  --  Zichen Guo, Jiawei Liu, Tieke He, Zhuoyang Li, and Peitian Zhangzhu" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20-TOOL: "TauJud: Test Augmentation ..."</span></small></a>
    </span>

    <span id="issta20tool-id8-p-lizhuoyang"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20tool-id8-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20tool-id8-p-lizhuoyang')" 
      >
        <a id="issta20tool-id8-p-titlelizhuoyang" >
          <span style="font-size: 100%">
            TauJud: Test Augmentation of Machine Learning in Judicial Documents
          </span>
        </a>
      </span>
      <br />
      Zichen Guo, Jiawei Liu, Tieke He, Zhuoyang Li, and Peitian Zhangzhu<br />
      <i><small>(Nanjing University, China)</small></i><br />
      <span id="issta20tool-id8-p-abslizhuoyang" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              The booming of big data makes the adoption of machine learning ubiquitous in the legal field. As we all know, a large amount of test data can better reflect the performance of the model, so the test data must be naturally expanded. In order to solve the high cost problem of labeling data in natural language processing, people in the industry have improved the performance of text classification tasks through simple data amplification techniques. However, the data amplification requirements in the judgment documents are interpretable and logical, as observed from CAIL2018 test data with over 200,000 judicial documents. Therefore, we have designed a test augmentation tool called TauJud specifically for generating more effective test data with uniform distribution over time and location for model evaluation and save time in marking data. The demo can be found at https://github.com/governormars/TauJud.<br/>
        <br />
        <a href="issta20tool-id8-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;"><a href="http://linyun.info/">Lin, Yun</a>  </td>
  <td>
    <span onclick="toggle('issta20main-id134-p-linyun')" title="Recovering Fitness Gradients for Interprocedural Boolean Flags in Search-Based Testing  --  Yun Lin, Jun Sun, Gordon Fraser, Ziheng Xiu, Ting Liu, and Jin Song Dong" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Recovering Fitness Gradients ..."</span></small></a>
    </span>

    <span id="issta20main-id134-p-linyun"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id134-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id134-p-linyun')" 
      >
        <a id="issta20main-id134-p-titlelinyun" >
          <span style="font-size: 100%">
            Recovering Fitness Gradients for Interprocedural Boolean Flags in Search-Based Testing
          </span>
        </a>
      </span>
      <br />
      <a href="http://linyun.info/" target="_blank">Yun Lin</a>, Jun Sun, Gordon Fraser, Ziheng Xiu, Ting Liu, and Jin Song Dong<br />
      <i><small>(National University of Singapore, Singapore; Singapore Management University, Singapore; University of Passau, Germany; Xi&#39;an Jiaotong University, China)</small></i><br />
      <span id="issta20main-id134-p-abslinyun" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              In Search-based Software Testing (SBST), test generation is guided by fitness functions that estimate how close a test case is to reach an uncovered test goal (e.g., branch). A popular fitness function estimates how close conditional statements are to evaluating to true or false, i.e., the branch distance. However, when conditions read Boolean variables (e.g., if(x &amp;&amp; y)), the branch distance provides no gradient for the search, since a Boolean can either be true or false. This flag problem can be addressed by transforming individual procedures such that Boolean flags are replaced with numeric comparisons that provide better guidance for the search. Unfortunately, defining a semantics-preserving transformation that is applicable in an interprocedural case, where Boolean flags are passed around as parameters and return values, is a daunting task. Thus, it is not yet supported by modern test generators. <br/>This work is based on the insight that fitness gradients can be recovered by using runtime information: Given an uncovered interprocedural flag branch, our approach (1) calculates context-sensitive branch distance for all control flows potentially returning the required flag in the called method, and (2) recursively aggregates these distances into a continuous value. We implemented our approach on top of the EvoSuite framework for Java, and empirically compared it with state-of-the-art testability transformations on non-trivial methods suffering from interprocedural flag problems, sampled from open source Java projects. Our experiment demonstrates that our approach achieves higher coverage on the subject methods with statistical significance and acceptable runtime overheads.<br/>
        <br />
        <a href="issta20main-id134-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Liu, Hui  </td>
  <td>
    <span onclick="toggle('issta20main-id19-p-liuhui')" title="Automated Classification of Actions in Bug Reports of Mobile Apps  --  Hui Liu, Mingzhu Shen, Jiahao Jin, and Yanjie Jiang" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Automated Classification of ..."</span></small></a>
    </span>

    <span id="issta20main-id19-p-liuhui"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id19-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id19-p-liuhui')" 
      >
        <a id="issta20main-id19-p-titleliuhui" >
          <span style="font-size: 100%">
            Automated Classification of Actions in Bug Reports of Mobile Apps
          </span>
        </a>
      </span>
      <br />
      Hui Liu, Mingzhu Shen, Jiahao Jin, and Yanjie Jiang<br />
      <i><small>(Beijing Institute of Technology, China)</small></i><br />
      <span id="issta20main-id19-p-absliuhui" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              When users encounter problems with mobile apps, they may commit such problems to developers as bug reports. To facilitate the processing of bug reports, researchers proposed approaches to validate the reported issues automatically according to the <em>steps to reproduce</em> specified in bug reports. Although such approaches have achieved high success rate in reproducing the reported issues, they often rely on a predefined vocabulary to identify and classify actions in bug reports. However, such manually constructed vocabulary and classification have significant limitations. It is challenging for the vocabulary to cover all potential action words because users may describe the same action with different words. Besides that, classification of actions solely based on the action words could be inaccurate because the same action word, appearing in different contexts, may have different meaning and thus belongs to different action categories. To this end, in this paper we propose an automated approach, called <em>MaCa</em>, to identify and classify action words in Mobile apps&#8217; bug reports. For a given bug report, it first identifies action words based on natural language processing. For each of the resulting action words, <em>MaCa</em> extracts its contexts, i.e., its enclosing segment, the associated UI target, and the type of its target element by both natural language processing and static analysis of the associated app. The action word and its contexts are then fed into a machine learning based classifier that predicts the category of the given action word in the given context. To train the classifier, we manually labelled 1,202 actions words from 525 bug reports that are associated with 207 apps. Our evaluation results on manually labelled data suggested that <em>MaCa</em> was accurate with high accuracy varying from 95% to 96.7%. We also investigated to what extent <em>MaCa</em> could further improve existing approaches (i.e., Yakusu and ReCDroid) in reproducing bug reports. Our evaluation results suggested that integrating <em>MaCa</em> into existing approaches significantly improved the success rates of ReCDroid and Yakusu by 22.7% = (69.2%-56.4%)/56.4% and 22.9%= (62.7%-51%)/51%, respectively.<br/>
        <br />
        <a href="issta20main-id19-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Liu, Jiawei  </td>
  <td>
    <span onclick="toggle('issta20tool-id8-p-liujiawei')" title="TauJud: Test Augmentation of Machine Learning in Judicial Documents  --  Zichen Guo, Jiawei Liu, Tieke He, Zhuoyang Li, and Peitian Zhangzhu" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20-TOOL: "TauJud: Test Augmentation ..."</span></small></a>
    </span>

    <span id="issta20tool-id8-p-liujiawei"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20tool-id8-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20tool-id8-p-liujiawei')" 
      >
        <a id="issta20tool-id8-p-titleliujiawei" >
          <span style="font-size: 100%">
            TauJud: Test Augmentation of Machine Learning in Judicial Documents
          </span>
        </a>
      </span>
      <br />
      Zichen Guo, Jiawei Liu, Tieke He, Zhuoyang Li, and Peitian Zhangzhu<br />
      <i><small>(Nanjing University, China)</small></i><br />
      <span id="issta20tool-id8-p-absliujiawei" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              The booming of big data makes the adoption of machine learning ubiquitous in the legal field. As we all know, a large amount of test data can better reflect the performance of the model, so the test data must be naturally expanded. In order to solve the high cost problem of labeling data in natural language processing, people in the industry have improved the performance of text classification tasks through simple data amplification techniques. However, the data amplification requirements in the judgment documents are interpretable and logical, as observed from CAIL2018 test data with over 200,000 judicial documents. Therefore, we have designed a test augmentation tool called TauJud specifically for generating more effective test data with uniform distribution over time and location for model evaluation and save time in marking data. The demo can be found at https://github.com/governormars/TauJud.<br/>
        <br />
        <a href="issta20tool-id8-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Liu, Muyang  </td>
  <td>
    <span onclick="toggle('issta20main-id38-p-liumuyang')" title="DeepSQLi: Deep Semantic Learning for Testing SQL Injection  --  Muyang Liu, Ke Li, and Tao Chen" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "DeepSQLi: Deep Semantic Learning ..."</span></small></a>
    </span>

    <span id="issta20main-id38-p-liumuyang"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id38-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id38-p-liumuyang')" 
      >
        <a id="issta20main-id38-p-titleliumuyang" >
          <span style="font-size: 100%">
            DeepSQLi: Deep Semantic Learning for Testing SQL Injection
          </span>
        </a>
      </span>
      <br />
      Muyang Liu, Ke Li, and Tao Chen<br />
      <i><small>(University of Electronic Science and Technology of China, China; University of Exeter, UK; Loughborough University, UK)</small></i><br />
      <span id="issta20main-id38-p-absliumuyang" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Security is unarguably the most serious concern for Web applications, to which SQL injection (SQLi) attack is one of the most devastating attacks. Automatically testing SQLi vulnerabilities is of ultimate importance, yet is unfortunately far from trivial to implement. This is because the existence of a huge, or potentially infinite, number of variants and semantic possibilities of SQL leading to SQLi attacks on various Web applications. In this paper, we propose a deep natural language processing based tool, dubbed DeepSQLi, to generate test cases for detecting SQLi vulnerabilities. Through adopting deep learning based neural language model and sequence of words prediction, DeepSQLi is equipped with the ability to learn the semantic knowledge embedded in SQLi attacks, allowing it to translate user inputs (or a test case) into a new test case, which is se- mantically related and potentially more sophisticated. Experiments are conducted to compare DeepSQLi with SQLmap, a state-of-the-art SQLi testing automation tool, on six real-world Web applications that are of different scales, characteristics and domains. Empirical results demonstrate the effectiveness and the remarkable superiority of DeepSQLi over SQLmap, such that more SQLi vulnerabilities can be identified by using a less number of test cases, whilst running much faster.<br/>
        <br />
        <a href="issta20main-id38-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Liu, Ting  </td>
  <td>
    <span onclick="toggle('issta20main-id134-p-liuting')" title="Recovering Fitness Gradients for Interprocedural Boolean Flags in Search-Based Testing  --  Yun Lin, Jun Sun, Gordon Fraser, Ziheng Xiu, Ting Liu, and Jin Song Dong" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Recovering Fitness Gradients ..."</span></small></a>
    </span>

    <span id="issta20main-id134-p-liuting"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id134-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id134-p-liuting')" 
      >
        <a id="issta20main-id134-p-titleliuting" >
          <span style="font-size: 100%">
            Recovering Fitness Gradients for Interprocedural Boolean Flags in Search-Based Testing
          </span>
        </a>
      </span>
      <br />
      <a href="http://linyun.info/" target="_blank">Yun Lin</a>, Jun Sun, Gordon Fraser, Ziheng Xiu, Ting Liu, and Jin Song Dong<br />
      <i><small>(National University of Singapore, Singapore; Singapore Management University, Singapore; University of Passau, Germany; Xi&#39;an Jiaotong University, China)</small></i><br />
      <span id="issta20main-id134-p-absliuting" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              In Search-based Software Testing (SBST), test generation is guided by fitness functions that estimate how close a test case is to reach an uncovered test goal (e.g., branch). A popular fitness function estimates how close conditional statements are to evaluating to true or false, i.e., the branch distance. However, when conditions read Boolean variables (e.g., if(x &amp;&amp; y)), the branch distance provides no gradient for the search, since a Boolean can either be true or false. This flag problem can be addressed by transforming individual procedures such that Boolean flags are replaced with numeric comparisons that provide better guidance for the search. Unfortunately, defining a semantics-preserving transformation that is applicable in an interprocedural case, where Boolean flags are passed around as parameters and return values, is a daunting task. Thus, it is not yet supported by modern test generators. <br/>This work is based on the insight that fitness gradients can be recovered by using runtime information: Given an uncovered interprocedural flag branch, our approach (1) calculates context-sensitive branch distance for all control flows potentially returning the required flag in the called method, and (2) recursively aggregates these distances into a continuous value. We implemented our approach on top of the EvoSuite framework for Java, and empirically compared it with state-of-the-art testability transformations on non-trivial methods suffering from interprocedural flag problems, sampled from open source Java projects. Our experiment demonstrates that our approach achieves higher coverage on the subject methods with statistical significance and acceptable runtime overheads.<br/>
        <br />
        <a href="issta20main-id134-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
    <span onclick="toggle('issta20main-id120-p-liuting')" title="Patch Based Vulnerability Matching for Binary Programs  --  Yifei Xu, Zhengzi Xu, Bihuan Chen, Fu Song, Yang Liu, and Ting Liu" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Patch Based Vulnerability ..."</span></small></a>
    </span>

    <span id="issta20main-id120-p-liuting"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id120-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id120-p-liuting')" 
      >
        <a id="issta20main-id120-p-titleliuting" >
          <span style="font-size: 100%">
            Patch Based Vulnerability Matching for Binary Programs
          </span>
        </a>
      </span>
      <br />
      Yifei Xu, Zhengzi Xu, Bihuan Chen, Fu Song, <a href="http://www.ntu.edu.sg/home/yangliu/" target="_blank">Yang Liu</a>, and Ting Liu<br />
      <i><small>(Xi&#39;an Jiaotong University, China; Nanyang Technological University, Singapore; Fudan University, China; ShanghaiTech University, China; Zhejiang University, China)</small></i><br />
      <span id="issta20main-id120-p-absliuting" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              The binary-level function matching has been widely used to detect whether there are 1-day vulnerabilities in released programs. However, the high false positive is a challenge for current function matching solutions, since the vulnerable function is highly similar to its corresponding patched version. In this paper, the Binary X-Ray (BinXray), a patch based vulnerability matching approach, is proposed to identify the specific 1-day vulnerabilities in target programs  
accurately and effectively. In the preparing step, a basic block mapping algorithm is designed to extract the signature of a patch, by comparing the given vulnerable and patched programs. The signature is represented as a set of basic block traces. In the detection step, the patching semantics is applied to reduce irrelevant basic block traces to speed up the signature searching. The trace similarity is also designed to identify whether a target program is patched. In experiments, 12 real software projects related to 479 CVEs are collected. BinXray achieves 93.31% accuracy and the analysis time cost is only 296.17ms per function, outperforming the state-of-the-art works.<br/>
        <br />
        <a href="issta20main-id120-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;"><a href="http://www.ntu.edu.sg/home/yangliu/">Liu, Yang</a>  </td>
  <td>
    <span onclick="toggle('issta20main-id120-p-liuyang')" title="Patch Based Vulnerability Matching for Binary Programs  --  Yifei Xu, Zhengzi Xu, Bihuan Chen, Fu Song, Yang Liu, and Ting Liu" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Patch Based Vulnerability ..."</span></small></a>
    </span>

    <span id="issta20main-id120-p-liuyang"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id120-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id120-p-liuyang')" 
      >
        <a id="issta20main-id120-p-titleliuyang" >
          <span style="font-size: 100%">
            Patch Based Vulnerability Matching for Binary Programs
          </span>
        </a>
      </span>
      <br />
      Yifei Xu, Zhengzi Xu, Bihuan Chen, Fu Song, <a href="http://www.ntu.edu.sg/home/yangliu/" target="_blank">Yang Liu</a>, and Ting Liu<br />
      <i><small>(Xi&#39;an Jiaotong University, China; Nanyang Technological University, Singapore; Fudan University, China; ShanghaiTech University, China; Zhejiang University, China)</small></i><br />
      <span id="issta20main-id120-p-absliuyang" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              The binary-level function matching has been widely used to detect whether there are 1-day vulnerabilities in released programs. However, the high false positive is a challenge for current function matching solutions, since the vulnerable function is highly similar to its corresponding patched version. In this paper, the Binary X-Ray (BinXray), a patch based vulnerability matching approach, is proposed to identify the specific 1-day vulnerabilities in target programs  
accurately and effectively. In the preparing step, a basic block mapping algorithm is designed to extract the signature of a patch, by comparing the given vulnerable and patched programs. The signature is represented as a set of basic block traces. In the detection step, the patching semantics is applied to reduce irrelevant basic block traces to speed up the signature searching. The trace similarity is also designed to identify whether a target program is patched. In experiments, 12 real software projects related to 479 CVEs are collected. BinXray achieves 93.31% accuracy and the analysis time cost is only 296.17ms per function, outperforming the state-of-the-art works.<br/>
        <br />
        <a href="issta20main-id120-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
    <span onclick="toggle('issta20main-id47-p-liuyang')" title="An Empirical Study on ARM Disassembly Tools  --  Muhui Jiang, Yajin Zhou, Xiapu Luo, Ruoyu Wang, Yang Liu, and Kui Ren" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "An Empirical Study on ARM ..."</span></small></a>
    </span>

    <span id="issta20main-id47-p-liuyang"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id47-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id47-p-liuyang')" 
      >
        <a id="issta20main-id47-p-titleliuyang" >
          <span style="font-size: 100%">
            An Empirical Study on ARM Disassembly Tools
          </span>
        </a>
      </span>
      <br />
      Muhui Jiang, Yajin Zhou, <a href="http://www4.comp.polyu.edu.hk/~csxluo/" target="_blank">Xiapu Luo</a>, Ruoyu Wang, <a href="http://www.ntu.edu.sg/home/yangliu/" target="_blank">Yang Liu</a>, and Kui Ren<br />
      <i><small>(Hong Kong Polytechnic University, China; Zhejiang University, China; Arizona State University, USA; Nanyang Technological University, Singapore)</small></i><br />
      <span id="issta20main-id47-p-absliuyang" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              With the increasing popularity of embedded devices, ARM is becoming the dominant architecture for them. In the meanwhile, there is a pressing need to perform security assessments for these devices. Due to different types of peripherals, it is challenging to dynamically run the firmware of these devices in an emulated environment. Therefore, the static analysis is still commonly used. Existing work usually leverages off-the-shelf tools to disassemble stripped ARM binaries and (implicitly) assume that reliable disassembling binaries and function recognition are solved problems. However, whether this assumption really holds is unknown. <br/>In this paper, we conduct the first comprehensive study on ARM disassembly tools. Specifically, we build 1,896 ARM binaries (including 248 obfuscated ones) with different compilers, compiling options, and obfuscation methods. We then evaluate them using eight state-of-the-art ARM disassembly tools (including both commercial and noncommercial ones) on their capabilities to locate instructions and function boundaries. These two are fundamental ones, which are leveraged to build other primitives. Our work reveals some observations that have not been systematically summarized and/or confirmed. For instance, we find that the existence of both ARM and Thumb instruction sets, and the reuse of the BL instruction for both function calls and branches bring serious challenges to disassembly tools. Our evaluation sheds light on the limitations of state-of-the-art disassembly tools and points out potential directions for improvement. To engage the community, we release the data set, and the related scripts at https://github.com/valour01/arm_disasssembler_study.<br/>
        <br />
        <a href="issta20main-id47-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Liu, Yepang  </td>
  <td>
    <span onclick="toggle('issta20main-id2-p-liuyepang')" title="Detecting and Diagnosing Energy Issues for Mobile Applications  --  Xueliang Li, Yuming Yang, Yepang Liu, John P. Gallagher, and Kaishun Wu" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Detecting and Diagnosing Energy ..."</span></small></a>
    </span>

    <span id="issta20main-id2-p-liuyepang"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id2-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id2-p-liuyepang')" 
      >
        <a id="issta20main-id2-p-titleliuyepang" >
          <span style="font-size: 100%">
            Detecting and Diagnosing Energy Issues for Mobile Applications
          </span>
        </a>
      </span>
      <br />
      Xueliang Li, Yuming Yang, Yepang Liu, John P. Gallagher, and Kaishun Wu<br />
      <i><small>(Shenzhen University, China; Southern University of Science and Technology, China; Roskilde University, Denmark; IMDEA Software Institute, Spain)</small></i><br />
      <span id="issta20main-id2-p-absliuyepang" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Energy efficiency is an important criterion to judge the quality of mobile apps, but one third of our randomly sampled apps suffer from energy issues that can quickly drain battery power. To understand these issues, we conducted an empirical study on 27 well-maintained apps such as Chrome and Firefox, whose issue tracking systems are publicly accessible. Our study revealed that the main root causes of energy issues include unnecessary workload and excessively frequent operations. Surprisingly, these issues are beyond the application of present technology on energy issue detection. We also found that 25.0% of energy issues can only manifest themselves under specific contexts such as poor network performance, but such contexts are again neglected by present technology. In this paper, we propose a novel testing framework for detecting energy issues in real-world mobile apps. Our framework examines apps with well-designed input sequences and runtime contexts. To identify the root causes mentioned above, we employed a machine learning algorithm to cluster the workloads and further evaluate their necessity. For the issues concealed by the specific contexts, we carefully set up several execution contexts to catch them. More importantly, we designed leading edge technology, e.g. pre-designing input sequences with potential energy overuse and tuning tests on-the-fly, to achieve high efficacy in detecting energy issues. A large-scale evaluation shows that 91.6% issues detected in our experiments were previously unknown to developers. On average, these issues double the energy costs of the apps. Our testing technique achieves a low number of false positives.<br/>
        <br />
        <a href="issta20main-id2-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Liu, Yi  </td>
  <td>
    <span onclick="toggle('issta20main-id76-p-liuyi')" title="Testing High Performance Numerical Simulation Programs: Experience, Lessons Learned, and Open Issues  --  Xiao He, Xingwei Wang, Jia Shi, and Yi Liu" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Testing High Performance Numerical ..."</span></small></a>
    </span>

    <span id="issta20main-id76-p-liuyi"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id76-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id76-p-liuyi')" 
      >
        <a id="issta20main-id76-p-titleliuyi" >
          <span style="font-size: 100%">
            Testing High Performance Numerical Simulation Programs: Experience, Lessons Learned, and Open Issues
          </span>
        </a>
      </span>
      <br />
      Xiao He, Xingwei Wang, Jia Shi, and Yi Liu<br />
      <i><small>(University of Science and Technology Beijing, China; CNCERT/CC, China)</small></i><br />
      <span id="issta20main-id76-p-absliuyi" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              High performance numerical simulation programs are widely used to simulate actual physical processes on high performance computers for the analysis of various physical and engineering problems. They are usually regarded as non-testable due to their high complexity. This paper reports our real experience and lessons learned from testing five simulation programs that will be used to design and analyze nuclear power plants. We applied five testing approaches and found 33 bugs. We found that property-based testing and metamorphic testing are two effective methods. Nevertheless, we suffered from the lack of domain knowledge, the high test costs, the shortage of test cases, severe oracle issues, and inadequate automation support. Consequently, the five programs are not exhaustively tested from the perspective of software testing, and many existing software testing techniques and tools are not fully applicable due to scalability and portability issues. We need more collaboration and communication with other communities to promote the research and application of software testing techniques.<br/>
        <br />
        <a href="issta20main-id76-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Liu, Zhibo  </td>
  <td>
    <span onclick="toggle('issta20main-id103-p-liuzhibo')" title="How Far We Have Come: Testing Decompilation Correctness of C Decompilers  --  Zhibo Liu and Shuai Wang" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "How Far We Have Come: Testing ..."</span></small></a>
    </span>

    <span id="issta20main-id103-p-liuzhibo"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id103-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id103-p-liuzhibo')" 
      >
        <a id="issta20main-id103-p-titleliuzhibo" >
          <span style="font-size: 100%">
            How Far We Have Come: Testing Decompilation Correctness of C Decompilers
          </span>
        </a>
      </span>
      <br />
      Zhibo Liu and Shuai Wang<br />
      <i><small>(Hong Kong University of Science and Technology, China)</small></i><br />
      <span id="issta20main-id103-p-absliuzhibo" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              A C decompiler converts an executable (the output from a C compiler) into source code. The recovered C source code, once recompiled, will produce an executable with the same functionality as the original executable. With over twenty years of development, C decompilers have been widely used in production to support reverse engineering applications, including legacy software migration, security retrofitting, software comprehension, and to act as the first step in launching adversarial software exploitations. As the paramount component and the trust base in numerous cybersecurity tasks, C decompilers have enabled the analysis of malware, ransomware, and promoted cybersecurity professionals&#8217; understanding of vulnerabilities in real-world systems.  
<br/>

In contrast to this flourishing market, our observation is that in academia, outputs of C decompilers (i.e., recovered C source code) are still not extensively used. Instead, the intermediate representations are often more desired for usage when developing applications such as binary security retrofitting. We acknowledge that such conservative approaches in academia are a result of widespread and pessimistic views on the decompilation correctness. However, in conventional software engineering and security research, how much of a problem is, for instance, reusing a piece of simple legacy code by taking the output of modern C decompilers?  
<br/>

In this work, we test decompilation correctness to present an up-to-date understanding regarding modern C decompilers. We detected a total of 1,423 inputs that can trigger decompilation errors from four popular decompilers, and with extensive manual effort, we identified 13 bugs in two open-source decompilers. Our findings show that the overly pessimistic view of decompilation correctness leads researchers to underestimate the potential of modern decompilers; the state-of-the-art decompilers certainly care about the functional correctness, and they are making promising progress. However, some tasks that have been studied for years in academia, such as type inference and optimization, still impede C decompilers from generating quality outputs more than is reflected in the literature. These issues rarely receive enough attention and can lead to great confusion that misleads users.<br/>
        <br />
        <a href="issta20main-id103-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_evaluated_functional_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Functional</span></a>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Liu, Zixi  </td>
  <td>
    <span onclick="toggle('issta20main-id140-p-liuzixi')" title="Functional Code Clone Detection with Syntax and Semantics Fusion Learning  --  Chunrong Fang, Zixi Liu, Yangyang Shi, Jeff Huang, and Qingkai Shi" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Functional Code Clone Detection ..."</span></small></a>
    </span>

    <span id="issta20main-id140-p-liuzixi"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id140-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id140-p-liuzixi')" 
      >
        <a id="issta20main-id140-p-titleliuzixi" >
          <span style="font-size: 100%">
            Functional Code Clone Detection with Syntax and Semantics Fusion Learning
          </span>
        </a>
      </span>
      <br />
      Chunrong Fang, Zixi Liu, Yangyang Shi, Jeff Huang, and Qingkai Shi<br />
      <i><small>(Nanjing University, China; Texas A&#38;M University, USA; Hong Kong University of Science and Technology, China)</small></i><br />
      <span id="issta20main-id140-p-absliuzixi" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Clone detection of source code is among the most fundamental software engineering techniques. Despite intensive research in the past decade, existing techniques are still unsatisfactory in detecting &quot;functional&quot; code clones. In particular, existing techniques cannot efficiently extract syntax and semantics information from source code. In this paper, we propose a novel joint code representation that applies fusion embedding techniques to learn hidden syntactic and semantic features of source codes. Besides, we introduce a new granularity for functional code clone detection. Our approach regards the connected methods with caller-callee relationships as a functionality and the method without any caller-callee relationship with other methods represents a single functionality. Then we train a supervised deep learning model to detect functional code clones. We conduct evaluations on a large dataset of C++ programs and the experimental results show that fusion learning can significantly outperform the state-of-the-art techniques in detecting functional code clones.<br/>
        <br />
        <a href="issta20main-id140-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_available_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Available</span></a>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_evaluated_reusable_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Reusable</span></a>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_evaluated_functional_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Functional</span></a>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Lou, Yiling  </td>
  <td>
    <span onclick="toggle('issta20main-id22-p-louyiling')" title="Can Automated Program Repair Refine Fault Localization? A Unified Debugging Approach  --  Yiling Lou, Ali Ghanbari, Xia Li, Lingming Zhang, Haotian Zhang, Dan Hao, and Lu Zhang" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Can Automated Program Repair ..."</span></small></a>
    </span>

    <span id="issta20main-id22-p-louyiling"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id22-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id22-p-louyiling')" 
      >
        <a id="issta20main-id22-p-titlelouyiling" >
          <span style="font-size: 100%">
            Can Automated Program Repair Refine Fault Localization? A Unified Debugging Approach
          </span>
        </a>
      </span>
      <br />
      Yiling Lou, Ali Ghanbari, Xia Li, Lingming Zhang, Haotian Zhang, Dan Hao, and Lu Zhang<br />
      <i><small>(Peking University, China; University of Texas at Dallas, USA; Ant Financial Services, China)</small></i><br />
      <span id="issta20main-id22-p-abslouyiling" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              A large body of research efforts have been dedicated to automated software debugging, including both automated fault localization and program repair. However, existing fault localization techniques have limited effectiveness on real-world software systems while even the most advanced program repair techniques can only fix a small ratio of real-world bugs. Although fault localization and program repair are inherently connected, their only existing connection in the literature is that program repair techniques usually use off-the-shelf fault localization techniques (e.g., Ochiai) to determine the potential candidate statements/elements for patching. In this work, we propose the unified debugging approach to unify the two areas in the other direction for the first time, i.e., can program repair in turn help with fault localization? In this way, we not only open a new dimension for more powerful fault localization, but also extend the application scope of program repair to all possible bugs (not only the bugs that can be directly automatically fixed). We have designed ProFL to leverage patch-execution results (from program repair) as the feedback information for fault localization. The experimental results on the widely used Defects4J benchmark show that the basic ProFL can already at least localize 37.61% more bugs within Top-1 than state-of-the-art spectrum and mutation based fault localization. Furthermore, ProFL can boost state-of-the-art fault localization via both unsupervised and supervised learning. Meanwhile, we have demonstrated ProFL&#39;s effectiveness under different settings and through a case study within Alipay, a popular online payment system with over 1 billion global users.<br/>
        <br />
        <a href="issta20main-id22-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_available_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Available</span></a>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_evaluated_reusable_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Reusable</span></a>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_evaluated_functional_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Functional</span></a>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;"><a href="http://www4.comp.polyu.edu.hk/~csxluo/">Luo, Xiapu</a>  </td>
  <td>
    <span onclick="toggle('issta20main-id47-p-luoxiapu')" title="An Empirical Study on ARM Disassembly Tools  --  Muhui Jiang, Yajin Zhou, Xiapu Luo, Ruoyu Wang, Yang Liu, and Kui Ren" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "An Empirical Study on ARM ..."</span></small></a>
    </span>

    <span id="issta20main-id47-p-luoxiapu"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id47-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id47-p-luoxiapu')" 
      >
        <a id="issta20main-id47-p-titleluoxiapu" >
          <span style="font-size: 100%">
            An Empirical Study on ARM Disassembly Tools
          </span>
        </a>
      </span>
      <br />
      Muhui Jiang, Yajin Zhou, <a href="http://www4.comp.polyu.edu.hk/~csxluo/" target="_blank">Xiapu Luo</a>, Ruoyu Wang, <a href="http://www.ntu.edu.sg/home/yangliu/" target="_blank">Yang Liu</a>, and Kui Ren<br />
      <i><small>(Hong Kong Polytechnic University, China; Zhejiang University, China; Arizona State University, USA; Nanyang Technological University, Singapore)</small></i><br />
      <span id="issta20main-id47-p-absluoxiapu" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              With the increasing popularity of embedded devices, ARM is becoming the dominant architecture for them. In the meanwhile, there is a pressing need to perform security assessments for these devices. Due to different types of peripherals, it is challenging to dynamically run the firmware of these devices in an emulated environment. Therefore, the static analysis is still commonly used. Existing work usually leverages off-the-shelf tools to disassemble stripped ARM binaries and (implicitly) assume that reliable disassembling binaries and function recognition are solved problems. However, whether this assumption really holds is unknown. <br/>In this paper, we conduct the first comprehensive study on ARM disassembly tools. Specifically, we build 1,896 ARM binaries (including 248 obfuscated ones) with different compilers, compiling options, and obfuscation methods. We then evaluate them using eight state-of-the-art ARM disassembly tools (including both commercial and noncommercial ones) on their capabilities to locate instructions and function boundaries. These two are fundamental ones, which are leveraged to build other primitives. Our work reveals some observations that have not been systematically summarized and/or confirmed. For instance, we find that the existence of both ARM and Thumb instruction sets, and the reuse of the BL instruction for both function calls and branches bring serious challenges to disassembly tools. Our evaluation sheds light on the limitations of state-of-the-art disassembly tools and points out potential directions for improvement. To engage the community, we release the data set, and the related scripts at https://github.com/valour01/arm_disasssembler_study.<br/>
        <br />
        <a href="issta20main-id47-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Lutellier, Thibaud  </td>
  <td>
    <span onclick="toggle('issta20main-id96-p-lutellierthibaud')" title="CoCoNuT: Combining Context-Aware Neural Translation Models using Ensemble for Program Repair  --  Thibaud Lutellier, Hung Viet Pham, Lawrence Pang, Yitong Li, Moshi Wei, and Lin Tan" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "CoCoNuT: Combining Context-Aware ..."</span></small></a>
    </span>

    <span id="issta20main-id96-p-lutellierthibaud"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id96-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id96-p-lutellierthibaud')" 
      >
        <a id="issta20main-id96-p-titlelutellierthibaud" >
          <span style="font-size: 100%">
            CoCoNuT: Combining Context-Aware Neural Translation Models using Ensemble for Program Repair
          </span>
        </a>
      </span>
      <br />
      Thibaud Lutellier, Hung Viet Pham, Lawrence Pang, Yitong Li, Moshi Wei, and Lin Tan<br />
      <i><small>(University of Waterloo, Canada; Purdue University, USA)</small></i><br />
      <span id="issta20main-id96-p-abslutellierthibaud" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Automated generate-and-validate (GV) program repair techniques (APR) typically rely on hard-coded rules, thus only fixing bugs following specific fix patterns. These rules require a significant amount of manual effort to discover and it is hard to adapt these rules to different programming languages. <br/>To address these challenges, we propose a new G&amp;V technique&#8212;CoCoNuT, which uses ensemble learning on the combination of convolutional neural networks (CNNs) and a new context-aware neural machine translation (NMT) architecture to automatically fix bugs in multiple programming languages. To better represent the context of a bug, we introduce a new context-aware NMT architecture that represents the buggy source code and its surrounding context separately. CoCoNuT uses CNNs instead of recurrent neural networks (RNNs), since CNN layers can be stacked to extract hierarchical features and better model source code at different granularity levels (e.g., statements and functions). In addition, CoCoNuT takes advantage of the randomness in hyperparameter tuning to build multiple models that fix different bugs and combines these models using ensemble learning to fix more bugs. <br/>Our evaluation on six popular benchmarks for four programming languages (Java, C, Python, and JavaScript) shows that CoCoNuT correctly fixes (i.e., the first generated patch is semantically equivalent to the developer&#8217;s patch) 509 bugs, including 309 bugs that are fixed by none of the 27 techniques with which we compare.<br/>
        <br />
        <a href="issta20main-id96-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;"><a id="M"> </a>Ma, Shiqing
  </td>
  <td>
    <span onclick="toggle('issta20tool-id21-p-mashiqing')" title="FineLock: Automatically Refactoring Coarse-Grained Locks into Fine-Grained Locks  --  Yang Zhang, Shuai Shao, Juan Zhai, and Shiqing Ma" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20-TOOL: "FineLock: Automatically Refactoring ..."</span></small></a>
    </span>

    <span id="issta20tool-id21-p-mashiqing"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20tool-id21-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20tool-id21-p-mashiqing')" 
      >
        <a id="issta20tool-id21-p-titlemashiqing" >
          <span style="font-size: 100%">
            FineLock: Automatically Refactoring Coarse-Grained Locks into Fine-Grained Locks
          </span>
        </a>
      </span>
      <br />
      Yang Zhang, Shuai Shao, Juan Zhai, and Shiqing Ma<br />
      <i><small>(Hebei University of Science and Technology, China; Rutgers University, USA)</small></i><br />
      <span id="issta20tool-id21-p-absmashiqing" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Lock is a frequently-used synchronization mechanism to enforce exclusive access to a shared resource. However, lock-based concurrent programs are susceptible to lock contention, which leads to low performance and poor scalability. Furthermore, inappropriate granularity of a lock makes lock contention even worse. Compared to coarse-grained lock, fine-grained lock can mitigate lock contention but difficult to use. Converting coarse-grained lock into fine-grained lock manually is not only error-prone and tedious, but also requires a lot of expertise. In this paper, we propose to leverage program analysis techniques and pushdown automaton to automatically covert coarse-grained locks into fine-grained locks to reduce lock contention. We developed a prototype FineLock and evaluates it on 5 projects. The evaluation results demonstrate FineLock can refactor 1,546 locks in an average of 27.6 seconds, including converting 129 coarse-grained locks into fine-grained locks and 1,417 coarse-grained locks into read/write locks. By automatically providing potential refactoring recommendations, our tool saves a lot of efforts for developers.<br/>
        <br />
        <a href="issta20tool-id21-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Macêdo Batista, Daniel  </td>
  <td>
    <span onclick="toggle('issta20doc-p3-p-macedobatistadaniel')" title="Program-Aware Fuzzing for MQTT Applications  --  Luis Gustavo Araujo Rodriguez and Daniel Macêdo Batista" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20-DOC: "Program-Aware Fuzzing for ..."</span></small></a>
    </span>

    <span id="issta20doc-p3-p-macedobatistadaniel"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20doc-p3-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20doc-p3-p-macedobatistadaniel')" 
      >
        <a id="issta20doc-p3-p-titlemacedobatistadaniel" >
          <span style="font-size: 100%">
            Program-Aware Fuzzing for MQTT Applications
          </span>
        </a>
      </span>
      <br />
      Luis Gustavo Araujo Rodriguez and Daniel Macêdo Batista<br />
      <i><small>(University of São Paulo, Brazil)</small></i><br />
      <span id="issta20doc-p3-p-absmacedobatistadaniel" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Over the last few years, MQTT applications have been widely exposed to vulnerabilities because of their weak protocol implementations. For our preliminary research, we conducted background studies to: (1) determine the main cause of vulnerabilities in MQTT applications; and (2) analyze existing MQTT-based testing frameworks. Our preliminary results confirm that MQTT is most susceptible to malformed packets, and its existing testing frameworks are based on blackbox fuzzing, meaning vulnerabilities are difficult and time-consuming to find. Thus, the aim of my research is to study and develop effective fuzzing strategies for the MQTT protocol, thereby contributing to the development of more robust MQTT applications in IoT and Smart Cities.<br/>
        <br />
        <a href="issta20doc-p3-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Machalica, Mateusz  </td>
  <td>
    <span onclick="toggle('issta20main-id33-p-machalicamateusz')" title="Scaffle: Bug Localization on Millions of Files  --  Michael Pradel, Vijayaraghavan Murali, Rebecca Qian, Mateusz Machalica, Erik Meijer, and Satish Chandra" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Scaffle: Bug Localization ..."</span></small></a>
    </span>

    <span id="issta20main-id33-p-machalicamateusz"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id33-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id33-p-machalicamateusz')" 
      >
        <a id="issta20main-id33-p-titlemachalicamateusz" >
          <span style="font-size: 100%">
            Scaffle: Bug Localization on Millions of Files
          </span>
        </a>
      </span>
      <br />
      <a href="http://mp.binaervarianz.de/" target="_blank">Michael Pradel</a>, Vijayaraghavan Murali, Rebecca Qian, Mateusz Machalica, Erik Meijer, and Satish Chandra<br />
      <i><small>(University of Stuttgart, Germany; Facebook, USA)</small></i><br />
      <span id="issta20main-id33-p-absmachalicamateusz" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Despite all efforts to avoid bugs, software sometimes crashes in the field, leaving crash traces as the only information to localize the problem. Prior approaches on localizing where to fix the root cause of a crash do not scale well to ultra-large scale, heterogeneous code bases that contain millions of code files written in multiple programming languages. This paper presents Scaffle, the first scalable bug localization technique, which is based on the key insight to divide the problem into two easier sub-problems. First, a trained machine learning model predicts which lines of a raw crash trace are most informative for localizing the bug. Then, these lines are fed to an information retrieval-based search engine to retrieve file paths in the code base, predicting which file to change to address the crash. The approach does not make any assumptions about the format of a crash trace or the language that produces it. We evaluate Scaffle with tens of thousands of crash traces produced by a large-scale industrial code base at Facebook that contains millions of possible bug locations and that powers tools used by billions of people. The results show that the approach correctly predicts the file to fix for 40% to 60% (50% to 70%) of all crash traces within the top-1 (top-5) predictions. Moreover, Scaffle improves over several baseline approaches, including an existing classification-based approach, a scalable variant of existing information retrieval-based approaches, and a set of hand-tuned, industrially deployed heuristics.<br/>
        <br />
        <a href="issta20main-id33-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Manjunath, Niveditha  </td>
  <td>
    <span onclick="toggle('issta20tool-id22-p-manjunathniveditha')" title="CPSDebug: A Tool for Explanation of Failures in Cyber-Physical Systems  --  Ezio Bartocci, Niveditha Manjunath, Leonardo Mariani, Cristinel Mateis, Dejan Ničković, and Fabrizio Pastore" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20-TOOL: "CPSDebug: A Tool for Explanation ..."</span></small></a>
    </span>

    <span id="issta20tool-id22-p-manjunathniveditha"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20tool-id22-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20tool-id22-p-manjunathniveditha')" 
      >
        <a id="issta20tool-id22-p-titlemanjunathniveditha" >
          <span style="font-size: 100%">
            CPSDebug: A Tool for Explanation of Failures in Cyber-Physical Systems
          </span>
        </a>
      </span>
      <br />
      Ezio Bartocci, Niveditha Manjunath, Leonardo Mariani, Cristinel Mateis, Dejan Ničković, and Fabrizio Pastore<br />
      <i><small>(TU Vienna, Austria; Austrian Institute of Technology, Austria; University of Milano-Bicocca, Italy; University of Luxembourg, Luxembourg)</small></i><br />
      <span id="issta20tool-id22-p-absmanjunathniveditha" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Debugging Cyber-Physical System models is often challenging, as it requires identifying a potentially long, complex and heterogenous combination of events that resulted in a violation of the expected behavior of the system. In this paper we present CPSDebug, a tool for supporting designers in the debugging of failures in MATLAB Simulink/Stateflow models. CPSDebug implements a gray-box approach that combines testing, specification mining, and failure analysis to identify the causes of failures and explain their propagation in time and space. The evaluation of the tool, based on multiple usage scenarios and faults and direct feedback from engineers, shows that CPSDebug can effectively aid engineers during debugging tasks.<br/>
        <br />
        <a href="issta20tool-id22-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Mariani, Leonardo  </td>
  <td>
    <span onclick="toggle('issta20main-id98-p-marianileonardo')" title="Data Loss Detector: Automatically Revealing Data Loss Bugs in Android Apps  --  Oliviero Riganelli, Simone Paolo Mottadelli, Claudio Rota, Daniela Micucci, and Leonardo Mariani" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Data Loss Detector: Automatically ..."</span></small></a>
    </span>

    <span id="issta20main-id98-p-marianileonardo"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id98-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id98-p-marianileonardo')" 
      >
        <a id="issta20main-id98-p-titlemarianileonardo" >
          <span style="font-size: 100%">
            Data Loss Detector: Automatically Revealing Data Loss Bugs in Android Apps
          </span>
        </a>
      </span>
      <br />
      Oliviero Riganelli, Simone Paolo Mottadelli, Claudio Rota, <a href="http://www.sal.disco.unimib.it/people/daniela-micucci/" target="_blank">Daniela Micucci</a>, and Leonardo Mariani<br />
      <i><small>(University of Milano-Bicocca, Italy)</small></i><br />
      <span id="issta20main-id98-p-absmarianileonardo" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Android apps must work correctly even if their execution is interrupted by external events. For instance, an app must work properly even if a phone call is received, or after its layout is redrawn because the smartphone has been rotated. Since these events may require destroying, when the execution is interrupted, and recreating, when the execution is resumed, the foreground activity of the app, the only way to prevent the loss of state information is to save and restore it. This behavior must be explicitly implemented by app developers, who often miss to implement it properly, releasing apps affected by data loss problems, that is, apps that may lose state information when their execution is interrupted.  
Although several techniques can be used to automatically generate test cases for Android apps, the obtained test cases seldom include the interactions and the checks necessary to exercise and reveal data loss faults. To address this problem, this paper presents Data Loss Detector (DLD), a test case generation technique that integrates an exploration strategy, data-loss-revealing actions, and two customized oracle strategies for the detection of data loss failures.  
DLD revealed 75% of the faults in a benchmark of 54 Android app releases affected by 110 known data loss faults, and also revealed unknown data loss problems, outperforming competing approaches.<br/>
        <br />
        <a href="issta20main-id98-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_available_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Available</span></a>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_evaluated_reusable_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Reusable</span></a>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_evaluated_functional_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Functional</span></a>
    </span>
    <span onclick="toggle('issta20tool-id22-p-marianileonardo')" title="CPSDebug: A Tool for Explanation of Failures in Cyber-Physical Systems  --  Ezio Bartocci, Niveditha Manjunath, Leonardo Mariani, Cristinel Mateis, Dejan Ničković, and Fabrizio Pastore" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20-TOOL: "CPSDebug: A Tool for Explanation ..."</span></small></a>
    </span>

    <span id="issta20tool-id22-p-marianileonardo"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20tool-id22-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20tool-id22-p-marianileonardo')" 
      >
        <a id="issta20tool-id22-p-titlemarianileonardo" >
          <span style="font-size: 100%">
            CPSDebug: A Tool for Explanation of Failures in Cyber-Physical Systems
          </span>
        </a>
      </span>
      <br />
      Ezio Bartocci, Niveditha Manjunath, Leonardo Mariani, Cristinel Mateis, Dejan Ničković, and Fabrizio Pastore<br />
      <i><small>(TU Vienna, Austria; Austrian Institute of Technology, Austria; University of Milano-Bicocca, Italy; University of Luxembourg, Luxembourg)</small></i><br />
      <span id="issta20tool-id22-p-absmarianileonardo" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Debugging Cyber-Physical System models is often challenging, as it requires identifying a potentially long, complex and heterogenous combination of events that resulted in a violation of the expected behavior of the system. In this paper we present CPSDebug, a tool for supporting designers in the debugging of failures in MATLAB Simulink/Stateflow models. CPSDebug implements a gray-box approach that combines testing, specification mining, and failure analysis to identify the causes of failures and explain their propagation in time and space. The evaluation of the tool, based on multiple usage scenarios and faults and direct feedback from engineers, shows that CPSDebug can effectively aid engineers during debugging tasks.<br/>
        <br />
        <a href="issta20tool-id22-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Mateis, Cristinel  </td>
  <td>
    <span onclick="toggle('issta20tool-id22-p-mateiscristinel')" title="CPSDebug: A Tool for Explanation of Failures in Cyber-Physical Systems  --  Ezio Bartocci, Niveditha Manjunath, Leonardo Mariani, Cristinel Mateis, Dejan Ničković, and Fabrizio Pastore" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20-TOOL: "CPSDebug: A Tool for Explanation ..."</span></small></a>
    </span>

    <span id="issta20tool-id22-p-mateiscristinel"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20tool-id22-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20tool-id22-p-mateiscristinel')" 
      >
        <a id="issta20tool-id22-p-titlemateiscristinel" >
          <span style="font-size: 100%">
            CPSDebug: A Tool for Explanation of Failures in Cyber-Physical Systems
          </span>
        </a>
      </span>
      <br />
      Ezio Bartocci, Niveditha Manjunath, Leonardo Mariani, Cristinel Mateis, Dejan Ničković, and Fabrizio Pastore<br />
      <i><small>(TU Vienna, Austria; Austrian Institute of Technology, Austria; University of Milano-Bicocca, Italy; University of Luxembourg, Luxembourg)</small></i><br />
      <span id="issta20tool-id22-p-absmateiscristinel" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Debugging Cyber-Physical System models is often challenging, as it requires identifying a potentially long, complex and heterogenous combination of events that resulted in a violation of the expected behavior of the system. In this paper we present CPSDebug, a tool for supporting designers in the debugging of failures in MATLAB Simulink/Stateflow models. CPSDebug implements a gray-box approach that combines testing, specification mining, and failure analysis to identify the causes of failures and explain their propagation in time and space. The evaluation of the tool, based on multiple usage scenarios and faults and direct feedback from engineers, shows that CPSDebug can effectively aid engineers during debugging tasks.<br/>
        <br />
        <a href="issta20tool-id22-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Mathis, Björn  </td>
  <td>
    <span onclick="toggle('issta20main-id130-p-mathisbjoern')" title="Learning Input Tokens for Effective Fuzzing  --  Björn Mathis, Rahul Gopinath, and Andreas Zeller" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Learning Input Tokens for ..."</span></small></a>
    </span>

    <span id="issta20main-id130-p-mathisbjoern"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id130-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id130-p-mathisbjoern')" 
      >
        <a id="issta20main-id130-p-titlemathisbjoern" >
          <span style="font-size: 100%">
            Learning Input Tokens for Effective Fuzzing
          </span>
        </a>
      </span>
      <br />
      Björn Mathis, Rahul Gopinath, and Andreas Zeller<br />
      <i><small>(CISPA, Germany)</small></i><br />
      <span id="issta20main-id130-p-absmathisbjoern" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Modern fuzzing tools like AFL operate at a lexical level: They explore the input space of tested programs one byte after another. For inputs with complex syntactical properties, this is very inefficient, as keywords and other tokens have to be composed one character at a time. Fuzzers thus allow to specify dictionaries listing possible tokens the input can be composed from; such dictionaries speed up fuzzers dramatically. Also, fuzzers make use of dynamic tainting to track input tokens and infer values that are expected in the input validation phase. Unfortunately, such tokens are usually implicitly converted to program specific values which causes a loss of the taints attached to the input data in the lexical phase.  
In this paper, we present a technique to extend dynamic tainting to not only track explicit data flows but also taint implicitly converted data without suffering from taint explosion. This extension makes it possible to augment existing techniques and automatically infer a set of tokens and seed inputs for the input language of a program given nothing but the source code. Specifically targeting the lexical analysis of an input processor, our lFuzzer test generator systematically explores branches of the lexical analysis, producing a set of tokens that fully cover all decisions seen. The resulting set of tokens can be directly used as a dictionary for fuzzing. Along with the token extraction seed inputs are generated which give further fuzzing processes a head start. In our experiments, the lFuzzer-AFL combination achieves up to 17% more coverage on complex input formats like json, lisp, tinyC, and JavaScript compared to AFL.<br/>
        <br />
        <a href="issta20main-id130-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_available_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Available</span></a>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_evaluated_functional_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Functional</span></a>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Meijer, Erik  </td>
  <td>
    <span onclick="toggle('issta20main-id33-p-meijererik')" title="Scaffle: Bug Localization on Millions of Files  --  Michael Pradel, Vijayaraghavan Murali, Rebecca Qian, Mateusz Machalica, Erik Meijer, and Satish Chandra" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Scaffle: Bug Localization ..."</span></small></a>
    </span>

    <span id="issta20main-id33-p-meijererik"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id33-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id33-p-meijererik')" 
      >
        <a id="issta20main-id33-p-titlemeijererik" >
          <span style="font-size: 100%">
            Scaffle: Bug Localization on Millions of Files
          </span>
        </a>
      </span>
      <br />
      <a href="http://mp.binaervarianz.de/" target="_blank">Michael Pradel</a>, Vijayaraghavan Murali, Rebecca Qian, Mateusz Machalica, Erik Meijer, and Satish Chandra<br />
      <i><small>(University of Stuttgart, Germany; Facebook, USA)</small></i><br />
      <span id="issta20main-id33-p-absmeijererik" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Despite all efforts to avoid bugs, software sometimes crashes in the field, leaving crash traces as the only information to localize the problem. Prior approaches on localizing where to fix the root cause of a crash do not scale well to ultra-large scale, heterogeneous code bases that contain millions of code files written in multiple programming languages. This paper presents Scaffle, the first scalable bug localization technique, which is based on the key insight to divide the problem into two easier sub-problems. First, a trained machine learning model predicts which lines of a raw crash trace are most informative for localizing the bug. Then, these lines are fed to an information retrieval-based search engine to retrieve file paths in the code base, predicting which file to change to address the crash. The approach does not make any assumptions about the format of a crash trace or the language that produces it. We evaluate Scaffle with tens of thousands of crash traces produced by a large-scale industrial code base at Facebook that contains millions of possible bug locations and that powers tools used by billions of people. The results show that the approach correctly predicts the file to fix for 40% to 60% (50% to 70%) of all crash traces within the top-1 (top-5) predictions. Moreover, Scaffle improves over several baseline approaches, including an existing classification-based approach, a scalable variant of existing information retrieval-based approaches, and a set of hand-tuned, industrially deployed heuristics.<br/>
        <br />
        <a href="issta20main-id33-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Men, Duo  </td>
  <td>
    <span onclick="toggle('issta20tool-id28-p-menduo')" title="Test Recommendation System Based on Slicing Coverage Filtering  --  Ruixiang Qian, Yuan Zhao, Duo Men, Yang Feng, Qingkai Shi, Yong Huang, and Zhenyu Chen" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20-TOOL: "Test Recommendation System ..."</span></small></a>
    </span>

    <span id="issta20tool-id28-p-menduo"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20tool-id28-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20tool-id28-p-menduo')" 
      >
        <a id="issta20tool-id28-p-titlemenduo" >
          <span style="font-size: 100%">
            Test Recommendation System Based on Slicing Coverage Filtering
          </span>
        </a>
      </span>
      <br />
      Ruixiang Qian, Yuan Zhao, Duo Men, Yang Feng, Qingkai Shi, Yong Huang, and <a href="http://software.nju.edu.cn/zychen/" target="_blank">Zhenyu Chen</a><br />
      <i><small>(Nanjing University, China; Hong Kong University of Science and Technology, China; Mooctest, China)</small></i><br />
      <span id="issta20tool-id28-p-absmenduo" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Software testing plays a crucial role in software lifecycle. As a basic approach of software testing, unit testing is one of the necessary skills for software practitioners. Since testers are required to understand the inner code of the software under test(SUT) while writing a test case, testers usually need to learn how to detect the bug within SUT effectively. When novice programmers started to learn writing unit tests, they will generally watch a video lesson or reading unit tests written by others. These learning approaches are either time-consuming or too hard for a novice. To solve these problems, we developed a system, named TeSRS, to assist novice programmers to learn unit testing. TeSRS is a test recommendation system which can effectively assist test novice in learning unit testing. Utilizing program slice technique, TeSRS has gotten an enormous amount of test snippets from superior crowdsourcing test scripts. Depending on these test snippets, TeSRS provides novices a easier way for unit test learning. To sum up, TeSRS can help test novices (1) obtain high level design ideas of unit test case and (2) improve capabilities(e.g. branch coverage rate and mutation coverage rate) of their test scripts. TeSRS has built a scalable corpus composed of over 8000 test snippets from more than 25 test problems. Its stable performance shows effectiveness in unit test learning. <br/>Demo video can be found at <a>https://youtu.be/xvrLdvU8zFA</a><br/>
        <br />
        <a href="issta20tool-id28-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
      <a href="https://www.youtube.com/watch?v=xvrLdvU8zFA"><img width="15" src="../images/video.png" alt="" /><span style="font-size: 90%"> Video</span></a>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Mezini, Mira  </td>
  <td>
    <span onclick="toggle('issta20main-id78-p-mezinimira')" title="A Programming Model for Semi-implicit Parallelization of Static Analyses  --  Dominik Helm, Florian Kübler, Jan Thomas Kölzer, Philipp Haller, Michael Eichberg, Guido Salvaneschi, and Mira Mezini" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "A Programming Model for Semi-implicit ..."</span></small></a>
    </span>

    <span id="issta20main-id78-p-mezinimira"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id78-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id78-p-mezinimira')" 
      >
        <a id="issta20main-id78-p-titlemezinimira" >
          <span style="font-size: 100%">
            A Programming Model for Semi-implicit Parallelization of Static Analyses
          </span>
        </a>
      </span>
      <br />
      Dominik Helm, Florian Kübler, Jan Thomas Kölzer, Philipp Haller, Michael Eichberg, Guido Salvaneschi, and Mira Mezini<br />
      <i><small>(TU Darmstadt, Germany; KTH, Sweden)</small></i><br />
      <span id="issta20main-id78-p-absmezinimira" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Parallelization of static analyses is necessary to scale to real-world programs, but it is a complex and difficult task and, therefore, often only done manually for selected high-profile analyses. In this paper, we propose a programming model for semi-implicit parallelization of static analyses which is inspired by reactive programming. Reusing the domain-expert knowledge on how to parallelize anal-  
yses encoded in the programming framework, developers do not need to think about parallelization and concurrency issues on their own. The programming model supports stateful computations, only requires monotonic computations over lattices, and is independent of specific analyses. Our evaluation shows the applicability of the programming model to different analyses and the importance of user-selected scheduling strategies. We implemented an IFDS solver that was able to outperform a state-of-the-art, specialized parallel IFDS solver both in absolute performance and scalability.<br/>
        <br />
        <a href="issta20main-id78-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;"><a href="http://www.sal.disco.unimib.it/people/daniela-micucci/">Micucci, Daniela</a>  </td>
  <td>
    <span onclick="toggle('issta20main-id98-p-micuccidaniela')" title="Data Loss Detector: Automatically Revealing Data Loss Bugs in Android Apps  --  Oliviero Riganelli, Simone Paolo Mottadelli, Claudio Rota, Daniela Micucci, and Leonardo Mariani" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Data Loss Detector: Automatically ..."</span></small></a>
    </span>

    <span id="issta20main-id98-p-micuccidaniela"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id98-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id98-p-micuccidaniela')" 
      >
        <a id="issta20main-id98-p-titlemicuccidaniela" >
          <span style="font-size: 100%">
            Data Loss Detector: Automatically Revealing Data Loss Bugs in Android Apps
          </span>
        </a>
      </span>
      <br />
      Oliviero Riganelli, Simone Paolo Mottadelli, Claudio Rota, <a href="http://www.sal.disco.unimib.it/people/daniela-micucci/" target="_blank">Daniela Micucci</a>, and Leonardo Mariani<br />
      <i><small>(University of Milano-Bicocca, Italy)</small></i><br />
      <span id="issta20main-id98-p-absmicuccidaniela" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Android apps must work correctly even if their execution is interrupted by external events. For instance, an app must work properly even if a phone call is received, or after its layout is redrawn because the smartphone has been rotated. Since these events may require destroying, when the execution is interrupted, and recreating, when the execution is resumed, the foreground activity of the app, the only way to prevent the loss of state information is to save and restore it. This behavior must be explicitly implemented by app developers, who often miss to implement it properly, releasing apps affected by data loss problems, that is, apps that may lose state information when their execution is interrupted.  
Although several techniques can be used to automatically generate test cases for Android apps, the obtained test cases seldom include the interactions and the checks necessary to exercise and reveal data loss faults. To address this problem, this paper presents Data Loss Detector (DLD), a test case generation technique that integrates an exploration strategy, data-loss-revealing actions, and two customized oracle strategies for the detection of data loss failures.  
DLD revealed 75% of the faults in a benchmark of 54 Android app releases affected by 110 known data loss faults, and also revealed unknown data loss problems, outperforming competing approaches.<br/>
        <br />
        <a href="issta20main-id98-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_available_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Available</span></a>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_evaluated_reusable_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Reusable</span></a>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_evaluated_functional_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Functional</span></a>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;"><a href="https://aleksandarmilicevic.github.io/">Milicevic, Aleksandar</a>  </td>
  <td>
    <span onclick="toggle('issta20main-id166-p-milicevicaleksandar')" title="Debugging the Performance of Maven’s Test Isolation: Experience Report  --  Pengyu Nie, Ahmet Celik, Matthew Coley, Aleksandar Milicevic, Jonathan Bell, and Milos Gligoric" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Debugging the Performance ..."</span></small></a>
    </span>

    <span id="issta20main-id166-p-milicevicaleksandar"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id166-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id166-p-milicevicaleksandar')" 
      >
        <a id="issta20main-id166-p-titlemilicevicaleksandar" >
          <span style="font-size: 100%">
            Debugging the Performance of Maven’s Test Isolation: Experience Report
          </span>
        </a>
      </span>
      <br />
      Pengyu Nie, Ahmet Celik, Matthew Coley, <a href="https://aleksandarmilicevic.github.io/" target="_blank">Aleksandar Milicevic</a>, Jonathan Bell, and <a href="http://users.ece.utexas.edu/~gligoric/" target="_blank">Milos Gligoric</a><br />
      <i><small>(University of Texas at Austin, USA; Facebook, USA; George Mason University, USA; Microsoft, USA)</small></i><br />
      <span id="issta20main-id166-p-absmilicevicaleksandar" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Testing is the most common approach used in industry for checking software correctness. Developers frequently practice reliable testing-executing individual tests in isolation from each other-to avoid test failures caused by test-order dependencies and shared state pollution (e.g., when tests mutate static fields). A common way of doing this is by running each test as a separate process. Unfortunately, this is known to introduce substantial overhead. This experience report describes our efforts to better understand the sources of this overhead and to create a system to confirm the minimal overhead possible. We found that different build systems use different mechanisms for communicating between these multiple processes, and that because of this design decision, running tests with some build systems could be faster than with others. Through this inquiry we discovered a significant performance bug in Apache Maven&#8217;s test running code, which slowed down test execution by on average 350 milliseconds per-test when compared to a competing build system, Ant. When used for testing real projects, this can result in a significant reduction in testing time. We submitted a patch for this bug which has been integrated into the Apache Maven build system, and describe our ongoing efforts to improve Maven&#8217;s test execution tooling.<br/>
        <br />
        <a href="issta20main-id166-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Misailovic, Sasa  </td>
  <td>
    <span onclick="toggle('issta20main-id159-p-misailovicsasa')" title="Detecting Flaky Tests in Probabilistic and Machine Learning Applications  --  Saikat Dutta, August Shi, Rutvik Choudhary, Zhekun Zhang, Aryaman Jain, and Sasa Misailovic" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Detecting Flaky Tests in Probabilistic ..."</span></small></a>
    </span>

    <span id="issta20main-id159-p-misailovicsasa"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id159-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id159-p-misailovicsasa')" 
      >
        <a id="issta20main-id159-p-titlemisailovicsasa" >
          <span style="font-size: 100%">
            Detecting Flaky Tests in Probabilistic and Machine Learning Applications
          </span>
        </a>
      </span>
      <br />
      Saikat Dutta, <a href="http://mir.cs.illinois.edu/~awshi2/" target="_blank">August Shi</a>, Rutvik Choudhary, Zhekun Zhang, Aryaman Jain, and Sasa Misailovic<br />
      <i><small>(University of Illinois at Urbana-Champaign, USA)</small></i><br />
      <span id="issta20main-id159-p-absmisailovicsasa" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Probabilistic programming systems and machine learning frameworks like Pyro, PyMC3, TensorFlow, and PyTorch provide scalable and efficient primitives for inference and training. However, such operations are non-deterministic. Hence, it is challenging for developers to write tests for applications that depend on such frameworks, often resulting in flaky tests &#8211; tests which fail non-deterministically when run on the same version of code.  
<br/>

In this paper, we conduct the first extensive study of flaky tests in this domain. In particular, we study the projects that depend on four frameworks: Pyro, PyMC3, TensorFlow-Probability, and  
PyTorch. We identify 75 bug reports/commits that deal with flaky tests, and we categorize the common causes and fixes for them. This study provides developers with useful insights on dealing with flaky tests in this domain.  
<br/>

Motivated by our study, we develop a technique, FLASH, to systematically detect flaky tests due to assertions passing and failing in different runs on the same code. These assertions fail due to differences in the sequence of random numbers in different runs of the same test. FLASH exposes such failures, and our evaluation on 20 projects results in 11 previously-unknown flaky tests that we reported to developers.<br/>
        <br />
        <a href="issta20main-id159-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Mottadelli, Simone Paolo  </td>
  <td>
    <span onclick="toggle('issta20main-id98-p-mottadellisimonepaolo')" title="Data Loss Detector: Automatically Revealing Data Loss Bugs in Android Apps  --  Oliviero Riganelli, Simone Paolo Mottadelli, Claudio Rota, Daniela Micucci, and Leonardo Mariani" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Data Loss Detector: Automatically ..."</span></small></a>
    </span>

    <span id="issta20main-id98-p-mottadellisimonepaolo"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id98-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id98-p-mottadellisimonepaolo')" 
      >
        <a id="issta20main-id98-p-titlemottadellisimonepaolo" >
          <span style="font-size: 100%">
            Data Loss Detector: Automatically Revealing Data Loss Bugs in Android Apps
          </span>
        </a>
      </span>
      <br />
      Oliviero Riganelli, Simone Paolo Mottadelli, Claudio Rota, <a href="http://www.sal.disco.unimib.it/people/daniela-micucci/" target="_blank">Daniela Micucci</a>, and Leonardo Mariani<br />
      <i><small>(University of Milano-Bicocca, Italy)</small></i><br />
      <span id="issta20main-id98-p-absmottadellisimonepaolo" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Android apps must work correctly even if their execution is interrupted by external events. For instance, an app must work properly even if a phone call is received, or after its layout is redrawn because the smartphone has been rotated. Since these events may require destroying, when the execution is interrupted, and recreating, when the execution is resumed, the foreground activity of the app, the only way to prevent the loss of state information is to save and restore it. This behavior must be explicitly implemented by app developers, who often miss to implement it properly, releasing apps affected by data loss problems, that is, apps that may lose state information when their execution is interrupted.  
Although several techniques can be used to automatically generate test cases for Android apps, the obtained test cases seldom include the interactions and the checks necessary to exercise and reveal data loss faults. To address this problem, this paper presents Data Loss Detector (DLD), a test case generation technique that integrates an exploration strategy, data-loss-revealing actions, and two customized oracle strategies for the detection of data loss failures.  
DLD revealed 75% of the faults in a benchmark of 54 Android app releases affected by 110 known data loss faults, and also revealed unknown data loss problems, outperforming competing approaches.<br/>
        <br />
        <a href="issta20main-id98-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_available_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Available</span></a>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_evaluated_reusable_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Reusable</span></a>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_evaluated_functional_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Functional</span></a>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Murali, Vijayaraghavan  </td>
  <td>
    <span onclick="toggle('issta20main-id33-p-muralivijayaraghavan')" title="Scaffle: Bug Localization on Millions of Files  --  Michael Pradel, Vijayaraghavan Murali, Rebecca Qian, Mateusz Machalica, Erik Meijer, and Satish Chandra" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Scaffle: Bug Localization ..."</span></small></a>
    </span>

    <span id="issta20main-id33-p-muralivijayaraghavan"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id33-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id33-p-muralivijayaraghavan')" 
      >
        <a id="issta20main-id33-p-titlemuralivijayaraghavan" >
          <span style="font-size: 100%">
            Scaffle: Bug Localization on Millions of Files
          </span>
        </a>
      </span>
      <br />
      <a href="http://mp.binaervarianz.de/" target="_blank">Michael Pradel</a>, Vijayaraghavan Murali, Rebecca Qian, Mateusz Machalica, Erik Meijer, and Satish Chandra<br />
      <i><small>(University of Stuttgart, Germany; Facebook, USA)</small></i><br />
      <span id="issta20main-id33-p-absmuralivijayaraghavan" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Despite all efforts to avoid bugs, software sometimes crashes in the field, leaving crash traces as the only information to localize the problem. Prior approaches on localizing where to fix the root cause of a crash do not scale well to ultra-large scale, heterogeneous code bases that contain millions of code files written in multiple programming languages. This paper presents Scaffle, the first scalable bug localization technique, which is based on the key insight to divide the problem into two easier sub-problems. First, a trained machine learning model predicts which lines of a raw crash trace are most informative for localizing the bug. Then, these lines are fed to an information retrieval-based search engine to retrieve file paths in the code base, predicting which file to change to address the crash. The approach does not make any assumptions about the format of a crash trace or the language that produces it. We evaluate Scaffle with tens of thousands of crash traces produced by a large-scale industrial code base at Facebook that contains millions of possible bug locations and that powers tools used by billions of people. The results show that the approach correctly predicts the file to fix for 40% to 60% (50% to 70%) of all crash traces within the top-1 (top-5) predictions. Moreover, Scaffle improves over several baseline approaches, including an existing classification-based approach, a scalable variant of existing information retrieval-based approaches, and a set of hand-tuned, industrially deployed heuristics.<br/>
        <br />
        <a href="issta20main-id33-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;"><a id="N"> </a>Nejati, Shiva
  </td>
  <td>
    <span onclick="toggle('issta20main-id83-p-nejatishiva')" title="Automated Repair of Feature Interaction Failures in Automated Driving Systems  --  Raja Ben Abdessalem, Annibale Panichella, Shiva Nejati, Lionel C. Briand, and Thomas Stifter" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Automated Repair of Feature ..."</span></small></a>
    </span>

    <span id="issta20main-id83-p-nejatishiva"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id83-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id83-p-nejatishiva')" 
      >
        <a id="issta20main-id83-p-titlenejatishiva" >
          <span style="font-size: 100%">
            Automated Repair of Feature Interaction Failures in Automated Driving Systems
          </span>
        </a>
      </span>
      <br />
      Raja Ben Abdessalem, Annibale Panichella, Shiva Nejati, Lionel C. Briand, and Thomas Stifter<br />
      <i><small>(University of Luxembourg, Luxembourg; Delft University of Technology, Netherlands; University of Ottawa, Canada; IEE, Luxembourg)</small></i><br />
      <span id="issta20main-id83-p-absnejatishiva" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              In the past years, several automated repair strategies have been proposed to fix bugs in individual software programs without any human intervention. There has been, however, little work on how automated repair techniques can resolve failures that arise at the system-level and are caused by undesired interactions among different system components or functions. Feature interaction failures are common in complex systems such as autonomous cars that are typically built as a composition of independent features (i.e., units of functionality). In this paper, we propose a repair technique to automatically resolve undesired feature interaction failures in automated driving systems (ADS) that lead to the violation of system safety requirements. Our repair strategy achieves its goal by (1) localizing faults spanning several lines of code, (2) simultaneously resolving multiple interaction failures caused by independent faults, (3) scaling repair strategies from the unit-level to the system-level, and (4) resolving failures based on their order of severity. We have evaluated our approach using two industrial ADS containing four features. Our results show that our repair strategy resolves the undesired interaction failures in these two systems in less than 16h and outperforms existing automated repair techniques.<br/>
        <br />
        <a href="issta20main-id83-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Ničković, Dejan  </td>
  <td>
    <span onclick="toggle('issta20tool-id22-p-nickovicdejan')" title="CPSDebug: A Tool for Explanation of Failures in Cyber-Physical Systems  --  Ezio Bartocci, Niveditha Manjunath, Leonardo Mariani, Cristinel Mateis, Dejan Ničković, and Fabrizio Pastore" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20-TOOL: "CPSDebug: A Tool for Explanation ..."</span></small></a>
    </span>

    <span id="issta20tool-id22-p-nickovicdejan"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20tool-id22-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20tool-id22-p-nickovicdejan')" 
      >
        <a id="issta20tool-id22-p-titlenickovicdejan" >
          <span style="font-size: 100%">
            CPSDebug: A Tool for Explanation of Failures in Cyber-Physical Systems
          </span>
        </a>
      </span>
      <br />
      Ezio Bartocci, Niveditha Manjunath, Leonardo Mariani, Cristinel Mateis, Dejan Ničković, and Fabrizio Pastore<br />
      <i><small>(TU Vienna, Austria; Austrian Institute of Technology, Austria; University of Milano-Bicocca, Italy; University of Luxembourg, Luxembourg)</small></i><br />
      <span id="issta20tool-id22-p-absnickovicdejan" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Debugging Cyber-Physical System models is often challenging, as it requires identifying a potentially long, complex and heterogenous combination of events that resulted in a violation of the expected behavior of the system. In this paper we present CPSDebug, a tool for supporting designers in the debugging of failures in MATLAB Simulink/Stateflow models. CPSDebug implements a gray-box approach that combines testing, specification mining, and failure analysis to identify the causes of failures and explain their propagation in time and space. The evaluation of the tool, based on multiple usage scenarios and faults and direct feedback from engineers, shows that CPSDebug can effectively aid engineers during debugging tasks.<br/>
        <br />
        <a href="issta20tool-id22-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Nie, Pengyu  </td>
  <td>
    <span onclick="toggle('issta20main-id166-p-niepengyu')" title="Debugging the Performance of Maven’s Test Isolation: Experience Report  --  Pengyu Nie, Ahmet Celik, Matthew Coley, Aleksandar Milicevic, Jonathan Bell, and Milos Gligoric" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Debugging the Performance ..."</span></small></a>
    </span>

    <span id="issta20main-id166-p-niepengyu"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id166-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id166-p-niepengyu')" 
      >
        <a id="issta20main-id166-p-titleniepengyu" >
          <span style="font-size: 100%">
            Debugging the Performance of Maven’s Test Isolation: Experience Report
          </span>
        </a>
      </span>
      <br />
      Pengyu Nie, Ahmet Celik, Matthew Coley, <a href="https://aleksandarmilicevic.github.io/" target="_blank">Aleksandar Milicevic</a>, Jonathan Bell, and <a href="http://users.ece.utexas.edu/~gligoric/" target="_blank">Milos Gligoric</a><br />
      <i><small>(University of Texas at Austin, USA; Facebook, USA; George Mason University, USA; Microsoft, USA)</small></i><br />
      <span id="issta20main-id166-p-absniepengyu" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Testing is the most common approach used in industry for checking software correctness. Developers frequently practice reliable testing-executing individual tests in isolation from each other-to avoid test failures caused by test-order dependencies and shared state pollution (e.g., when tests mutate static fields). A common way of doing this is by running each test as a separate process. Unfortunately, this is known to introduce substantial overhead. This experience report describes our efforts to better understand the sources of this overhead and to create a system to confirm the minimal overhead possible. We found that different build systems use different mechanisms for communicating between these multiple processes, and that because of this design decision, running tests with some build systems could be faster than with others. Through this inquiry we discovered a significant performance bug in Apache Maven&#8217;s test running code, which slowed down test execution by on average 350 milliseconds per-test when compared to a competing build system, Ant. When used for testing real projects, this can result in a significant reduction in testing time. We submitted a patch for this bug which has been integrated into the Apache Maven build system, and describe our ongoing efforts to improve Maven&#8217;s test execution tooling.<br/>
        <br />
        <a href="issta20main-id166-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Nowack, Martin  </td>
  <td>
    <span onclick="toggle('issta20main-id94-p-nowackmartin')" title="Running Symbolic Execution Forever  --  Frank Busse, Martin Nowack, and Cristian Cadar" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Running Symbolic Execution ..."</span></small></a>
    </span>

    <span id="issta20main-id94-p-nowackmartin"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id94-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id94-p-nowackmartin')" 
      >
        <a id="issta20main-id94-p-titlenowackmartin" >
          <span style="font-size: 100%">
            Running Symbolic Execution Forever
          </span>
        </a>
      </span>
      <br />
      Frank Busse, Martin Nowack, and <a href="http://www.doc.ic.ac.uk/~cristic/" target="_blank">Cristian Cadar</a><br />
      <i><small>(Imperial College London, UK)</small></i><br />
      <span id="issta20main-id94-p-absnowackmartin" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              When symbolic execution is used to analyse real-world applications, it often consumes all available memory in a relatively short amount of time, sometimes making it impossible to analyse an application for an extended period.  
In this paper, we present a technique that can record an ongoing symbolic execution analysis to disk and selectively restore paths of interest later, making it possible to run symbolic execution indefinitely.  
To be successful, our approach addresses several essential research challenges related to detecting divergences on re-execution, storing long-running executions efficiently, changing search heuristics during re-execution, and providing a global view of the stored execution.  
Our extensive evaluation of 93 Linux applications shows that our approach is practical, enabling these applications to run for days while continuing to explore new execution paths.<br/>
        <br />
        <a href="issta20main-id94-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_available_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Available</span></a>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_evaluated_reusable_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Reusable</span></a>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_evaluated_functional_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Functional</span></a>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;"><a id="O"> </a>Oei, Reed
  </td>
  <td>
    <span onclick="toggle('issta20main-id57-p-oeireed')" title="Dependent-Test-Aware Regression Testing Techniques  --  Wing Lam, August Shi, Reed Oei, Sai Zhang, Michael D. Ernst, and Tao Xie" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Dependent-Test-Aware Regression ..."</span></small></a>
    </span>

    <span id="issta20main-id57-p-oeireed"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id57-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id57-p-oeireed')" 
      >
        <a id="issta20main-id57-p-titleoeireed" >
          <span style="font-size: 100%">
            Dependent-Test-Aware Regression Testing Techniques
          </span>
        </a>
      </span>
      <br />
      <a href="http://winglam2.web.engr.illinois.edu/" target="_blank">Wing Lam</a>, <a href="http://mir.cs.illinois.edu/~awshi2/" target="_blank">August Shi</a>, Reed Oei, Sai Zhang, <a href="https://homes.cs.washington.edu/~mernst/" target="_blank">Michael D. Ernst</a>, and <a href="http://taoxie.cs.illinois.edu/" target="_blank">Tao Xie</a><br />
      <i><small>(University of Illinois at Urbana-Champaign, USA; Google, USA; University of Washington, USA; Peking University, China)</small></i><br />
      <span id="issta20main-id57-p-absoeireed" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Developers typically rely on regression testing techniques to ensure that their changes do not break existing functionality. Unfortunately, these techniques suffer from flaky tests, which can both pass and fail when run multiple times on the same version of code and tests. One prominent type of flaky tests is order-dependent (OD) tests, which are tests that pass when run in one order but fail when run in another order. Although OD tests may cause flaky-test failures, OD tests can help developers run their tests faster by allowing them to share resources. We propose to make regression testing techniques dependent-test-aware to reduce flaky-test failures.  
<br/>

To understand the necessity of dependent-test-aware regression testing techniques, we conduct the first study on the impact of OD tests on three regression testing techniques: test prioritization, test selection, and test parallelization. In particular, we implement 4 test prioritization, 6 test selection, and 2 test parallelization algorithms, and we evaluate them on 11 Java modules with OD tests. When we run the orders produced by the traditional, dependent-test-unaware regression testing algorithms, 82% of human-written test suites and 100% of automatically-generated test suites with OD tests have at least one flaky-test failure.  
<br/>

We develop a general approach for enhancing regression testing algorithms to make them dependent-test-aware, and apply our approach to 12 algorithms. Compared to traditional, unenhanced regression testing algorithms, the enhanced algorithms use provided test dependencies to produce orders with different permutations or extra tests. Our evaluation shows that, in comparison to the orders produced by unenhanced algorithms, the orders produced by enhanced algorithms (1) have overall 80% fewer flaky-test failures due to OD tests, and (2) may add extra tests but run only 1% slower on average. Our results suggest that enhancing regression testing algorithms to be dependent-test-aware can substantially reduce flaky-test failures with only a minor slowdown to run the tests.<br/>
        <br />
        <a href="issta20main-id57-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Oh, Hakjoo  </td>
  <td>
    <span onclick="toggle('issta20main-id26-p-ohhakjoo')" title="Effective White-Box Testing of Deep Neural Networks with Adaptive Neuron-Selection Strategy  --  Seokhyun Lee, Sooyoung Cha, Dain Lee, and Hakjoo Oh" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Effective White-Box Testing ..."</span></small></a>
    </span>

    <span id="issta20main-id26-p-ohhakjoo"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id26-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id26-p-ohhakjoo')" 
      >
        <a id="issta20main-id26-p-titleohhakjoo" >
          <span style="font-size: 100%">
            Effective White-Box Testing of Deep Neural Networks with Adaptive Neuron-Selection Strategy
          </span>
        </a>
      </span>
      <br />
      Seokhyun Lee, Sooyoung Cha, Dain Lee, and Hakjoo Oh<br />
      <i><small>(Korea University, South Korea)</small></i><br />
      <span id="issta20main-id26-p-absohhakjoo" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              We present Adapt, a new white-box testing technique for deep neural networks. As deep neural networks are increasingly used in safety-first applications, testing their behavior systematically has become a critical problem. Accordingly, various testing techniques for deep neural networks have been proposed in recent years. However, neural network testing is still at an early stage and existing techniques are not yet sufficiently effective. In this paper, we aim to advance this field, in particular white-box testing approaches for neural networks, by identifying and addressing a key limitation of existing state-of-the-arts. We observe that the so-called neuron-selection strategy is a critical component of white-box testing and propose a new technique that effectively employs the strategy by continuously adapting it to the ongoing testing process. Experiments with real-world network models and datasets show that Adapt is remarkably more effective than existing testing techniques in terms of coverage and adversarial inputs found.<br/>
        <br />
        <a href="issta20main-id26-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_available_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Available</span></a>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_evaluated_reusable_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Reusable</span></a>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_evaluated_functional_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Functional</span></a>
          <span style="font-size: 80%; color: blue;"> 
            <img width="20" src="../images/award.svg" alt="" />
            ACM SIGSOFT Distinguished Paper Award</span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Ostrand, Thomas J.  </td>
  <td>
    <span onclick="toggle('issta20main-id63-p-ostrandthomasj')" title="Intermittently Failing Tests in the Embedded Systems Domain  --  Per Erik Strandberg, Thomas J. Ostrand, Elaine J. Weyuker, Wasif Afzal, and Daniel Sundmark" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Intermittently Failing Tests ..."</span></small></a>
    </span>

    <span id="issta20main-id63-p-ostrandthomasj"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id63-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id63-p-ostrandthomasj')" 
      >
        <a id="issta20main-id63-p-titleostrandthomasj" >
          <span style="font-size: 100%">
            Intermittently Failing Tests in the Embedded Systems Domain
          </span>
        </a>
      </span>
      <br />
      Per Erik Strandberg, Thomas J. Ostrand, Elaine J. Weyuker, Wasif Afzal, and Daniel Sundmark<br />
      <i><small>(Westermo Network Technologies, Sweden; Mälardalen University, Sweden; University of Central Florida, USA)</small></i><br />
      <span id="issta20main-id63-p-absostrandthomasj" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Software testing is sometimes plagued with intermittently failing tests and finding the root causes of such failing tests is often difficult. This problem has been widely studied at the unit testing level for open source software, but there has been far less investigation at the system test level, particularly the testing of industrial embedded systems. This paper describes our investigation of the root causes of intermittently failing tests in the embedded systems domain, with the goal of better understanding, explaining and categorizing the underlying faults. The subject of our investigation is a currently-running industrial embedded system, along with the system level testing that was performed. We devised and used a novel metric for classifying test cases as intermittent. From more than a half million test verdicts, we identified intermittently and consistently failing tests, and identified their root causes using multiple sources. We found that about 1-3% of all test cases were intermittently failing. From analysis of the case study results and related work, we identified nine factors associated with test case intermittence. We found that a fix for a consistently failing test typically removed a larger number of failures detected by other tests than a fix for an intermittent test. We also found that more effort was usually needed to identify fixes for intermittent tests than for consistent tests. An overlap between root causes leading to intermittent and consistent tests was identified. Many root causes of intermittence are the same in industrial embedded systems and open source software. However, when comparing unit testing to system level testing, especially for embedded systems, we observed that the test environment itself is often the cause of intermittence.<br/>
        <br />
        <a href="issta20main-id63-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;"><a id="P"> </a>Pan, Minxue
  </td>
  <td>
    <span onclick="toggle('issta20main-id155-p-panminxue')" title="Reinforcement Learning Based Curiosity-Driven Testing of Android Applications  --  Minxue Pan, An Huang, Guoxin Wang, Tian Zhang, and Xuandong Li" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Reinforcement Learning Based ..."</span></small></a>
    </span>

    <span id="issta20main-id155-p-panminxue"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id155-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id155-p-panminxue')" 
      >
        <a id="issta20main-id155-p-titlepanminxue" >
          <span style="font-size: 100%">
            Reinforcement Learning Based Curiosity-Driven Testing of Android Applications
          </span>
        </a>
      </span>
      <br />
      Minxue Pan, An Huang, Guoxin Wang, Tian Zhang, and Xuandong Li<br />
      <i><small>(Nanjing University, China)</small></i><br />
      <span id="issta20main-id155-p-abspanminxue" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Mobile applications play an important role in our daily life, while it still remains a challenge to guarantee their correctness. Model-based and systematic approaches have been applied to Android GUI testing. However, they do not show significant advantages over random approaches because of limitations such as imprecise models and poor scalability. In this paper, we propose Q-testing, a reinforcement learning based approach which benefits from both random and model-based approaches to automated testing of Android applications. Q-testing explores the Android apps with a curiosity-driven strategy that utilizes a memory set to record part of previously visited states and guides the testing towards unfamiliar functionalities. A state comparison module, which is a neural network trained by plenty of collected samples, is novelly employed to divide different states at the granularity of functional scenarios. It can determine the reinforcement learning reward in Q-testing and help the curiosity-driven strategy explore different functionalities efficiently. We conduct experiments on 50 open-source applications where Q-testing outperforms the state-of-the-art and state-of-practice Android GUI testing tools in terms of code coverage and fault detection. So far, 22 of our reported faults have been confirmed, among which 7 have been fixed.<br/>
        <br />
        <a href="issta20main-id155-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
          <span style="font-size: 80%; color: blue;"> 
            <img width="20" src="../images/award.svg" alt="" />
            ACM SIGSOFT Distinguished Paper Award</span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Pang, Lawrence  </td>
  <td>
    <span onclick="toggle('issta20main-id96-p-panglawrence')" title="CoCoNuT: Combining Context-Aware Neural Translation Models using Ensemble for Program Repair  --  Thibaud Lutellier, Hung Viet Pham, Lawrence Pang, Yitong Li, Moshi Wei, and Lin Tan" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "CoCoNuT: Combining Context-Aware ..."</span></small></a>
    </span>

    <span id="issta20main-id96-p-panglawrence"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id96-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id96-p-panglawrence')" 
      >
        <a id="issta20main-id96-p-titlepanglawrence" >
          <span style="font-size: 100%">
            CoCoNuT: Combining Context-Aware Neural Translation Models using Ensemble for Program Repair
          </span>
        </a>
      </span>
      <br />
      Thibaud Lutellier, Hung Viet Pham, Lawrence Pang, Yitong Li, Moshi Wei, and Lin Tan<br />
      <i><small>(University of Waterloo, Canada; Purdue University, USA)</small></i><br />
      <span id="issta20main-id96-p-abspanglawrence" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Automated generate-and-validate (GV) program repair techniques (APR) typically rely on hard-coded rules, thus only fixing bugs following specific fix patterns. These rules require a significant amount of manual effort to discover and it is hard to adapt these rules to different programming languages. <br/>To address these challenges, we propose a new G&amp;V technique&#8212;CoCoNuT, which uses ensemble learning on the combination of convolutional neural networks (CNNs) and a new context-aware neural machine translation (NMT) architecture to automatically fix bugs in multiple programming languages. To better represent the context of a bug, we introduce a new context-aware NMT architecture that represents the buggy source code and its surrounding context separately. CoCoNuT uses CNNs instead of recurrent neural networks (RNNs), since CNN layers can be stacked to extract hierarchical features and better model source code at different granularity levels (e.g., statements and functions). In addition, CoCoNuT takes advantage of the randomness in hyperparameter tuning to build multiple models that fix different bugs and combines these models using ensemble learning to fix more bugs. <br/>Our evaluation on six popular benchmarks for four programming languages (Java, C, Python, and JavaScript) shows that CoCoNuT correctly fixes (i.e., the first generated patch is semantically equivalent to the developer&#8217;s patch) 509 bugs, including 309 bugs that are fixed by none of the 27 techniques with which we compare.<br/>
        <br />
        <a href="issta20main-id96-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Panichella, Annibale  </td>
  <td>
    <span onclick="toggle('issta20main-id83-p-panichellaannibale')" title="Automated Repair of Feature Interaction Failures in Automated Driving Systems  --  Raja Ben Abdessalem, Annibale Panichella, Shiva Nejati, Lionel C. Briand, and Thomas Stifter" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Automated Repair of Feature ..."</span></small></a>
    </span>

    <span id="issta20main-id83-p-panichellaannibale"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id83-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id83-p-panichellaannibale')" 
      >
        <a id="issta20main-id83-p-titlepanichellaannibale" >
          <span style="font-size: 100%">
            Automated Repair of Feature Interaction Failures in Automated Driving Systems
          </span>
        </a>
      </span>
      <br />
      Raja Ben Abdessalem, Annibale Panichella, Shiva Nejati, Lionel C. Briand, and Thomas Stifter<br />
      <i><small>(University of Luxembourg, Luxembourg; Delft University of Technology, Netherlands; University of Ottawa, Canada; IEE, Luxembourg)</small></i><br />
      <span id="issta20main-id83-p-abspanichellaannibale" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              In the past years, several automated repair strategies have been proposed to fix bugs in individual software programs without any human intervention. There has been, however, little work on how automated repair techniques can resolve failures that arise at the system-level and are caused by undesired interactions among different system components or functions. Feature interaction failures are common in complex systems such as autonomous cars that are typically built as a composition of independent features (i.e., units of functionality). In this paper, we propose a repair technique to automatically resolve undesired feature interaction failures in automated driving systems (ADS) that lead to the violation of system safety requirements. Our repair strategy achieves its goal by (1) localizing faults spanning several lines of code, (2) simultaneously resolving multiple interaction failures caused by independent faults, (3) scaling repair strategies from the unit-level to the system-level, and (4) resolving failures based on their order of severity. We have evaluated our approach using two industrial ADS containing four features. Our results show that our repair strategy resolves the undesired interaction failures in these two systems in less than 16h and outperforms existing automated repair techniques.<br/>
        <br />
        <a href="issta20main-id83-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Pastore, Fabrizio  </td>
  <td>
    <span onclick="toggle('issta20tool-id22-p-pastorefabrizio')" title="CPSDebug: A Tool for Explanation of Failures in Cyber-Physical Systems  --  Ezio Bartocci, Niveditha Manjunath, Leonardo Mariani, Cristinel Mateis, Dejan Ničković, and Fabrizio Pastore" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20-TOOL: "CPSDebug: A Tool for Explanation ..."</span></small></a>
    </span>

    <span id="issta20tool-id22-p-pastorefabrizio"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20tool-id22-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20tool-id22-p-pastorefabrizio')" 
      >
        <a id="issta20tool-id22-p-titlepastorefabrizio" >
          <span style="font-size: 100%">
            CPSDebug: A Tool for Explanation of Failures in Cyber-Physical Systems
          </span>
        </a>
      </span>
      <br />
      Ezio Bartocci, Niveditha Manjunath, Leonardo Mariani, Cristinel Mateis, Dejan Ničković, and Fabrizio Pastore<br />
      <i><small>(TU Vienna, Austria; Austrian Institute of Technology, Austria; University of Milano-Bicocca, Italy; University of Luxembourg, Luxembourg)</small></i><br />
      <span id="issta20tool-id22-p-abspastorefabrizio" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Debugging Cyber-Physical System models is often challenging, as it requires identifying a potentially long, complex and heterogenous combination of events that resulted in a violation of the expected behavior of the system. In this paper we present CPSDebug, a tool for supporting designers in the debugging of failures in MATLAB Simulink/Stateflow models. CPSDebug implements a gray-box approach that combines testing, specification mining, and failure analysis to identify the causes of failures and explain their propagation in time and space. The evaluation of the tool, based on multiple usage scenarios and faults and direct feedback from engineers, shows that CPSDebug can effectively aid engineers during debugging tasks.<br/>
        <br />
        <a href="issta20tool-id22-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;"><a href="http://blogs.ubc.ca/karthik/">Pattabiraman, Karthik</a>  </td>
  <td>
    <span onclick="toggle('issta20main-id58-p-pattabiramankarthik')" title="How Effective Are Smart Contract Analysis Tools? Evaluating Smart Contract Static Analysis Tools using Bug Injection  --  Asem Ghaleb and Karthik Pattabiraman" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "How Effective Are Smart Contract ..."</span></small></a>
    </span>

    <span id="issta20main-id58-p-pattabiramankarthik"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id58-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id58-p-pattabiramankarthik')" 
      >
        <a id="issta20main-id58-p-titlepattabiramankarthik" >
          <span style="font-size: 100%">
            How Effective Are Smart Contract Analysis Tools? Evaluating Smart Contract Static Analysis Tools using Bug Injection
          </span>
        </a>
      </span>
      <br />
      Asem Ghaleb and <a href="http://blogs.ubc.ca/karthik/" target="_blank">Karthik Pattabiraman</a><br />
      <i><small>(University of British Columbia, Canada)</small></i><br />
      <span id="issta20main-id58-p-abspattabiramankarthik" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Security attacks targeting smart contracts have been on the rise, which have led to financial loss and erosion of trust. Therefore, it is important to enable developers to discover security vulnerabilities in smart contracts before deployment. A number of static analysis tools have been developed for finding security bugs in smart contracts. However, despite the numerous bug-finding tools, there is no systematic approach to evaluate the proposed tools and gauge their effectiveness. This paper proposes SolidiFI, an automated and systematic approach for evaluating smart contracts&#8217; static analysis tools. SolidiFI is based on injecting bugs (i.e., code defects) into all potential locations in a smart contract to introduce targeted security vulnerabilities. SolidiFI then checks the generated buggy contract using the static analysis tools, and identifies the bugs that the tools are unable to detect (false-negatives) along with identifying the bugs reported as false-positives. SolidiFI is used to evaluate six widely-used static analysis tools, namely, Oyente, Securify, Mythril, SmartCheck, Manticore and Slither, using a set of 50 contracts injected by 9369 distinct bugs. It finds several instances of bugs that are not detected by the evaluated tools despite their claims of being able to detect such bugs, and all the tools report many false positives.<br/>
        <br />
        <a href="issta20main-id58-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
      <a href="https://github.com/DependableSystemsLab/SolidiFI"><img width="15" src="../images/tool.png" alt="" /><span style="font-size: 90%"> Info</span></a>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_available_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Available</span></a>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_evaluated_functional_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Functional</span></a>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Peng, Qianyang  </td>
  <td>
    <span onclick="toggle('issta20main-id126-p-pengqianyang')" title="Empirically Revisiting and Enhancing IR-Based Test-Case Prioritization  --  Qianyang Peng, August Shi, and Lingming Zhang" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Empirically Revisiting and ..."</span></small></a>
    </span>

    <span id="issta20main-id126-p-pengqianyang"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id126-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id126-p-pengqianyang')" 
      >
        <a id="issta20main-id126-p-titlepengqianyang" >
          <span style="font-size: 100%">
            Empirically Revisiting and Enhancing IR-Based Test-Case Prioritization
          </span>
        </a>
      </span>
      <br />
      Qianyang Peng, <a href="http://mir.cs.illinois.edu/~awshi2/" target="_blank">August Shi</a>, and Lingming Zhang<br />
      <i><small>(University of Illinois at Urbana-Champaign, USA; University of Texas at Dallas, USA)</small></i><br />
      <span id="issta20main-id126-p-abspengqianyang" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Test-case prioritization (TCP) aims to detect regression bugs faster  
via reordering the tests run. While TCP has been studied for over  
20 years, it was almost always evaluated using seeded faults/mutants as opposed to using real test failures. In this work, we study  
the recent change-aware information retrieval (IR) technique for  
TCP. Prior work has shown it performing better than traditional  
coverage-based TCP techniques, but it was only evaluated on a  
small-scale dataset with a cost-unaware metric based on seeded  
faults/mutants. We extend the prior work by conducting a much  
larger and more realistic evaluation as well as proposing enhancements that substantially improve the performance. In particular,  
we evaluate the original technique on a large-scale, real-world  
software-evolution dataset with real failures using both cost-aware  
and cost-unaware metrics under various configurations. Also, we  
design and evaluate hybrid techniques combining the IR features,  
historical test execution time, and test failure frequencies. Our  
results show that the change-aware IR technique outperforms stateof-the-art coverage-based techniques in this real-world setting, and  
our hybrid techniques improve even further upon the original IR  
technique. Moreover, we show that flaky tests have a substantial  
impact on evaluating the change-aware TCP techniques based on  
real test failures.<br/>
        <br />
        <a href="issta20main-id126-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
      <a href="https://sites.google.com/view/ir-based-tcp"><img width="15" src="../images/tool.png" alt="" /><span style="font-size: 90%"> Info</span></a>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Pham, Hung Viet  </td>
  <td>
    <span onclick="toggle('issta20main-id96-p-phamhungviet')" title="CoCoNuT: Combining Context-Aware Neural Translation Models using Ensemble for Program Repair  --  Thibaud Lutellier, Hung Viet Pham, Lawrence Pang, Yitong Li, Moshi Wei, and Lin Tan" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "CoCoNuT: Combining Context-Aware ..."</span></small></a>
    </span>

    <span id="issta20main-id96-p-phamhungviet"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id96-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id96-p-phamhungviet')" 
      >
        <a id="issta20main-id96-p-titlephamhungviet" >
          <span style="font-size: 100%">
            CoCoNuT: Combining Context-Aware Neural Translation Models using Ensemble for Program Repair
          </span>
        </a>
      </span>
      <br />
      Thibaud Lutellier, Hung Viet Pham, Lawrence Pang, Yitong Li, Moshi Wei, and Lin Tan<br />
      <i><small>(University of Waterloo, Canada; Purdue University, USA)</small></i><br />
      <span id="issta20main-id96-p-absphamhungviet" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Automated generate-and-validate (GV) program repair techniques (APR) typically rely on hard-coded rules, thus only fixing bugs following specific fix patterns. These rules require a significant amount of manual effort to discover and it is hard to adapt these rules to different programming languages. <br/>To address these challenges, we propose a new G&amp;V technique&#8212;CoCoNuT, which uses ensemble learning on the combination of convolutional neural networks (CNNs) and a new context-aware neural machine translation (NMT) architecture to automatically fix bugs in multiple programming languages. To better represent the context of a bug, we introduce a new context-aware NMT architecture that represents the buggy source code and its surrounding context separately. CoCoNuT uses CNNs instead of recurrent neural networks (RNNs), since CNN layers can be stacked to extract hierarchical features and better model source code at different granularity levels (e.g., statements and functions). In addition, CoCoNuT takes advantage of the randomness in hyperparameter tuning to build multiple models that fix different bugs and combines these models using ensemble learning to fix more bugs. <br/>Our evaluation on six popular benchmarks for four programming languages (Java, C, Python, and JavaScript) shows that CoCoNuT correctly fixes (i.e., the first generated patch is semantically equivalent to the developer&#8217;s patch) 509 bugs, including 309 bugs that are fixed by none of the 27 techniques with which we compare.<br/>
        <br />
        <a href="issta20main-id96-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Polishchuk, Marina  </td>
  <td>
    <span onclick="toggle('issta20main-id90-p-polishchukmarina')" title="Differential Regression Testing for REST APIs  --  Patrice Godefroid, Daniel Lehmann, and Marina Polishchuk" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Differential Regression Testing ..."</span></small></a>
    </span>

    <span id="issta20main-id90-p-polishchukmarina"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id90-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id90-p-polishchukmarina')" 
      >
        <a id="issta20main-id90-p-titlepolishchukmarina" >
          <span style="font-size: 100%">
            Differential Regression Testing for REST APIs
          </span>
        </a>
      </span>
      <br />
      Patrice Godefroid, Daniel Lehmann, and Marina Polishchuk<br />
      <i><small>(Microsoft Research, USA; University of Stuttgart, Germany)</small></i><br />
      <span id="issta20main-id90-p-abspolishchukmarina" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Cloud services are programmatically accessed through REST APIs. Since REST APIs are constantly evolving, an important problem is how to prevent breaking changes of APIs, while supporting several different versions. To find such breaking changes in an automated way, we introduce differential regression testing for REST APIs.  
Our approach is based on two observations. First, breaking changes in REST APIs involve two software components, namely the client and the service. As such, there are also two types of regressions: regressions in the API specification, i.e., in the contract between the client and the service, and regressions in the service itself, i.e., previously working requests are &quot;broken&quot; in later versions of the service. Finding both kinds of regressions involves testing along two dimensions: when the service changes and when the specification changes.  
Second, to detect such bugs automatically, we employ differential testing. That is, we compare the behavior of different versions on the same inputs against each other, and find regressions in the observed differences. For generating inputs (sequences of HTTP requests) to services, we use RESTler, a stateful fuzzer for REST APIs. Comparing the outputs (HTTP responses) of a cloud service involves several challenges, like abstracting over minor differences, handling out-of-order requests, and non-determinism.  
Differential regression testing across 17 different versions of the widely-used Azure networking APIs deployed between 2016 and 2019 detected 14 regressions in total, 5 of those in the official API specifications and 9 regressions in the services themselves.<br/>
        <br />
        <a href="issta20main-id90-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Poskitt, Christopher M.  </td>
  <td>
    <span onclick="toggle('issta20main-id40-p-poskittchristopherm')" title="Active Fuzzing for Testing and Securing Cyber-Physical Systems  --  Yuqi Chen, Bohan Xuan, Christopher M. Poskitt, Jun Sun, and Fan Zhang" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Active Fuzzing for Testing ..."</span></small></a>
    </span>

    <span id="issta20main-id40-p-poskittchristopherm"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id40-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id40-p-poskittchristopherm')" 
      >
        <a id="issta20main-id40-p-titleposkittchristopherm" >
          <span style="font-size: 100%">
            Active Fuzzing for Testing and Securing Cyber-Physical Systems
          </span>
        </a>
      </span>
      <br />
      Yuqi Chen, Bohan Xuan, Christopher M. Poskitt, Jun Sun, and Fan Zhang<br />
      <i><small>(Singapore Management University, Singapore; Zhejiang University, China; Zhejiang Lab, China; Alibaba-Zhejiang University Joint Institute of Frontier Technologies, China)</small></i><br />
      <span id="issta20main-id40-p-absposkittchristopherm" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Cyber-physical systems&#160;(CPSs) in critical infrastructure face a pervasive threat from attackers, motivating research into a variety of countermeasures for securing them. Assessing the effectiveness of these countermeasures is challenging, however, as realistic benchmarks of attacks are difficult to manually construct, blindly testing is ineffective due to the enormous search spaces and resource requirements, and intelligent fuzzing approaches require impractical amounts of data and network access. In this work, we propose <em>active fuzzing</em>, an automatic approach for finding test suites of packet-level CPS network attacks, targeting scenarios in which attackers can observe sensors and manipulate packets, but have no existing knowledge about the payload encodings. Our approach learns regression models for predicting sensor values that will result from sampled network packets, and uses these predictions to guide a search for payload manipulations (i.e.&#160;bit flips) most likely to drive the CPS into an unsafe state. Key to our solution is the use of <em>online active learning</em>, which iteratively updates the models by sampling payloads that are estimated to maximally improve them. We evaluate the efficacy of active fuzzing by implementing it for a water purification plant testbed, finding it can automatically discover a test suite of flow, pressure, and over/underflow attacks, all with substantially less time, data, and network access than the most comparable approach. Finally, we demonstrate that our prediction models can also be utilised as countermeasures themselves, implementing them as anomaly detectors and early warning systems.<br/>
        <br />
        <a href="issta20main-id40-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;"><a href="http://mp.binaervarianz.de/">Pradel, Michael</a>  </td>
  <td>
    <span onclick="toggle('issta20main-id33-p-pradelmichael')" title="Scaffle: Bug Localization on Millions of Files  --  Michael Pradel, Vijayaraghavan Murali, Rebecca Qian, Mateusz Machalica, Erik Meijer, and Satish Chandra" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Scaffle: Bug Localization ..."</span></small></a>
    </span>

    <span id="issta20main-id33-p-pradelmichael"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id33-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id33-p-pradelmichael')" 
      >
        <a id="issta20main-id33-p-titlepradelmichael" >
          <span style="font-size: 100%">
            Scaffle: Bug Localization on Millions of Files
          </span>
        </a>
      </span>
      <br />
      <a href="http://mp.binaervarianz.de/" target="_blank">Michael Pradel</a>, Vijayaraghavan Murali, Rebecca Qian, Mateusz Machalica, Erik Meijer, and Satish Chandra<br />
      <i><small>(University of Stuttgart, Germany; Facebook, USA)</small></i><br />
      <span id="issta20main-id33-p-abspradelmichael" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Despite all efforts to avoid bugs, software sometimes crashes in the field, leaving crash traces as the only information to localize the problem. Prior approaches on localizing where to fix the root cause of a crash do not scale well to ultra-large scale, heterogeneous code bases that contain millions of code files written in multiple programming languages. This paper presents Scaffle, the first scalable bug localization technique, which is based on the key insight to divide the problem into two easier sub-problems. First, a trained machine learning model predicts which lines of a raw crash trace are most informative for localizing the bug. Then, these lines are fed to an information retrieval-based search engine to retrieve file paths in the code base, predicting which file to change to address the crash. The approach does not make any assumptions about the format of a crash trace or the language that produces it. We evaluate Scaffle with tens of thousands of crash traces produced by a large-scale industrial code base at Facebook that contains millions of possible bug locations and that powers tools used by billions of people. The results show that the approach correctly predicts the file to fix for 40% to 60% (50% to 70%) of all crash traces within the top-1 (top-5) predictions. Moreover, Scaffle improves over several baseline approaches, including an existing classification-based approach, a scalable variant of existing information retrieval-based approaches, and a set of hand-tuned, industrially deployed heuristics.<br/>
        <br />
        <a href="issta20main-id33-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;"><a id="Q"> </a>Qian, Rebecca
  </td>
  <td>
    <span onclick="toggle('issta20main-id33-p-qianrebecca')" title="Scaffle: Bug Localization on Millions of Files  --  Michael Pradel, Vijayaraghavan Murali, Rebecca Qian, Mateusz Machalica, Erik Meijer, and Satish Chandra" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Scaffle: Bug Localization ..."</span></small></a>
    </span>

    <span id="issta20main-id33-p-qianrebecca"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id33-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id33-p-qianrebecca')" 
      >
        <a id="issta20main-id33-p-titleqianrebecca" >
          <span style="font-size: 100%">
            Scaffle: Bug Localization on Millions of Files
          </span>
        </a>
      </span>
      <br />
      <a href="http://mp.binaervarianz.de/" target="_blank">Michael Pradel</a>, Vijayaraghavan Murali, Rebecca Qian, Mateusz Machalica, Erik Meijer, and Satish Chandra<br />
      <i><small>(University of Stuttgart, Germany; Facebook, USA)</small></i><br />
      <span id="issta20main-id33-p-absqianrebecca" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Despite all efforts to avoid bugs, software sometimes crashes in the field, leaving crash traces as the only information to localize the problem. Prior approaches on localizing where to fix the root cause of a crash do not scale well to ultra-large scale, heterogeneous code bases that contain millions of code files written in multiple programming languages. This paper presents Scaffle, the first scalable bug localization technique, which is based on the key insight to divide the problem into two easier sub-problems. First, a trained machine learning model predicts which lines of a raw crash trace are most informative for localizing the bug. Then, these lines are fed to an information retrieval-based search engine to retrieve file paths in the code base, predicting which file to change to address the crash. The approach does not make any assumptions about the format of a crash trace or the language that produces it. We evaluate Scaffle with tens of thousands of crash traces produced by a large-scale industrial code base at Facebook that contains millions of possible bug locations and that powers tools used by billions of people. The results show that the approach correctly predicts the file to fix for 40% to 60% (50% to 70%) of all crash traces within the top-1 (top-5) predictions. Moreover, Scaffle improves over several baseline approaches, including an existing classification-based approach, a scalable variant of existing information retrieval-based approaches, and a set of hand-tuned, industrially deployed heuristics.<br/>
        <br />
        <a href="issta20main-id33-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Qian, Ruixiang  </td>
  <td>
    <span onclick="toggle('issta20tool-id28-p-qianruixiang')" title="Test Recommendation System Based on Slicing Coverage Filtering  --  Ruixiang Qian, Yuan Zhao, Duo Men, Yang Feng, Qingkai Shi, Yong Huang, and Zhenyu Chen" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20-TOOL: "Test Recommendation System ..."</span></small></a>
    </span>

    <span id="issta20tool-id28-p-qianruixiang"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20tool-id28-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20tool-id28-p-qianruixiang')" 
      >
        <a id="issta20tool-id28-p-titleqianruixiang" >
          <span style="font-size: 100%">
            Test Recommendation System Based on Slicing Coverage Filtering
          </span>
        </a>
      </span>
      <br />
      Ruixiang Qian, Yuan Zhao, Duo Men, Yang Feng, Qingkai Shi, Yong Huang, and <a href="http://software.nju.edu.cn/zychen/" target="_blank">Zhenyu Chen</a><br />
      <i><small>(Nanjing University, China; Hong Kong University of Science and Technology, China; Mooctest, China)</small></i><br />
      <span id="issta20tool-id28-p-absqianruixiang" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Software testing plays a crucial role in software lifecycle. As a basic approach of software testing, unit testing is one of the necessary skills for software practitioners. Since testers are required to understand the inner code of the software under test(SUT) while writing a test case, testers usually need to learn how to detect the bug within SUT effectively. When novice programmers started to learn writing unit tests, they will generally watch a video lesson or reading unit tests written by others. These learning approaches are either time-consuming or too hard for a novice. To solve these problems, we developed a system, named TeSRS, to assist novice programmers to learn unit testing. TeSRS is a test recommendation system which can effectively assist test novice in learning unit testing. Utilizing program slice technique, TeSRS has gotten an enormous amount of test snippets from superior crowdsourcing test scripts. Depending on these test snippets, TeSRS provides novices a easier way for unit test learning. To sum up, TeSRS can help test novices (1) obtain high level design ideas of unit test case and (2) improve capabilities(e.g. branch coverage rate and mutation coverage rate) of their test scripts. TeSRS has built a scalable corpus composed of over 8000 test snippets from more than 25 test problems. Its stable performance shows effectiveness in unit test learning. <br/>Demo video can be found at <a>https://youtu.be/xvrLdvU8zFA</a><br/>
        <br />
        <a href="issta20tool-id28-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
      <a href="https://www.youtube.com/watch?v=xvrLdvU8zFA"><img width="15" src="../images/video.png" alt="" /><span style="font-size: 90%"> Video</span></a>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;"><a id="R"> </a>Rall, Daniel
  </td>
  <td>
    <span onclick="toggle('issta20main-id27-p-ralldaniel')" title="Scalable Build Service System with Smart Scheduling Service  --  Kaiyuan Wang, Greg Tener, Vijay Gullapalli, Xin Huang, Ahmed Gad, and Daniel Rall" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Scalable Build Service System ..."</span></small></a>
    </span>

    <span id="issta20main-id27-p-ralldaniel"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id27-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id27-p-ralldaniel')" 
      >
        <a id="issta20main-id27-p-titleralldaniel" >
          <span style="font-size: 100%">
            Scalable Build Service System with Smart Scheduling Service
          </span>
        </a>
      </span>
      <br />
      Kaiyuan Wang, Greg Tener, Vijay Gullapalli, Xin Huang, Ahmed Gad, and Daniel Rall<br />
      <i><small>(Google, USA)</small></i><br />
      <span id="issta20main-id27-p-absralldaniel" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Build automation is critical for developers to check if their code compiles, passes all tests and is safe to deploy to the server. Many companies adopt Continuous Integration (CI) services to make sure that the code changes from multiple developers can be safely merged at the head of the project. Internally, CI triggers builds to make sure that the new code change compiles and passes the tests. For any large company which has a monolithic code repository and thousands of developers, it is hard to make sure that all code changes are safe to submit in a timely manner. The reason is that each code change may involve multiple builds, and the company needs to run millions of builds every day to guarantee developers&#8217; productivity.  
<br/>

Google is one of those large companies that need a scalable build service to support developers&#8217; work. More than 100,000 code changes are submitted to our repository on average each day, including changes from either human users or automated tools. More than 15 million builds are executed on average each day. In this paper, we first describe an overview of our scalable build service architecture. Then, we discuss more details about how we make build scheduling decisions. Finally, we discuss some experience in the scalability of the build service system and the performance of the build scheduling service.<br/>
        <br />
        <a href="issta20main-id27-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Ren, Kui  </td>
  <td>
    <span onclick="toggle('issta20main-id47-p-renkui')" title="An Empirical Study on ARM Disassembly Tools  --  Muhui Jiang, Yajin Zhou, Xiapu Luo, Ruoyu Wang, Yang Liu, and Kui Ren" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "An Empirical Study on ARM ..."</span></small></a>
    </span>

    <span id="issta20main-id47-p-renkui"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id47-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id47-p-renkui')" 
      >
        <a id="issta20main-id47-p-titlerenkui" >
          <span style="font-size: 100%">
            An Empirical Study on ARM Disassembly Tools
          </span>
        </a>
      </span>
      <br />
      Muhui Jiang, Yajin Zhou, <a href="http://www4.comp.polyu.edu.hk/~csxluo/" target="_blank">Xiapu Luo</a>, Ruoyu Wang, <a href="http://www.ntu.edu.sg/home/yangliu/" target="_blank">Yang Liu</a>, and Kui Ren<br />
      <i><small>(Hong Kong Polytechnic University, China; Zhejiang University, China; Arizona State University, USA; Nanyang Technological University, Singapore)</small></i><br />
      <span id="issta20main-id47-p-absrenkui" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              With the increasing popularity of embedded devices, ARM is becoming the dominant architecture for them. In the meanwhile, there is a pressing need to perform security assessments for these devices. Due to different types of peripherals, it is challenging to dynamically run the firmware of these devices in an emulated environment. Therefore, the static analysis is still commonly used. Existing work usually leverages off-the-shelf tools to disassemble stripped ARM binaries and (implicitly) assume that reliable disassembling binaries and function recognition are solved problems. However, whether this assumption really holds is unknown. <br/>In this paper, we conduct the first comprehensive study on ARM disassembly tools. Specifically, we build 1,896 ARM binaries (including 248 obfuscated ones) with different compilers, compiling options, and obfuscation methods. We then evaluate them using eight state-of-the-art ARM disassembly tools (including both commercial and noncommercial ones) on their capabilities to locate instructions and function boundaries. These two are fundamental ones, which are leveraged to build other primitives. Our work reveals some observations that have not been systematically summarized and/or confirmed. For instance, we find that the existence of both ARM and Thumb instruction sets, and the reuse of the BL instruction for both function calls and branches bring serious challenges to disassembly tools. Our evaluation sheds light on the limitations of state-of-the-art disassembly tools and points out potential directions for improvement. To engage the community, we release the data set, and the related scripts at https://github.com/valour01/arm_disasssembler_study.<br/>
        <br />
        <a href="issta20main-id47-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Riganelli, Oliviero  </td>
  <td>
    <span onclick="toggle('issta20main-id98-p-riganellioliviero')" title="Data Loss Detector: Automatically Revealing Data Loss Bugs in Android Apps  --  Oliviero Riganelli, Simone Paolo Mottadelli, Claudio Rota, Daniela Micucci, and Leonardo Mariani" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Data Loss Detector: Automatically ..."</span></small></a>
    </span>

    <span id="issta20main-id98-p-riganellioliviero"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id98-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id98-p-riganellioliviero')" 
      >
        <a id="issta20main-id98-p-titleriganellioliviero" >
          <span style="font-size: 100%">
            Data Loss Detector: Automatically Revealing Data Loss Bugs in Android Apps
          </span>
        </a>
      </span>
      <br />
      Oliviero Riganelli, Simone Paolo Mottadelli, Claudio Rota, <a href="http://www.sal.disco.unimib.it/people/daniela-micucci/" target="_blank">Daniela Micucci</a>, and Leonardo Mariani<br />
      <i><small>(University of Milano-Bicocca, Italy)</small></i><br />
      <span id="issta20main-id98-p-absriganellioliviero" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Android apps must work correctly even if their execution is interrupted by external events. For instance, an app must work properly even if a phone call is received, or after its layout is redrawn because the smartphone has been rotated. Since these events may require destroying, when the execution is interrupted, and recreating, when the execution is resumed, the foreground activity of the app, the only way to prevent the loss of state information is to save and restore it. This behavior must be explicitly implemented by app developers, who often miss to implement it properly, releasing apps affected by data loss problems, that is, apps that may lose state information when their execution is interrupted.  
Although several techniques can be used to automatically generate test cases for Android apps, the obtained test cases seldom include the interactions and the checks necessary to exercise and reveal data loss faults. To address this problem, this paper presents Data Loss Detector (DLD), a test case generation technique that integrates an exploration strategy, data-loss-revealing actions, and two customized oracle strategies for the detection of data loss failures.  
DLD revealed 75% of the faults in a benchmark of 54 Android app releases affected by 110 known data loss faults, and also revealed unknown data loss problems, outperforming competing approaches.<br/>
        <br />
        <a href="issta20main-id98-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_available_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Available</span></a>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_evaluated_reusable_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Reusable</span></a>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_evaluated_functional_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Functional</span></a>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Rinetzky, Noam  </td>
  <td>
    <span onclick="toggle('issta20main-id53-p-rinetzkynoam')" title="Relocatable Addressing Model for Symbolic Execution  --  David Trabish and Noam Rinetzky" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Relocatable Addressing Model ..."</span></small></a>
    </span>

    <span id="issta20main-id53-p-rinetzkynoam"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id53-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id53-p-rinetzkynoam')" 
      >
        <a id="issta20main-id53-p-titlerinetzkynoam" >
          <span style="font-size: 100%">
            Relocatable Addressing Model for Symbolic Execution
          </span>
        </a>
      </span>
      <br />
      David Trabish and Noam Rinetzky<br />
      <i><small>(Tel Aviv University, Israel)</small></i><br />
      <span id="issta20main-id53-p-absrinetzkynoam" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Symbolic execution (SE) is a widely used program analysis technique.  
Existing SE engines model the memory space by associating  
memory objects with concrete addresses, where the representation  
of each allocated object is determined during its allocation. We  
present a novel addressing model where the underlying representation of an allocated object can be dynamically modified even after  
its allocation, by using symbolic addresses rather than concrete  
ones. We demonstrate the benefits of our model in two application scenarios: dynamic inter- and intra-object partitioning. In the  
former, we show how the recently proposed segmented memory  
model can be improved by dynamically merging several object  
representations into a single one, rather than doing that a-priori  
using static pointer analysis. In the latter, we show how the cost  
of solving array theory constraints can be reduced by splitting the  
representations of large objects into multiple smaller ones. Our preliminary results show that our approach can significantly improve  
the overall effectiveness of the symbolic exploration.<br/>
        <br />
        <a href="issta20main-id53-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Rosner, Nicolás  </td>
  <td>
    <span onclick="toggle('issta20main-id101-p-rosnernicolas')" title="Feedback-Driven Side-Channel Analysis for Networked Applications  --  İsmet Burak Kadron, Nicolás Rosner, and Tevfik Bultan" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Feedback-Driven Side-Channel ..."</span></small></a>
    </span>

    <span id="issta20main-id101-p-rosnernicolas"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id101-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id101-p-rosnernicolas')" 
      >
        <a id="issta20main-id101-p-titlerosnernicolas" >
          <span style="font-size: 100%">
            Feedback-Driven Side-Channel Analysis for Networked Applications
          </span>
        </a>
      </span>
      <br />
      İsmet Burak Kadron, Nicolás Rosner, and <a href="http://www.cs.ucsb.edu/~bultan/" target="_blank">Tevfik Bultan</a><br />
      <i><small>(University of California at Santa Barbara, USA)</small></i><br />
      <span id="issta20main-id101-p-absrosnernicolas" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Information leakage in software systems is a problem of growing importance. Networked applications can leak sensitive information even when they use encryption. For example, some characteristics of network packets, such as their size, timing and direction, are visible even for encrypted traffic. Patterns in these characteristics can be leveraged as side channels to extract information about secret values accessed by the application. In this paper, we present a new tool called AutoFeed for detecting and quantifying information leakage due to side channels in networked software applications. AutoFeed profiles the target system and automatically explores the input space, explores the space of output features that may leak information, quantifies the information leakage, and identifies the top-leaking features.  
Given a set of input mutators and a small number of initial inputs provided by the user, AutoFeed iteratively mutates inputs and periodically updates its leakage estimations to identify the features that leak the greatest amount of information about the secret of interest. AutoFeed uses a feedback loop for incremental profiling, and a stopping criterion that terminates the analysis when the leakage estimation for the top-leaking features converges. AutoFeed also automatically assigns weights to mutators in order to focus the search of the input space on exploring dimensions that are relevant to the leakage quantification. Our experimental evaluation on the benchmarks shows that AutoFeed is effective in detecting and quantifying information leaks in networked applications.<br/>
        <br />
        <a href="issta20main-id101-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Rota, Claudio  </td>
  <td>
    <span onclick="toggle('issta20main-id98-p-rotaclaudio')" title="Data Loss Detector: Automatically Revealing Data Loss Bugs in Android Apps  --  Oliviero Riganelli, Simone Paolo Mottadelli, Claudio Rota, Daniela Micucci, and Leonardo Mariani" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Data Loss Detector: Automatically ..."</span></small></a>
    </span>

    <span id="issta20main-id98-p-rotaclaudio"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id98-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id98-p-rotaclaudio')" 
      >
        <a id="issta20main-id98-p-titlerotaclaudio" >
          <span style="font-size: 100%">
            Data Loss Detector: Automatically Revealing Data Loss Bugs in Android Apps
          </span>
        </a>
      </span>
      <br />
      Oliviero Riganelli, Simone Paolo Mottadelli, Claudio Rota, <a href="http://www.sal.disco.unimib.it/people/daniela-micucci/" target="_blank">Daniela Micucci</a>, and Leonardo Mariani<br />
      <i><small>(University of Milano-Bicocca, Italy)</small></i><br />
      <span id="issta20main-id98-p-absrotaclaudio" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Android apps must work correctly even if their execution is interrupted by external events. For instance, an app must work properly even if a phone call is received, or after its layout is redrawn because the smartphone has been rotated. Since these events may require destroying, when the execution is interrupted, and recreating, when the execution is resumed, the foreground activity of the app, the only way to prevent the loss of state information is to save and restore it. This behavior must be explicitly implemented by app developers, who often miss to implement it properly, releasing apps affected by data loss problems, that is, apps that may lose state information when their execution is interrupted.  
Although several techniques can be used to automatically generate test cases for Android apps, the obtained test cases seldom include the interactions and the checks necessary to exercise and reveal data loss faults. To address this problem, this paper presents Data Loss Detector (DLD), a test case generation technique that integrates an exploration strategy, data-loss-revealing actions, and two customized oracle strategies for the detection of data loss failures.  
DLD revealed 75% of the faults in a benchmark of 54 Android app releases affected by 110 known data loss faults, and also revealed unknown data loss problems, outperforming competing approaches.<br/>
        <br />
        <a href="issta20main-id98-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_available_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Available</span></a>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_evaluated_reusable_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Reusable</span></a>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_evaluated_functional_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Functional</span></a>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Rubio-González, Cindy  </td>
  <td>
    <span onclick="toggle('issta20main-id128-p-rubiogonzalezcindy')" title="Discovering Discrepancies in Numerical Libraries  --  Jackson Vanover, Xuan Deng, and Cindy Rubio-González" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Discovering Discrepancies ..."</span></small></a>
    </span>

    <span id="issta20main-id128-p-rubiogonzalezcindy"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id128-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id128-p-rubiogonzalezcindy')" 
      >
        <a id="issta20main-id128-p-titlerubiogonzalezcindy" >
          <span style="font-size: 100%">
            Discovering Discrepancies in Numerical Libraries
          </span>
        </a>
      </span>
      <br />
      Jackson Vanover, Xuan Deng, and Cindy Rubio-González<br />
      <i><small>(University of California at Davis, USA)</small></i><br />
      <span id="issta20main-id128-p-absrubiogonzalezcindy" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Numerical libraries constitute the building blocks for software  
applications that perform numerical calculations. Thus, it is  
paramount that such libraries provide accurate and consistent results.  
To that end, this paper addresses the problem of finding discrepancies  
between synonymous functions in different numerical libraries as a  
means of identifying incorrect behavior. Our approach automatically  
finds such synonymous functions, synthesizes testing drivers, and  
executes differential tests to discover meaningful discrepancies  
across numerical libraries. We implement our approach in a tool named  
FPDiff, and provide an evaluation on four popular numerical libraries:  
GNU Scientific Library (GSL), SciPy, mpmath, and jmat. FPDiff finds  
a total of 126 equivalence classes with a 95.8% precision  
and 79% recall, and discovers 655 instances in which  
an input produces a set of disagreeing outputs between function  
synonyms, 150 of which we found to represent  
125 unique bugs. We have reported all bugs to library  
maintainers; so far, 30 bugs have been fixed, 9  
have been found to be previously known, and 25 more  
have been acknowledged by developers.<br/>
        <br />
        <a href="issta20main-id128-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_available_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Available</span></a>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_evaluated_reusable_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Reusable</span></a>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_evaluated_functional_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Functional</span></a>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;"><a id="S"> </a>Salvaneschi, Guido
  </td>
  <td>
    <span onclick="toggle('issta20main-id78-p-salvaneschiguido')" title="A Programming Model for Semi-implicit Parallelization of Static Analyses  --  Dominik Helm, Florian Kübler, Jan Thomas Kölzer, Philipp Haller, Michael Eichberg, Guido Salvaneschi, and Mira Mezini" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "A Programming Model for Semi-implicit ..."</span></small></a>
    </span>

    <span id="issta20main-id78-p-salvaneschiguido"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id78-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id78-p-salvaneschiguido')" 
      >
        <a id="issta20main-id78-p-titlesalvaneschiguido" >
          <span style="font-size: 100%">
            A Programming Model for Semi-implicit Parallelization of Static Analyses
          </span>
        </a>
      </span>
      <br />
      Dominik Helm, Florian Kübler, Jan Thomas Kölzer, Philipp Haller, Michael Eichberg, Guido Salvaneschi, and Mira Mezini<br />
      <i><small>(TU Darmstadt, Germany; KTH, Sweden)</small></i><br />
      <span id="issta20main-id78-p-abssalvaneschiguido" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Parallelization of static analyses is necessary to scale to real-world programs, but it is a complex and difficult task and, therefore, often only done manually for selected high-profile analyses. In this paper, we propose a programming model for semi-implicit parallelization of static analyses which is inspired by reactive programming. Reusing the domain-expert knowledge on how to parallelize anal-  
yses encoded in the programming framework, developers do not need to think about parallelization and concurrency issues on their own. The programming model supports stateful computations, only requires monotonic computations over lattices, and is independent of specific analyses. Our evaluation shows the applicability of the programming model to different analyses and the importance of user-selected scheduling strategies. We implemented an IFDS solver that was able to outperform a state-of-the-art, specialized parallel IFDS solver both in absolute performance and scalability.<br/>
        <br />
        <a href="issta20main-id78-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Shao, Shuai  </td>
  <td>
    <span onclick="toggle('issta20tool-id21-p-shaoshuai')" title="FineLock: Automatically Refactoring Coarse-Grained Locks into Fine-Grained Locks  --  Yang Zhang, Shuai Shao, Juan Zhai, and Shiqing Ma" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20-TOOL: "FineLock: Automatically Refactoring ..."</span></small></a>
    </span>

    <span id="issta20tool-id21-p-shaoshuai"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20tool-id21-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20tool-id21-p-shaoshuai')" 
      >
        <a id="issta20tool-id21-p-titleshaoshuai" >
          <span style="font-size: 100%">
            FineLock: Automatically Refactoring Coarse-Grained Locks into Fine-Grained Locks
          </span>
        </a>
      </span>
      <br />
      Yang Zhang, Shuai Shao, Juan Zhai, and Shiqing Ma<br />
      <i><small>(Hebei University of Science and Technology, China; Rutgers University, USA)</small></i><br />
      <span id="issta20tool-id21-p-absshaoshuai" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Lock is a frequently-used synchronization mechanism to enforce exclusive access to a shared resource. However, lock-based concurrent programs are susceptible to lock contention, which leads to low performance and poor scalability. Furthermore, inappropriate granularity of a lock makes lock contention even worse. Compared to coarse-grained lock, fine-grained lock can mitigate lock contention but difficult to use. Converting coarse-grained lock into fine-grained lock manually is not only error-prone and tedious, but also requires a lot of expertise. In this paper, we propose to leverage program analysis techniques and pushdown automaton to automatically covert coarse-grained locks into fine-grained locks to reduce lock contention. We developed a prototype FineLock and evaluates it on 5 projects. The evaluation results demonstrate FineLock can refactor 1,546 locks in an average of 27.6 seconds, including converting 129 coarse-grained locks into fine-grained locks and 1,417 coarse-grained locks into read/write locks. By automatically providing potential refactoring recommendations, our tool saves a lot of efforts for developers.<br/>
        <br />
        <a href="issta20tool-id21-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Sharma, Arnab  </td>
  <td>
    <span onclick="toggle('issta20main-id85-p-sharmaarnab')" title="Higher Income, Larger Loan? Monotonicity Testing of Machine Learning Models  --  Arnab Sharma and Heike Wehrheim" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Higher Income, Larger Loan? ..."</span></small></a>
    </span>

    <span id="issta20main-id85-p-sharmaarnab"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id85-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id85-p-sharmaarnab')" 
      >
        <a id="issta20main-id85-p-titlesharmaarnab" >
          <span style="font-size: 100%">
            Higher Income, Larger Loan? Monotonicity Testing of Machine Learning Models
          </span>
        </a>
      </span>
      <br />
      Arnab Sharma and Heike Wehrheim<br />
      <i><small>(University of Paderborn, Germany)</small></i><br />
      <span id="issta20main-id85-p-abssharmaarnab" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Today, machine learning (ML) models are increasingly applied in decision making.  
This induces an urgent need for quality assurance of ML models with respect to (often domain-dependent) requirements. Monotonicity is one such requirement. It specifies a software as &#39;&#39;learned&#39;&#39; by an ML algorithm to give an increasing prediction with the increase of some attribute values. While there exist multiple ML algorithms for ensuring monotonicity of the generated model, approaches for checking monotonicity, in particular of black-box models are largely lacking.  
<br/>

In this work, we propose verification-based testing of monotonicity, i.e., the formal computation of test inputs on a white-box model via verification technology, and the automatic inference of  
this approximating white-box model from the black-box model under test. On the white-box model, the space of test inputs can be systematically explored by a directed computation of test cases.  
The empirical evaluation on 90 black-box models shows that verification-based testing can outperform adaptive random testing as well as property-based techniques with respect to effectiveness and efficiency.<br/>
        <br />
        <a href="issta20main-id85-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Shen, Mingzhu  </td>
  <td>
    <span onclick="toggle('issta20main-id19-p-shenmingzhu')" title="Automated Classification of Actions in Bug Reports of Mobile Apps  --  Hui Liu, Mingzhu Shen, Jiahao Jin, and Yanjie Jiang" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Automated Classification of ..."</span></small></a>
    </span>

    <span id="issta20main-id19-p-shenmingzhu"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id19-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id19-p-shenmingzhu')" 
      >
        <a id="issta20main-id19-p-titleshenmingzhu" >
          <span style="font-size: 100%">
            Automated Classification of Actions in Bug Reports of Mobile Apps
          </span>
        </a>
      </span>
      <br />
      Hui Liu, Mingzhu Shen, Jiahao Jin, and Yanjie Jiang<br />
      <i><small>(Beijing Institute of Technology, China)</small></i><br />
      <span id="issta20main-id19-p-absshenmingzhu" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              When users encounter problems with mobile apps, they may commit such problems to developers as bug reports. To facilitate the processing of bug reports, researchers proposed approaches to validate the reported issues automatically according to the <em>steps to reproduce</em> specified in bug reports. Although such approaches have achieved high success rate in reproducing the reported issues, they often rely on a predefined vocabulary to identify and classify actions in bug reports. However, such manually constructed vocabulary and classification have significant limitations. It is challenging for the vocabulary to cover all potential action words because users may describe the same action with different words. Besides that, classification of actions solely based on the action words could be inaccurate because the same action word, appearing in different contexts, may have different meaning and thus belongs to different action categories. To this end, in this paper we propose an automated approach, called <em>MaCa</em>, to identify and classify action words in Mobile apps&#8217; bug reports. For a given bug report, it first identifies action words based on natural language processing. For each of the resulting action words, <em>MaCa</em> extracts its contexts, i.e., its enclosing segment, the associated UI target, and the type of its target element by both natural language processing and static analysis of the associated app. The action word and its contexts are then fed into a machine learning based classifier that predicts the category of the given action word in the given context. To train the classifier, we manually labelled 1,202 actions words from 525 bug reports that are associated with 207 apps. Our evaluation results on manually labelled data suggested that <em>MaCa</em> was accurate with high accuracy varying from 95% to 96.7%. We also investigated to what extent <em>MaCa</em> could further improve existing approaches (i.e., Yakusu and ReCDroid) in reproducing bug reports. Our evaluation results suggested that integrating <em>MaCa</em> into existing approaches significantly improved the success rates of ReCDroid and Yakusu by 22.7% = (69.2%-56.4%)/56.4% and 22.9%= (62.7%-51%)/51%, respectively.<br/>
        <br />
        <a href="issta20main-id19-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;"><a href="http://mir.cs.illinois.edu/~awshi2/">Shi, August</a>  </td>
  <td>
    <span onclick="toggle('issta20main-id126-p-shiaugust')" title="Empirically Revisiting and Enhancing IR-Based Test-Case Prioritization  --  Qianyang Peng, August Shi, and Lingming Zhang" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Empirically Revisiting and ..."</span></small></a>
    </span>

    <span id="issta20main-id126-p-shiaugust"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id126-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id126-p-shiaugust')" 
      >
        <a id="issta20main-id126-p-titleshiaugust" >
          <span style="font-size: 100%">
            Empirically Revisiting and Enhancing IR-Based Test-Case Prioritization
          </span>
        </a>
      </span>
      <br />
      Qianyang Peng, <a href="http://mir.cs.illinois.edu/~awshi2/" target="_blank">August Shi</a>, and Lingming Zhang<br />
      <i><small>(University of Illinois at Urbana-Champaign, USA; University of Texas at Dallas, USA)</small></i><br />
      <span id="issta20main-id126-p-absshiaugust" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Test-case prioritization (TCP) aims to detect regression bugs faster  
via reordering the tests run. While TCP has been studied for over  
20 years, it was almost always evaluated using seeded faults/mutants as opposed to using real test failures. In this work, we study  
the recent change-aware information retrieval (IR) technique for  
TCP. Prior work has shown it performing better than traditional  
coverage-based TCP techniques, but it was only evaluated on a  
small-scale dataset with a cost-unaware metric based on seeded  
faults/mutants. We extend the prior work by conducting a much  
larger and more realistic evaluation as well as proposing enhancements that substantially improve the performance. In particular,  
we evaluate the original technique on a large-scale, real-world  
software-evolution dataset with real failures using both cost-aware  
and cost-unaware metrics under various configurations. Also, we  
design and evaluate hybrid techniques combining the IR features,  
historical test execution time, and test failure frequencies. Our  
results show that the change-aware IR technique outperforms stateof-the-art coverage-based techniques in this real-world setting, and  
our hybrid techniques improve even further upon the original IR  
technique. Moreover, we show that flaky tests have a substantial  
impact on evaluating the change-aware TCP techniques based on  
real test failures.<br/>
        <br />
        <a href="issta20main-id126-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
      <a href="https://sites.google.com/view/ir-based-tcp"><img width="15" src="../images/tool.png" alt="" /><span style="font-size: 90%"> Info</span></a>
    </span>
    <span onclick="toggle('issta20main-id57-p-shiaugust')" title="Dependent-Test-Aware Regression Testing Techniques  --  Wing Lam, August Shi, Reed Oei, Sai Zhang, Michael D. Ernst, and Tao Xie" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Dependent-Test-Aware Regression ..."</span></small></a>
    </span>

    <span id="issta20main-id57-p-shiaugust"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id57-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id57-p-shiaugust')" 
      >
        <a id="issta20main-id57-p-titleshiaugust" >
          <span style="font-size: 100%">
            Dependent-Test-Aware Regression Testing Techniques
          </span>
        </a>
      </span>
      <br />
      <a href="http://winglam2.web.engr.illinois.edu/" target="_blank">Wing Lam</a>, <a href="http://mir.cs.illinois.edu/~awshi2/" target="_blank">August Shi</a>, Reed Oei, Sai Zhang, <a href="https://homes.cs.washington.edu/~mernst/" target="_blank">Michael D. Ernst</a>, and <a href="http://taoxie.cs.illinois.edu/" target="_blank">Tao Xie</a><br />
      <i><small>(University of Illinois at Urbana-Champaign, USA; Google, USA; University of Washington, USA; Peking University, China)</small></i><br />
      <span id="issta20main-id57-p-absshiaugust" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Developers typically rely on regression testing techniques to ensure that their changes do not break existing functionality. Unfortunately, these techniques suffer from flaky tests, which can both pass and fail when run multiple times on the same version of code and tests. One prominent type of flaky tests is order-dependent (OD) tests, which are tests that pass when run in one order but fail when run in another order. Although OD tests may cause flaky-test failures, OD tests can help developers run their tests faster by allowing them to share resources. We propose to make regression testing techniques dependent-test-aware to reduce flaky-test failures.  
<br/>

To understand the necessity of dependent-test-aware regression testing techniques, we conduct the first study on the impact of OD tests on three regression testing techniques: test prioritization, test selection, and test parallelization. In particular, we implement 4 test prioritization, 6 test selection, and 2 test parallelization algorithms, and we evaluate them on 11 Java modules with OD tests. When we run the orders produced by the traditional, dependent-test-unaware regression testing algorithms, 82% of human-written test suites and 100% of automatically-generated test suites with OD tests have at least one flaky-test failure.  
<br/>

We develop a general approach for enhancing regression testing algorithms to make them dependent-test-aware, and apply our approach to 12 algorithms. Compared to traditional, unenhanced regression testing algorithms, the enhanced algorithms use provided test dependencies to produce orders with different permutations or extra tests. Our evaluation shows that, in comparison to the orders produced by unenhanced algorithms, the orders produced by enhanced algorithms (1) have overall 80% fewer flaky-test failures due to OD tests, and (2) may add extra tests but run only 1% slower on average. Our results suggest that enhancing regression testing algorithms to be dependent-test-aware can substantially reduce flaky-test failures with only a minor slowdown to run the tests.<br/>
        <br />
        <a href="issta20main-id57-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
    <span onclick="toggle('issta20main-id159-p-shiaugust')" title="Detecting Flaky Tests in Probabilistic and Machine Learning Applications  --  Saikat Dutta, August Shi, Rutvik Choudhary, Zhekun Zhang, Aryaman Jain, and Sasa Misailovic" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Detecting Flaky Tests in Probabilistic ..."</span></small></a>
    </span>

    <span id="issta20main-id159-p-shiaugust"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id159-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id159-p-shiaugust')" 
      >
        <a id="issta20main-id159-p-titleshiaugust" >
          <span style="font-size: 100%">
            Detecting Flaky Tests in Probabilistic and Machine Learning Applications
          </span>
        </a>
      </span>
      <br />
      Saikat Dutta, <a href="http://mir.cs.illinois.edu/~awshi2/" target="_blank">August Shi</a>, Rutvik Choudhary, Zhekun Zhang, Aryaman Jain, and Sasa Misailovic<br />
      <i><small>(University of Illinois at Urbana-Champaign, USA)</small></i><br />
      <span id="issta20main-id159-p-absshiaugust" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Probabilistic programming systems and machine learning frameworks like Pyro, PyMC3, TensorFlow, and PyTorch provide scalable and efficient primitives for inference and training. However, such operations are non-deterministic. Hence, it is challenging for developers to write tests for applications that depend on such frameworks, often resulting in flaky tests &#8211; tests which fail non-deterministically when run on the same version of code.  
<br/>

In this paper, we conduct the first extensive study of flaky tests in this domain. In particular, we study the projects that depend on four frameworks: Pyro, PyMC3, TensorFlow-Probability, and  
PyTorch. We identify 75 bug reports/commits that deal with flaky tests, and we categorize the common causes and fixes for them. This study provides developers with useful insights on dealing with flaky tests in this domain.  
<br/>

Motivated by our study, we develop a technique, FLASH, to systematically detect flaky tests due to assertions passing and failing in different runs on the same code. These assertions fail due to differences in the sequence of random numbers in different runs of the same test. FLASH exposes such failures, and our evaluation on 20 projects results in 11 previously-unknown flaky tests that we reported to developers.<br/>
        <br />
        <a href="issta20main-id159-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Shi, Jia  </td>
  <td>
    <span onclick="toggle('issta20main-id76-p-shijia')" title="Testing High Performance Numerical Simulation Programs: Experience, Lessons Learned, and Open Issues  --  Xiao He, Xingwei Wang, Jia Shi, and Yi Liu" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Testing High Performance Numerical ..."</span></small></a>
    </span>

    <span id="issta20main-id76-p-shijia"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id76-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id76-p-shijia')" 
      >
        <a id="issta20main-id76-p-titleshijia" >
          <span style="font-size: 100%">
            Testing High Performance Numerical Simulation Programs: Experience, Lessons Learned, and Open Issues
          </span>
        </a>
      </span>
      <br />
      Xiao He, Xingwei Wang, Jia Shi, and Yi Liu<br />
      <i><small>(University of Science and Technology Beijing, China; CNCERT/CC, China)</small></i><br />
      <span id="issta20main-id76-p-absshijia" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              High performance numerical simulation programs are widely used to simulate actual physical processes on high performance computers for the analysis of various physical and engineering problems. They are usually regarded as non-testable due to their high complexity. This paper reports our real experience and lessons learned from testing five simulation programs that will be used to design and analyze nuclear power plants. We applied five testing approaches and found 33 bugs. We found that property-based testing and metamorphic testing are two effective methods. Nevertheless, we suffered from the lack of domain knowledge, the high test costs, the shortage of test cases, severe oracle issues, and inadequate automation support. Consequently, the five programs are not exhaustively tested from the perspective of software testing, and many existing software testing techniques and tools are not fully applicable due to scalability and portability issues. We need more collaboration and communication with other communities to promote the research and application of software testing techniques.<br/>
        <br />
        <a href="issta20main-id76-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Shi, Qingkai  </td>
  <td>
    <span onclick="toggle('issta20main-id140-p-shiqingkai')" title="Functional Code Clone Detection with Syntax and Semantics Fusion Learning  --  Chunrong Fang, Zixi Liu, Yangyang Shi, Jeff Huang, and Qingkai Shi" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Functional Code Clone Detection ..."</span></small></a>
    </span>

    <span id="issta20main-id140-p-shiqingkai"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id140-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id140-p-shiqingkai')" 
      >
        <a id="issta20main-id140-p-titleshiqingkai" >
          <span style="font-size: 100%">
            Functional Code Clone Detection with Syntax and Semantics Fusion Learning
          </span>
        </a>
      </span>
      <br />
      Chunrong Fang, Zixi Liu, Yangyang Shi, Jeff Huang, and Qingkai Shi<br />
      <i><small>(Nanjing University, China; Texas A&#38;M University, USA; Hong Kong University of Science and Technology, China)</small></i><br />
      <span id="issta20main-id140-p-absshiqingkai" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Clone detection of source code is among the most fundamental software engineering techniques. Despite intensive research in the past decade, existing techniques are still unsatisfactory in detecting &quot;functional&quot; code clones. In particular, existing techniques cannot efficiently extract syntax and semantics information from source code. In this paper, we propose a novel joint code representation that applies fusion embedding techniques to learn hidden syntactic and semantic features of source codes. Besides, we introduce a new granularity for functional code clone detection. Our approach regards the connected methods with caller-callee relationships as a functionality and the method without any caller-callee relationship with other methods represents a single functionality. Then we train a supervised deep learning model to detect functional code clones. We conduct evaluations on a large dataset of C++ programs and the experimental results show that fusion learning can significantly outperform the state-of-the-art techniques in detecting functional code clones.<br/>
        <br />
        <a href="issta20main-id140-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_available_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Available</span></a>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_evaluated_reusable_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Reusable</span></a>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_evaluated_functional_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Functional</span></a>
    </span>
    <span onclick="toggle('issta20main-id149-p-shiqingkai')" title="DeepGini: Prioritizing Massive Tests to Enhance the Robustness of Deep Neural Networks  --  Yang Feng, Qingkai Shi, Xinyu Gao, Jun Wan, Chunrong Fang, and Zhenyu Chen" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "DeepGini: Prioritizing Massive ..."</span></small></a>
    </span>

    <span id="issta20main-id149-p-shiqingkai"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id149-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id149-p-shiqingkai')" 
      >
        <a id="issta20main-id149-p-titleshiqingkai" >
          <span style="font-size: 100%">
            DeepGini: Prioritizing Massive Tests to Enhance the Robustness of Deep Neural Networks
          </span>
        </a>
      </span>
      <br />
      Yang Feng, Qingkai Shi, Xinyu Gao, Jun Wan, Chunrong Fang, and <a href="http://software.nju.edu.cn/zychen/" target="_blank">Zhenyu Chen</a><br />
      <i><small>(Nanjing University, China; Hong Kong University of Science and Technology, China; Ant Financial Services, China)</small></i><br />
      <span id="issta20main-id149-p-absshiqingkai" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Deep neural networks (DNN) have been deployed in many software systems to assist in various classification tasks. In company with the fantastic effectiveness in classification, DNNs could also exhibit incorrect behaviors and result in accidents and losses. Therefore, testing techniques that can detect incorrect DNN behaviors and improve DNN quality are extremely necessary and critical. However, the testing oracle, which defines the correct output for a given input, is often not available in the automated testing. To obtain the oracle information, the testing tasks of DNN-based systems usually require expensive human efforts to label the testing data, which significantly slows down the process of quality assurance.  
<br/>

To mitigate this problem, we propose DeepGini, a test prioritization technique designed based on a statistical perspective of DNN. Such a statistical perspective allows us to reduce the problem of measuring misclassification probability to the problem of measuring set impurity, which allows us to quickly identify possibly-misclassified tests. To evaluate, we conduct an extensive empirical study on popular datasets and prevalent DNN models. The experimental results demonstrate that DeepGini outperforms existing coverage-based techniques in prioritizing tests regarding both effectiveness and efficiency. Meanwhile, we observe that the tests prioritized at the front by DeepGini are more effective in improving the DNN quality in comparison with the coverage-based techniques.<br/>
        <br />
        <a href="issta20main-id149-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
    <span onclick="toggle('issta20main-id21-p-shiqingkai')" title="Fast Bit-Vector Satisfiability  --  Peisen Yao, Qingkai Shi, Heqing Huang, and Charles Zhang" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Fast Bit-Vector Satisfiability ..."</span></small></a>
    </span>

    <span id="issta20main-id21-p-shiqingkai"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id21-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id21-p-shiqingkai')" 
      >
        <a id="issta20main-id21-p-titleshiqingkai" >
          <span style="font-size: 100%">
            Fast Bit-Vector Satisfiability
          </span>
        </a>
      </span>
      <br />
      Peisen Yao, Qingkai Shi, Heqing Huang, and Charles Zhang<br />
      <i><small>(Hong Kong University of Science and Technology, China)</small></i><br />
      <span id="issta20main-id21-p-absshiqingkai" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              SMT solving is often a major source of cost in a broad range of techniques such as symbolic program analysis.  
Thus, speeding up SMT solving is still an urgent requirement.  
A dominant approach, which is known as eager SMT solving, is to reduce a first-order formula to a pure Boolean formula, which is handed to an expensive SAT solver to determine the satisfiability.  
We observe that the SAT solver can utilize the knowledge in the first-order formula to boost its solving efficiency.  
Unfortunately, despite much progress, it is still not clear how to make use of the knowledge in an eager SMT solver.  
This paper addresses the problem by introducing a new and fast method,  
which utilizes the interval and data-dependence information learned from the first-order formulas.  
<br/>

We have implemented the approach as a tool called Trident and evaluated it on three symbolic analyzers (Angr, Qsym, and Pinpoint).  
The experimental results, based on seven million SMT solving instances generated for thirty real-world software systems, show that Trident significantly reduces the total solving time from 2.9X to 7.9X over three state-of-the-art SMT solvers (Z3, CVC4, and Boolector),  
without sacrificing the number of solved instances.  
We also demonstrate that Trident achieves  
end-to-end speedups for three program analysis clients by 1.9X, 1.6X, and 2.4X, respectively.<br/>
        <br />
        <a href="issta20main-id21-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
    <span onclick="toggle('issta20main-id145-p-shiqingkai')" title="Escaping Dependency Hell: Finding Build Dependency Errors with the Unified Dependency Graph  --  Gang Fan, Chengpeng Wang, Rongxin Wu, Xiao Xiao, Qingkai Shi, and Charles Zhang" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Escaping Dependency Hell: ..."</span></small></a>
    </span>

    <span id="issta20main-id145-p-shiqingkai"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id145-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id145-p-shiqingkai')" 
      >
        <a id="issta20main-id145-p-titleshiqingkai" >
          <span style="font-size: 100%">
            Escaping Dependency Hell: Finding Build Dependency Errors with the Unified Dependency Graph
          </span>
        </a>
      </span>
      <br />
      Gang Fan, Chengpeng Wang, Rongxin Wu, Xiao Xiao, Qingkai Shi, and Charles Zhang<br />
      <i><small>(Hong Kong University of Science and Technology, China; Xiamen University, China; Sourcebrella, China)</small></i><br />
      <span id="issta20main-id145-p-absshiqingkai" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Modern software projects rely on build systems and build scripts to assemble executable artifacts correctly and efficiently. However, developing build scripts is error-prone. Dependency-related errors in build scripts, mainly including missing dependencies and redundant dependencies, are common in various kinds of software projects. These errors lead to build failures, incorrect build results or poor performance in incremental or parallel builds. To detect such errors, various techniques are proposed and suffer from low efficiency and high false positive problems, due to the deficiency of the underlying dependency graphs. In this work, we design a new dependency graph, the unified dependency graph (UDG), which leverages both static and dynamic information to uniformly encode the declared and actual dependencies between build targets and files. The construction of UDG facilitates the efficient and precise detection of dependency errors via simple graph traversals. We implement the proposed approach as a tool, VeriBuild, and evaluate it on forty-two well-maintained open-source projects. The experimental results show that, without losing precision, VeriBuild incurs 58.2% less overhead than the state-of-the-art approach. By the time of writing, 398 detected dependency issues have been confirmed by the developers.<br/>
        <br />
        <a href="issta20main-id145-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
    <span onclick="toggle('issta20tool-id28-p-shiqingkai')" title="Test Recommendation System Based on Slicing Coverage Filtering  --  Ruixiang Qian, Yuan Zhao, Duo Men, Yang Feng, Qingkai Shi, Yong Huang, and Zhenyu Chen" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20-TOOL: "Test Recommendation System ..."</span></small></a>
    </span>

    <span id="issta20tool-id28-p-shiqingkai"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20tool-id28-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20tool-id28-p-shiqingkai')" 
      >
        <a id="issta20tool-id28-p-titleshiqingkai" >
          <span style="font-size: 100%">
            Test Recommendation System Based on Slicing Coverage Filtering
          </span>
        </a>
      </span>
      <br />
      Ruixiang Qian, Yuan Zhao, Duo Men, Yang Feng, Qingkai Shi, Yong Huang, and <a href="http://software.nju.edu.cn/zychen/" target="_blank">Zhenyu Chen</a><br />
      <i><small>(Nanjing University, China; Hong Kong University of Science and Technology, China; Mooctest, China)</small></i><br />
      <span id="issta20tool-id28-p-absshiqingkai" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Software testing plays a crucial role in software lifecycle. As a basic approach of software testing, unit testing is one of the necessary skills for software practitioners. Since testers are required to understand the inner code of the software under test(SUT) while writing a test case, testers usually need to learn how to detect the bug within SUT effectively. When novice programmers started to learn writing unit tests, they will generally watch a video lesson or reading unit tests written by others. These learning approaches are either time-consuming or too hard for a novice. To solve these problems, we developed a system, named TeSRS, to assist novice programmers to learn unit testing. TeSRS is a test recommendation system which can effectively assist test novice in learning unit testing. Utilizing program slice technique, TeSRS has gotten an enormous amount of test snippets from superior crowdsourcing test scripts. Depending on these test snippets, TeSRS provides novices a easier way for unit test learning. To sum up, TeSRS can help test novices (1) obtain high level design ideas of unit test case and (2) improve capabilities(e.g. branch coverage rate and mutation coverage rate) of their test scripts. TeSRS has built a scalable corpus composed of over 8000 test snippets from more than 25 test problems. Its stable performance shows effectiveness in unit test learning. <br/>Demo video can be found at <a>https://youtu.be/xvrLdvU8zFA</a><br/>
        <br />
        <a href="issta20tool-id28-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
      <a href="https://www.youtube.com/watch?v=xvrLdvU8zFA"><img width="15" src="../images/video.png" alt="" /><span style="font-size: 90%"> Video</span></a>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Shi, Yangyang  </td>
  <td>
    <span onclick="toggle('issta20main-id140-p-shiyangyang')" title="Functional Code Clone Detection with Syntax and Semantics Fusion Learning  --  Chunrong Fang, Zixi Liu, Yangyang Shi, Jeff Huang, and Qingkai Shi" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Functional Code Clone Detection ..."</span></small></a>
    </span>

    <span id="issta20main-id140-p-shiyangyang"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id140-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id140-p-shiyangyang')" 
      >
        <a id="issta20main-id140-p-titleshiyangyang" >
          <span style="font-size: 100%">
            Functional Code Clone Detection with Syntax and Semantics Fusion Learning
          </span>
        </a>
      </span>
      <br />
      Chunrong Fang, Zixi Liu, Yangyang Shi, Jeff Huang, and Qingkai Shi<br />
      <i><small>(Nanjing University, China; Texas A&#38;M University, USA; Hong Kong University of Science and Technology, China)</small></i><br />
      <span id="issta20main-id140-p-absshiyangyang" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Clone detection of source code is among the most fundamental software engineering techniques. Despite intensive research in the past decade, existing techniques are still unsatisfactory in detecting &quot;functional&quot; code clones. In particular, existing techniques cannot efficiently extract syntax and semantics information from source code. In this paper, we propose a novel joint code representation that applies fusion embedding techniques to learn hidden syntactic and semantic features of source codes. Besides, we introduce a new granularity for functional code clone detection. Our approach regards the connected methods with caller-callee relationships as a functionality and the method without any caller-callee relationship with other methods represents a single functionality. Then we train a supervised deep learning model to detect functional code clones. We conduct evaluations on a large dataset of C++ programs and the experimental results show that fusion learning can significantly outperform the state-of-the-art techniques in detecting functional code clones.<br/>
        <br />
        <a href="issta20main-id140-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_available_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Available</span></a>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_evaluated_reusable_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Reusable</span></a>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_evaluated_functional_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Functional</span></a>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Smaragdakis, Yannis  </td>
  <td>
    <span onclick="toggle('issta20main-id167-p-smaragdakisyannis')" title="Identifying Java Calls in Native Code via Binary Scanning  --  George Fourtounis, Leonidas Triantafyllou, and Yannis Smaragdakis" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Identifying Java Calls in ..."</span></small></a>
    </span>

    <span id="issta20main-id167-p-smaragdakisyannis"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id167-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id167-p-smaragdakisyannis')" 
      >
        <a id="issta20main-id167-p-titlesmaragdakisyannis" >
          <span style="font-size: 100%">
            Identifying Java Calls in Native Code via Binary Scanning
          </span>
        </a>
      </span>
      <br />
      George Fourtounis, Leonidas Triantafyllou, and Yannis Smaragdakis<br />
      <i><small>(University of Athens, Greece)</small></i><br />
      <span id="issta20main-id167-p-abssmaragdakisyannis" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Current Java static analyzers, operating either on the source or bytecode level, exhibit unsoundness for programs that contain native code. We show that the Java Native Interface (JNI) specification, which is used by Java programs to interoperate with Java code, is principled enough to permit static reasoning about the effects of native code on program execution when it comes to call-backs. Our approach consists of disassembling native binaries, recovering static symbol information that corresponds to Java method signatures, and producing a model for statically exercising these native call-backs with appropriate mock objects. The approach manages to recover virtually all Java calls in native code, for both Android and Java desktop applications&#8212;(a) achieving 100% native-to-application call-graph recall on large Android applications (Chrome, Instagram) and (b) capturing the full native call-back behavior of the XCorpus suite programs.<br/>
        <br />
        <a href="issta20main-id167-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
      <a href="https://zenodo.org/record/3833964"><img width="15" src="../images/tool.png" alt="" /><span style="font-size: 90%"> Info</span></a>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_available_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Available</span></a>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_evaluated_functional_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Functional</span></a>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Song, Fu  </td>
  <td>
    <span onclick="toggle('issta20main-id120-p-songfu')" title="Patch Based Vulnerability Matching for Binary Programs  --  Yifei Xu, Zhengzi Xu, Bihuan Chen, Fu Song, Yang Liu, and Ting Liu" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Patch Based Vulnerability ..."</span></small></a>
    </span>

    <span id="issta20main-id120-p-songfu"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id120-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id120-p-songfu')" 
      >
        <a id="issta20main-id120-p-titlesongfu" >
          <span style="font-size: 100%">
            Patch Based Vulnerability Matching for Binary Programs
          </span>
        </a>
      </span>
      <br />
      Yifei Xu, Zhengzi Xu, Bihuan Chen, Fu Song, <a href="http://www.ntu.edu.sg/home/yangliu/" target="_blank">Yang Liu</a>, and Ting Liu<br />
      <i><small>(Xi&#39;an Jiaotong University, China; Nanyang Technological University, Singapore; Fudan University, China; ShanghaiTech University, China; Zhejiang University, China)</small></i><br />
      <span id="issta20main-id120-p-abssongfu" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              The binary-level function matching has been widely used to detect whether there are 1-day vulnerabilities in released programs. However, the high false positive is a challenge for current function matching solutions, since the vulnerable function is highly similar to its corresponding patched version. In this paper, the Binary X-Ray (BinXray), a patch based vulnerability matching approach, is proposed to identify the specific 1-day vulnerabilities in target programs  
accurately and effectively. In the preparing step, a basic block mapping algorithm is designed to extract the signature of a patch, by comparing the given vulnerable and patched programs. The signature is represented as a set of basic block traces. In the detection step, the patching semantics is applied to reduce irrelevant basic block traces to speed up the signature searching. The trace similarity is also designed to identify whether a target program is patched. In experiments, 12 real software projects related to 479 CVEs are collected. BinXray achieves 93.31% accuracy and the analysis time cost is only 296.17ms per function, outperforming the state-of-the-art works.<br/>
        <br />
        <a href="issta20main-id120-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Song, Will  </td>
  <td>
    <span onclick="toggle('issta20tool-id13-p-songwill')" title="Echidna: Effective, Usable, and Fast Fuzzing for Smart Contracts  --  Gustavo Grieco, Will Song, Artur Cygan, Josselin Feist, and Alex Groce" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20-TOOL: "Echidna: Effective, Usable, ..."</span></small></a>
    </span>

    <span id="issta20tool-id13-p-songwill"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20tool-id13-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20tool-id13-p-songwill')" 
      >
        <a id="issta20tool-id13-p-titlesongwill" >
          <span style="font-size: 100%">
            Echidna: Effective, Usable, and Fast Fuzzing for Smart Contracts
          </span>
        </a>
      </span>
      <br />
      Gustavo Grieco, Will Song, Artur Cygan, Josselin Feist, and <a href="http://www.cs.cmu.edu/~agroce" target="_blank">Alex Groce</a><br />
      <i><small>(Trail of Bits, USA; Northern Arizona University, USA)</small></i><br />
      <span id="issta20tool-id13-p-abssongwill" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Ethereum smart contracts---autonomous programs that run on a blockchain---often control transactions of financial and intellectual property. Because of the critical role they play, smart contracts need complete, comprehensive, and effective test generation. This paper introduces an open-source smart contract fuzzer called Echidna that makes it easy to automatically generate tests to detect violations in assertions and custom properties. Echidna is easy to install and does not require a complex configuration or deployment of contracts to a local blockchain. It offers responsive feedback, captures many property violations, and its default settings are calibrated based on experimental data. To date, Echidna has been used in more than 10 large paid security audits, and feedback from those audits has driven the features and user experience of Echidna, both in terms of practical usability (e.g., smart contract frameworks like Truffle and Embark) and test generation strategies. Echidna aims to be good at finding real bugs in smart contracts, with minimal user effort and maximal speed.<br/>
        <br />
        <a href="issta20tool-id13-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
      <a href="https://github.com/crytic/echidna"><img width="15" src="../images/tool.png" alt="" /><span style="font-size: 90%"> Info</span></a>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Soremekun, Ezekiel O.  </td>
  <td>
    <span onclick="toggle('issta20main-id136-p-soremekunezekielo')" title="Abstracting Failure-Inducing Inputs  --  Rahul Gopinath, Alexander Kampmann, Nikolas Havrikov, Ezekiel O. Soremekun, and Andreas Zeller" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Abstracting Failure-Inducing ..."</span></small></a>
    </span>

    <span id="issta20main-id136-p-soremekunezekielo"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id136-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id136-p-soremekunezekielo')" 
      >
        <a id="issta20main-id136-p-titlesoremekunezekielo" >
          <span style="font-size: 100%">
            Abstracting Failure-Inducing Inputs
          </span>
        </a>
      </span>
      <br />
      Rahul Gopinath, Alexander Kampmann, Nikolas Havrikov, Ezekiel O. Soremekun, and Andreas Zeller<br />
      <i><small>(CISPA, Germany)</small></i><br />
      <span id="issta20main-id136-p-abssoremekunezekielo" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              A program fails. Under which circumstances does the failure occur? Starting with a single failure-inducing input (&quot;The input ((4)) fails&quot;) and an input grammar, the DDSET algorithm uses systematic tests to automatically generalize the input to an abstract failure-inducing input that contains both (concrete) terminal symbols and (abstract) nonterminal symbols from the grammar&#8212;for instance, &quot;((&#60;expr&#62;))&quot;, which represents any expression &#60;expr&#62; in double parentheses. Such an abstract failure-inducing input can be used (1) as a debugging diagnostic, characterizing the circumstances under which a failure occurs (&quot;The error occurs whenever an expression is enclosed in double parentheses&quot;); (2) as a producer of additional failure-inducing tests to help design and validate fixes and repair candidates (&quot;The inputs ((1)), ((3 * 4)), and many more also fail&quot;). In its evaluation on real-world bugs in JavaScript, Clojure, Lua, and UNIX command line utilities, DDSET&#8217;s abstract failure-inducing inputs provided to-the-point diagnostics, and precise producers for further failure inducing inputs.<br/>
        <br />
        <a href="issta20main-id136-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
      <a href="https://github.com/vrthra/ddset"><img width="15" src="../images/tool.png" alt="" /><span style="font-size: 90%"> Info</span></a>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_available_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Available</span></a>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_evaluated_reusable_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Reusable</span></a>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_evaluated_functional_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Functional</span></a>
          <span style="font-size: 80%; color: blue;"> 
            <img width="20" src="../images/award.svg" alt="" />
            ACM SIGSOFT Distinguished Paper Award</span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Stevens, Clay  </td>
  <td>
    <span onclick="toggle('issta20main-id143-p-stevensclay')" title="Scalable Analysis of Interaction Threats in IoT Systems  --  Mohannad Alhanahnah, Clay Stevens, and Hamid Bagheri" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Scalable Analysis of Interaction ..."</span></small></a>
    </span>

    <span id="issta20main-id143-p-stevensclay"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id143-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id143-p-stevensclay')" 
      >
        <a id="issta20main-id143-p-titlestevensclay" >
          <span style="font-size: 100%">
            Scalable Analysis of Interaction Threats in IoT Systems
          </span>
        </a>
      </span>
      <br />
      Mohannad Alhanahnah, Clay Stevens, and Hamid Bagheri<br />
      <i><small>(University of Nebraska-Lincoln, USA)</small></i><br />
      <span id="issta20main-id143-p-absstevensclay" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              The ubiquity of Internet of Things (IoT) and our growing reliance on IoT apps are leaving us more vulnerable to safety and security threats than ever before. Many of these threats are manifested at the interaction level, where undesired or malicious coordinations between apps and physical devices can lead to intricate safety and security issues. This paper presents IoTCOM, an approach to automatically discover such hidden and unsafe interaction threats in a compositional and scalable fashion. It is backed with auto-mated program analysis and formally rigorous violation detection engines. IoTCOM relies on program analysis to automatically infer the relevant app&#8217;s behavior. Leveraging a novel strategy to trim the extracted app&#8217;s behavior prior to translating them to analyzable formal specifications,IoTCOM mitigates the state explosion associated with formal analysis. Our experiments with numerous bundles of real-world IoT apps have corroborated IoTCOM&#8217;s ability to effectively detect a broad spectrum of interaction threats triggered through cyber and physical channels, many of which were previously unknown, and to significantly outperform the existing techniques in terms of scalability.<br/>
        <br />
        <a href="issta20main-id143-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
          <span style="font-size: 80%; color: blue;"> 
            <img width="20" src="../images/award.svg" alt="" />
            ACM SIGSOFT Distinguished Paper Award</span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Stifter, Thomas  </td>
  <td>
    <span onclick="toggle('issta20main-id83-p-stifterthomas')" title="Automated Repair of Feature Interaction Failures in Automated Driving Systems  --  Raja Ben Abdessalem, Annibale Panichella, Shiva Nejati, Lionel C. Briand, and Thomas Stifter" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Automated Repair of Feature ..."</span></small></a>
    </span>

    <span id="issta20main-id83-p-stifterthomas"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id83-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id83-p-stifterthomas')" 
      >
        <a id="issta20main-id83-p-titlestifterthomas" >
          <span style="font-size: 100%">
            Automated Repair of Feature Interaction Failures in Automated Driving Systems
          </span>
        </a>
      </span>
      <br />
      Raja Ben Abdessalem, Annibale Panichella, Shiva Nejati, Lionel C. Briand, and Thomas Stifter<br />
      <i><small>(University of Luxembourg, Luxembourg; Delft University of Technology, Netherlands; University of Ottawa, Canada; IEE, Luxembourg)</small></i><br />
      <span id="issta20main-id83-p-absstifterthomas" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              In the past years, several automated repair strategies have been proposed to fix bugs in individual software programs without any human intervention. There has been, however, little work on how automated repair techniques can resolve failures that arise at the system-level and are caused by undesired interactions among different system components or functions. Feature interaction failures are common in complex systems such as autonomous cars that are typically built as a composition of independent features (i.e., units of functionality). In this paper, we propose a repair technique to automatically resolve undesired feature interaction failures in automated driving systems (ADS) that lead to the violation of system safety requirements. Our repair strategy achieves its goal by (1) localizing faults spanning several lines of code, (2) simultaneously resolving multiple interaction failures caused by independent faults, (3) scaling repair strategies from the unit-level to the system-level, and (4) resolving failures based on their order of severity. We have evaluated our approach using two industrial ADS containing four features. Our results show that our repair strategy resolves the undesired interaction failures in these two systems in less than 16h and outperforms existing automated repair techniques.<br/>
        <br />
        <a href="issta20main-id83-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Strandberg, Per Erik  </td>
  <td>
    <span onclick="toggle('issta20main-id63-p-strandbergpererik')" title="Intermittently Failing Tests in the Embedded Systems Domain  --  Per Erik Strandberg, Thomas J. Ostrand, Elaine J. Weyuker, Wasif Afzal, and Daniel Sundmark" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Intermittently Failing Tests ..."</span></small></a>
    </span>

    <span id="issta20main-id63-p-strandbergpererik"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id63-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id63-p-strandbergpererik')" 
      >
        <a id="issta20main-id63-p-titlestrandbergpererik" >
          <span style="font-size: 100%">
            Intermittently Failing Tests in the Embedded Systems Domain
          </span>
        </a>
      </span>
      <br />
      Per Erik Strandberg, Thomas J. Ostrand, Elaine J. Weyuker, Wasif Afzal, and Daniel Sundmark<br />
      <i><small>(Westermo Network Technologies, Sweden; Mälardalen University, Sweden; University of Central Florida, USA)</small></i><br />
      <span id="issta20main-id63-p-absstrandbergpererik" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Software testing is sometimes plagued with intermittently failing tests and finding the root causes of such failing tests is often difficult. This problem has been widely studied at the unit testing level for open source software, but there has been far less investigation at the system test level, particularly the testing of industrial embedded systems. This paper describes our investigation of the root causes of intermittently failing tests in the embedded systems domain, with the goal of better understanding, explaining and categorizing the underlying faults. The subject of our investigation is a currently-running industrial embedded system, along with the system level testing that was performed. We devised and used a novel metric for classifying test cases as intermittent. From more than a half million test verdicts, we identified intermittently and consistently failing tests, and identified their root causes using multiple sources. We found that about 1-3% of all test cases were intermittently failing. From analysis of the case study results and related work, we identified nine factors associated with test case intermittence. We found that a fix for a consistently failing test typically removed a larger number of failures detected by other tests than a fix for an intermittent test. We also found that more effort was usually needed to identify fixes for intermittent tests than for consistent tests. An overlap between root causes leading to intermittent and consistent tests was identified. Many root causes of intermittence are the same in industrial embedded systems and open source software. However, when comparing unit testing to system level testing, especially for embedded systems, we observed that the test environment itself is often the cause of intermittence.<br/>
        <br />
        <a href="issta20main-id63-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Sullivan, Allison K.  </td>
  <td>
    <span onclick="toggle('issta20tool-id18-p-sullivanallisonk')" title="ProFL: A Fault Localization Framework for Prolog  --  George Thompson and Allison K. Sullivan" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20-TOOL: "ProFL: A Fault Localization ..."</span></small></a>
    </span>

    <span id="issta20tool-id18-p-sullivanallisonk"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20tool-id18-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20tool-id18-p-sullivanallisonk')" 
      >
        <a id="issta20tool-id18-p-titlesullivanallisonk" >
          <span style="font-size: 100%">
            ProFL: A Fault Localization Framework for Prolog
          </span>
        </a>
      </span>
      <br />
      George Thompson and Allison K. Sullivan<br />
      <i><small>(North Carolina A&#38;T State University, USA; University of Texas at Arlington, USA)</small></i><br />
      <span id="issta20tool-id18-p-abssullivanallisonk" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Prolog is a declarative, first-order logic that has been used in a variety of domains to implement heavily rules-based systems. However, it is challenging to write a Prolog program correctly. Fortunately, the SWI-Prolog environment supports a unit testing framework, plunit, which enables developers to systematically check for correctness. However, knowing a program is faulty is just the first step. The developer then needs to fix the program which means the developer needs to determine what part of the program is faulty. ProFL is a fault localization tool that adapts imperative-based fault localization techniques to Prolog&#8217;s declarative environment. ProFL takes as input a faulty Prolog program and a plunit test suite. Then, ProFL performs fault localization and returns a list of suspicious program clauses to the user. Our toolset encompasses two different techniques: ProFL<sub><i>s</i></sub>, a spectrum-based technique, and ProFL<sub><i>m</i></sub>, a mutation-based technique. This paper describes our Python implementation of ProFL, which is a command-line tool, released as an open-source project on GitHub (https://github.com/geoorge1d127/ProFL). Our experimental results show ProFL is accurate at localizing faults in our benchmark programs.<br/>
        <br />
        <a href="issta20tool-id18-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Sun, Jun  </td>
  <td>
    <span onclick="toggle('issta20main-id40-p-sunjun')" title="Active Fuzzing for Testing and Securing Cyber-Physical Systems  --  Yuqi Chen, Bohan Xuan, Christopher M. Poskitt, Jun Sun, and Fan Zhang" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Active Fuzzing for Testing ..."</span></small></a>
    </span>

    <span id="issta20main-id40-p-sunjun"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id40-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id40-p-sunjun')" 
      >
        <a id="issta20main-id40-p-titlesunjun" >
          <span style="font-size: 100%">
            Active Fuzzing for Testing and Securing Cyber-Physical Systems
          </span>
        </a>
      </span>
      <br />
      Yuqi Chen, Bohan Xuan, Christopher M. Poskitt, Jun Sun, and Fan Zhang<br />
      <i><small>(Singapore Management University, Singapore; Zhejiang University, China; Zhejiang Lab, China; Alibaba-Zhejiang University Joint Institute of Frontier Technologies, China)</small></i><br />
      <span id="issta20main-id40-p-abssunjun" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Cyber-physical systems&#160;(CPSs) in critical infrastructure face a pervasive threat from attackers, motivating research into a variety of countermeasures for securing them. Assessing the effectiveness of these countermeasures is challenging, however, as realistic benchmarks of attacks are difficult to manually construct, blindly testing is ineffective due to the enormous search spaces and resource requirements, and intelligent fuzzing approaches require impractical amounts of data and network access. In this work, we propose <em>active fuzzing</em>, an automatic approach for finding test suites of packet-level CPS network attacks, targeting scenarios in which attackers can observe sensors and manipulate packets, but have no existing knowledge about the payload encodings. Our approach learns regression models for predicting sensor values that will result from sampled network packets, and uses these predictions to guide a search for payload manipulations (i.e.&#160;bit flips) most likely to drive the CPS into an unsafe state. Key to our solution is the use of <em>online active learning</em>, which iteratively updates the models by sampling payloads that are estimated to maximally improve them. We evaluate the efficacy of active fuzzing by implementing it for a water purification plant testbed, finding it can automatically discover a test suite of flow, pressure, and over/underflow attacks, all with substantially less time, data, and network access than the most comparable approach. Finally, we demonstrate that our prediction models can also be utilised as countermeasures themselves, implementing them as anomaly detectors and early warning systems.<br/>
        <br />
        <a href="issta20main-id40-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
    <span onclick="toggle('issta20main-id134-p-sunjun')" title="Recovering Fitness Gradients for Interprocedural Boolean Flags in Search-Based Testing  --  Yun Lin, Jun Sun, Gordon Fraser, Ziheng Xiu, Ting Liu, and Jin Song Dong" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Recovering Fitness Gradients ..."</span></small></a>
    </span>

    <span id="issta20main-id134-p-sunjun"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id134-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id134-p-sunjun')" 
      >
        <a id="issta20main-id134-p-titlesunjun" >
          <span style="font-size: 100%">
            Recovering Fitness Gradients for Interprocedural Boolean Flags in Search-Based Testing
          </span>
        </a>
      </span>
      <br />
      <a href="http://linyun.info/" target="_blank">Yun Lin</a>, Jun Sun, Gordon Fraser, Ziheng Xiu, Ting Liu, and Jin Song Dong<br />
      <i><small>(National University of Singapore, Singapore; Singapore Management University, Singapore; University of Passau, Germany; Xi&#39;an Jiaotong University, China)</small></i><br />
      <span id="issta20main-id134-p-abssunjun" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              In Search-based Software Testing (SBST), test generation is guided by fitness functions that estimate how close a test case is to reach an uncovered test goal (e.g., branch). A popular fitness function estimates how close conditional statements are to evaluating to true or false, i.e., the branch distance. However, when conditions read Boolean variables (e.g., if(x &amp;&amp; y)), the branch distance provides no gradient for the search, since a Boolean can either be true or false. This flag problem can be addressed by transforming individual procedures such that Boolean flags are replaced with numeric comparisons that provide better guidance for the search. Unfortunately, defining a semantics-preserving transformation that is applicable in an interprocedural case, where Boolean flags are passed around as parameters and return values, is a daunting task. Thus, it is not yet supported by modern test generators. <br/>This work is based on the insight that fitness gradients can be recovered by using runtime information: Given an uncovered interprocedural flag branch, our approach (1) calculates context-sensitive branch distance for all control flows potentially returning the required flag in the called method, and (2) recursively aggregates these distances into a continuous value. We implemented our approach on top of the EvoSuite framework for Java, and empirically compared it with state-of-the-art testability transformations on non-trivial methods suffering from interprocedural flag problems, sampled from open source Java projects. Our experiment demonstrates that our approach achieves higher coverage on the subject methods with statistical significance and acceptable runtime overheads.<br/>
        <br />
        <a href="issta20main-id134-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Sundmark, Daniel  </td>
  <td>
    <span onclick="toggle('issta20main-id63-p-sundmarkdaniel')" title="Intermittently Failing Tests in the Embedded Systems Domain  --  Per Erik Strandberg, Thomas J. Ostrand, Elaine J. Weyuker, Wasif Afzal, and Daniel Sundmark" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Intermittently Failing Tests ..."</span></small></a>
    </span>

    <span id="issta20main-id63-p-sundmarkdaniel"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id63-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id63-p-sundmarkdaniel')" 
      >
        <a id="issta20main-id63-p-titlesundmarkdaniel" >
          <span style="font-size: 100%">
            Intermittently Failing Tests in the Embedded Systems Domain
          </span>
        </a>
      </span>
      <br />
      Per Erik Strandberg, Thomas J. Ostrand, Elaine J. Weyuker, Wasif Afzal, and Daniel Sundmark<br />
      <i><small>(Westermo Network Technologies, Sweden; Mälardalen University, Sweden; University of Central Florida, USA)</small></i><br />
      <span id="issta20main-id63-p-abssundmarkdaniel" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Software testing is sometimes plagued with intermittently failing tests and finding the root causes of such failing tests is often difficult. This problem has been widely studied at the unit testing level for open source software, but there has been far less investigation at the system test level, particularly the testing of industrial embedded systems. This paper describes our investigation of the root causes of intermittently failing tests in the embedded systems domain, with the goal of better understanding, explaining and categorizing the underlying faults. The subject of our investigation is a currently-running industrial embedded system, along with the system level testing that was performed. We devised and used a novel metric for classifying test cases as intermittent. From more than a half million test verdicts, we identified intermittently and consistently failing tests, and identified their root causes using multiple sources. We found that about 1-3% of all test cases were intermittently failing. From analysis of the case study results and related work, we identified nine factors associated with test case intermittence. We found that a fix for a consistently failing test typically removed a larger number of failures detected by other tests than a fix for an intermittent test. We also found that more effort was usually needed to identify fixes for intermittent tests than for consistent tests. An overlap between root causes leading to intermittent and consistent tests was identified. Many root causes of intermittence are the same in industrial embedded systems and open source software. However, when comparing unit testing to system level testing, especially for embedded systems, we observed that the test environment itself is often the cause of intermittence.<br/>
        <br />
        <a href="issta20main-id63-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;"><a id="T"> </a>Tan, Lin
  </td>
  <td>
    <span onclick="toggle('issta20main-id96-p-tanlin')" title="CoCoNuT: Combining Context-Aware Neural Translation Models using Ensemble for Program Repair  --  Thibaud Lutellier, Hung Viet Pham, Lawrence Pang, Yitong Li, Moshi Wei, and Lin Tan" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "CoCoNuT: Combining Context-Aware ..."</span></small></a>
    </span>

    <span id="issta20main-id96-p-tanlin"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id96-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id96-p-tanlin')" 
      >
        <a id="issta20main-id96-p-titletanlin" >
          <span style="font-size: 100%">
            CoCoNuT: Combining Context-Aware Neural Translation Models using Ensemble for Program Repair
          </span>
        </a>
      </span>
      <br />
      Thibaud Lutellier, Hung Viet Pham, Lawrence Pang, Yitong Li, Moshi Wei, and Lin Tan<br />
      <i><small>(University of Waterloo, Canada; Purdue University, USA)</small></i><br />
      <span id="issta20main-id96-p-abstanlin" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Automated generate-and-validate (GV) program repair techniques (APR) typically rely on hard-coded rules, thus only fixing bugs following specific fix patterns. These rules require a significant amount of manual effort to discover and it is hard to adapt these rules to different programming languages. <br/>To address these challenges, we propose a new G&amp;V technique&#8212;CoCoNuT, which uses ensemble learning on the combination of convolutional neural networks (CNNs) and a new context-aware neural machine translation (NMT) architecture to automatically fix bugs in multiple programming languages. To better represent the context of a bug, we introduce a new context-aware NMT architecture that represents the buggy source code and its surrounding context separately. CoCoNuT uses CNNs instead of recurrent neural networks (RNNs), since CNN layers can be stacked to extract hierarchical features and better model source code at different granularity levels (e.g., statements and functions). In addition, CoCoNuT takes advantage of the randomness in hyperparameter tuning to build multiple models that fix different bugs and combines these models using ensemble learning to fix more bugs. <br/>Our evaluation on six popular benchmarks for four programming languages (Java, C, Python, and JavaScript) shows that CoCoNuT correctly fixes (i.e., the first generated patch is semantically equivalent to the developer&#8217;s patch) 509 bugs, including 309 bugs that are fixed by none of the 27 techniques with which we compare.<br/>
        <br />
        <a href="issta20main-id96-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Tener, Greg  </td>
  <td>
    <span onclick="toggle('issta20main-id27-p-tenergreg')" title="Scalable Build Service System with Smart Scheduling Service  --  Kaiyuan Wang, Greg Tener, Vijay Gullapalli, Xin Huang, Ahmed Gad, and Daniel Rall" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Scalable Build Service System ..."</span></small></a>
    </span>

    <span id="issta20main-id27-p-tenergreg"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id27-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id27-p-tenergreg')" 
      >
        <a id="issta20main-id27-p-titletenergreg" >
          <span style="font-size: 100%">
            Scalable Build Service System with Smart Scheduling Service
          </span>
        </a>
      </span>
      <br />
      Kaiyuan Wang, Greg Tener, Vijay Gullapalli, Xin Huang, Ahmed Gad, and Daniel Rall<br />
      <i><small>(Google, USA)</small></i><br />
      <span id="issta20main-id27-p-abstenergreg" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Build automation is critical for developers to check if their code compiles, passes all tests and is safe to deploy to the server. Many companies adopt Continuous Integration (CI) services to make sure that the code changes from multiple developers can be safely merged at the head of the project. Internally, CI triggers builds to make sure that the new code change compiles and passes the tests. For any large company which has a monolithic code repository and thousands of developers, it is hard to make sure that all code changes are safe to submit in a timely manner. The reason is that each code change may involve multiple builds, and the company needs to run millions of builds every day to guarantee developers&#8217; productivity.  
<br/>

Google is one of those large companies that need a scalable build service to support developers&#8217; work. More than 100,000 code changes are submitted to our repository on average each day, including changes from either human users or automated tools. More than 15 million builds are executed on average each day. In this paper, we first describe an overview of our scalable build service architecture. Then, we discuss more details about how we make build scheduling decisions. Finally, we discuss some experience in the scalability of the build service system and the performance of the build scheduling service.<br/>
        <br />
        <a href="issta20main-id27-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Thompson, George  </td>
  <td>
    <span onclick="toggle('issta20tool-id18-p-thompsongeorge')" title="ProFL: A Fault Localization Framework for Prolog  --  George Thompson and Allison K. Sullivan" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20-TOOL: "ProFL: A Fault Localization ..."</span></small></a>
    </span>

    <span id="issta20tool-id18-p-thompsongeorge"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20tool-id18-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20tool-id18-p-thompsongeorge')" 
      >
        <a id="issta20tool-id18-p-titlethompsongeorge" >
          <span style="font-size: 100%">
            ProFL: A Fault Localization Framework for Prolog
          </span>
        </a>
      </span>
      <br />
      George Thompson and Allison K. Sullivan<br />
      <i><small>(North Carolina A&#38;T State University, USA; University of Texas at Arlington, USA)</small></i><br />
      <span id="issta20tool-id18-p-absthompsongeorge" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Prolog is a declarative, first-order logic that has been used in a variety of domains to implement heavily rules-based systems. However, it is challenging to write a Prolog program correctly. Fortunately, the SWI-Prolog environment supports a unit testing framework, plunit, which enables developers to systematically check for correctness. However, knowing a program is faulty is just the first step. The developer then needs to fix the program which means the developer needs to determine what part of the program is faulty. ProFL is a fault localization tool that adapts imperative-based fault localization techniques to Prolog&#8217;s declarative environment. ProFL takes as input a faulty Prolog program and a plunit test suite. Then, ProFL performs fault localization and returns a list of suspicious program clauses to the user. Our toolset encompasses two different techniques: ProFL<sub><i>s</i></sub>, a spectrum-based technique, and ProFL<sub><i>m</i></sub>, a mutation-based technique. This paper describes our Python implementation of ProFL, which is a command-line tool, released as an open-source project on GitHub (https://github.com/geoorge1d127/ProFL). Our experimental results show ProFL is accurate at localizing faults in our benchmark programs.<br/>
        <br />
        <a href="issta20tool-id18-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Tizpaz-Niari, Saeid  </td>
  <td>
    <span onclick="toggle('issta20main-id50-p-tizpazniarisaeid')" title="Detecting and Understanding Real-World Differential Performance Bugs in Machine Learning Libraries  --  Saeid Tizpaz-Niari, Pavol Černý, and Ashutosh Trivedi" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Detecting and Understanding ..."</span></small></a>
    </span>

    <span id="issta20main-id50-p-tizpazniarisaeid"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id50-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id50-p-tizpazniarisaeid')" 
      >
        <a id="issta20main-id50-p-titletizpazniarisaeid" >
          <span style="font-size: 100%">
            Detecting and Understanding Real-World Differential Performance Bugs in Machine Learning Libraries
          </span>
        </a>
      </span>
      <br />
      Saeid Tizpaz-Niari, Pavol Černý, and Ashutosh Trivedi<br />
      <i><small>(University of Colorado Boulder, USA; TU Vienna, Austria)</small></i><br />
      <span id="issta20main-id50-p-abstizpazniarisaeid" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Programming errors that degrade the performance of systems are widespread, yet there is very little tool support for finding and diagnosing these bugs. We present a method and a tool based on differential performance analysis---we find inputs for which the performance varies widely, despite having the same size. To ensure that the differences in the performance are robust (i.e. hold also for large inputs), we compare the performance of not only single inputs, but of classes of inputs, where each class has similar inputs parameterized by their size. Thus, each class is represented by a performance function from the input size to performance. Importantly, we also provide an explanation for why the performance differs in a form that can be readily used to fix a performance bug.  
The two main phases in our method are discovery with fuzzing and explanation with decision tree classifiers, each of which is supported by clustering. First, we propose an evolutionary fuzzing algorithm to generate inputs that characterize different performance functions. For this fuzzing task, the unique challenge is that we not only need the input class with the worst performance, but rather a set of classes exhibiting differential performance. We use clustering to merge similar input classes which significantly improves the efficiency of our fuzzer. Second, we explain the differential performance in terms of program inputs and internals (e.g., methods and conditions). We adapt discriminant learning approaches with clustering and decision trees to localize suspicious code regions.  
We applied our techniques on a set of micro-benchmarks and real-world machine learning libraries. On a set of micro-benchmarks, we show that our approach outperforms state-of-the-art fuzzers in finding inputs to characterize differential performance. On a set of case-studies, we discover and explain multiple performance bugs in popular machine learning frameworks, for instance in implementations of logistic regression in scikit-learn. Four of these bugs, reported first in this paper, have since been fixed by the developers.<br/>
        <br />
        <a href="issta20main-id50-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_available_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Available</span></a>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_evaluated_functional_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Functional</span></a>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Trabish, David  </td>
  <td>
    <span onclick="toggle('issta20main-id53-p-trabishdavid')" title="Relocatable Addressing Model for Symbolic Execution  --  David Trabish and Noam Rinetzky" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Relocatable Addressing Model ..."</span></small></a>
    </span>

    <span id="issta20main-id53-p-trabishdavid"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id53-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id53-p-trabishdavid')" 
      >
        <a id="issta20main-id53-p-titletrabishdavid" >
          <span style="font-size: 100%">
            Relocatable Addressing Model for Symbolic Execution
          </span>
        </a>
      </span>
      <br />
      David Trabish and Noam Rinetzky<br />
      <i><small>(Tel Aviv University, Israel)</small></i><br />
      <span id="issta20main-id53-p-abstrabishdavid" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Symbolic execution (SE) is a widely used program analysis technique.  
Existing SE engines model the memory space by associating  
memory objects with concrete addresses, where the representation  
of each allocated object is determined during its allocation. We  
present a novel addressing model where the underlying representation of an allocated object can be dynamically modified even after  
its allocation, by using symbolic addresses rather than concrete  
ones. We demonstrate the benefits of our model in two application scenarios: dynamic inter- and intra-object partitioning. In the  
former, we show how the recently proposed segmented memory  
model can be improved by dynamically merging several object  
representations into a single one, rather than doing that a-priori  
using static pointer analysis. In the latter, we show how the cost  
of solving array theory constraints can be reduced by splitting the  
representations of large objects into multiple smaller ones. Our preliminary results show that our approach can significantly improve  
the overall effectiveness of the symbolic exploration.<br/>
        <br />
        <a href="issta20main-id53-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Triantafyllou, Leonidas  </td>
  <td>
    <span onclick="toggle('issta20main-id167-p-triantafyllouleonidas')" title="Identifying Java Calls in Native Code via Binary Scanning  --  George Fourtounis, Leonidas Triantafyllou, and Yannis Smaragdakis" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Identifying Java Calls in ..."</span></small></a>
    </span>

    <span id="issta20main-id167-p-triantafyllouleonidas"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id167-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id167-p-triantafyllouleonidas')" 
      >
        <a id="issta20main-id167-p-titletriantafyllouleonidas" >
          <span style="font-size: 100%">
            Identifying Java Calls in Native Code via Binary Scanning
          </span>
        </a>
      </span>
      <br />
      George Fourtounis, Leonidas Triantafyllou, and Yannis Smaragdakis<br />
      <i><small>(University of Athens, Greece)</small></i><br />
      <span id="issta20main-id167-p-abstriantafyllouleonidas" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Current Java static analyzers, operating either on the source or bytecode level, exhibit unsoundness for programs that contain native code. We show that the Java Native Interface (JNI) specification, which is used by Java programs to interoperate with Java code, is principled enough to permit static reasoning about the effects of native code on program execution when it comes to call-backs. Our approach consists of disassembling native binaries, recovering static symbol information that corresponds to Java method signatures, and producing a model for statically exercising these native call-backs with appropriate mock objects. The approach manages to recover virtually all Java calls in native code, for both Android and Java desktop applications&#8212;(a) achieving 100% native-to-application call-graph recall on large Android applications (Chrome, Instagram) and (b) capturing the full native call-back behavior of the XCorpus suite programs.<br/>
        <br />
        <a href="issta20main-id167-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
      <a href="https://zenodo.org/record/3833964"><img width="15" src="../images/tool.png" alt="" /><span style="font-size: 90%"> Info</span></a>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_available_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Available</span></a>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_evaluated_functional_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Functional</span></a>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Trivedi, Ashutosh  </td>
  <td>
    <span onclick="toggle('issta20main-id50-p-trivediashutosh')" title="Detecting and Understanding Real-World Differential Performance Bugs in Machine Learning Libraries  --  Saeid Tizpaz-Niari, Pavol Černý, and Ashutosh Trivedi" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Detecting and Understanding ..."</span></small></a>
    </span>

    <span id="issta20main-id50-p-trivediashutosh"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id50-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id50-p-trivediashutosh')" 
      >
        <a id="issta20main-id50-p-titletrivediashutosh" >
          <span style="font-size: 100%">
            Detecting and Understanding Real-World Differential Performance Bugs in Machine Learning Libraries
          </span>
        </a>
      </span>
      <br />
      Saeid Tizpaz-Niari, Pavol Černý, and Ashutosh Trivedi<br />
      <i><small>(University of Colorado Boulder, USA; TU Vienna, Austria)</small></i><br />
      <span id="issta20main-id50-p-abstrivediashutosh" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Programming errors that degrade the performance of systems are widespread, yet there is very little tool support for finding and diagnosing these bugs. We present a method and a tool based on differential performance analysis---we find inputs for which the performance varies widely, despite having the same size. To ensure that the differences in the performance are robust (i.e. hold also for large inputs), we compare the performance of not only single inputs, but of classes of inputs, where each class has similar inputs parameterized by their size. Thus, each class is represented by a performance function from the input size to performance. Importantly, we also provide an explanation for why the performance differs in a form that can be readily used to fix a performance bug.  
The two main phases in our method are discovery with fuzzing and explanation with decision tree classifiers, each of which is supported by clustering. First, we propose an evolutionary fuzzing algorithm to generate inputs that characterize different performance functions. For this fuzzing task, the unique challenge is that we not only need the input class with the worst performance, but rather a set of classes exhibiting differential performance. We use clustering to merge similar input classes which significantly improves the efficiency of our fuzzer. Second, we explain the differential performance in terms of program inputs and internals (e.g., methods and conditions). We adapt discriminant learning approaches with clustering and decision trees to localize suspicious code regions.  
We applied our techniques on a set of micro-benchmarks and real-world machine learning libraries. On a set of micro-benchmarks, we show that our approach outperforms state-of-the-art fuzzers in finding inputs to characterize differential performance. On a set of case-studies, we discover and explain multiple performance bugs in popular machine learning frameworks, for instance in implementations of logistic regression in scikit-learn. Four of these bugs, reported first in this paper, have since been fixed by the developers.<br/>
        <br />
        <a href="issta20main-id50-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_available_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Available</span></a>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_evaluated_functional_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Functional</span></a>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;"><a id="V"> </a>Vanover, Jackson
  </td>
  <td>
    <span onclick="toggle('issta20main-id128-p-vanoverjackson')" title="Discovering Discrepancies in Numerical Libraries  --  Jackson Vanover, Xuan Deng, and Cindy Rubio-González" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Discovering Discrepancies ..."</span></small></a>
    </span>

    <span id="issta20main-id128-p-vanoverjackson"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id128-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id128-p-vanoverjackson')" 
      >
        <a id="issta20main-id128-p-titlevanoverjackson" >
          <span style="font-size: 100%">
            Discovering Discrepancies in Numerical Libraries
          </span>
        </a>
      </span>
      <br />
      Jackson Vanover, Xuan Deng, and Cindy Rubio-González<br />
      <i><small>(University of California at Davis, USA)</small></i><br />
      <span id="issta20main-id128-p-absvanoverjackson" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Numerical libraries constitute the building blocks for software  
applications that perform numerical calculations. Thus, it is  
paramount that such libraries provide accurate and consistent results.  
To that end, this paper addresses the problem of finding discrepancies  
between synonymous functions in different numerical libraries as a  
means of identifying incorrect behavior. Our approach automatically  
finds such synonymous functions, synthesizes testing drivers, and  
executes differential tests to discover meaningful discrepancies  
across numerical libraries. We implement our approach in a tool named  
FPDiff, and provide an evaluation on four popular numerical libraries:  
GNU Scientific Library (GSL), SciPy, mpmath, and jmat. FPDiff finds  
a total of 126 equivalence classes with a 95.8% precision  
and 79% recall, and discovers 655 instances in which  
an input produces a set of disagreeing outputs between function  
synonyms, 150 of which we found to represent  
125 unique bugs. We have reported all bugs to library  
maintainers; so far, 30 bugs have been fixed, 9  
have been found to be previously known, and 25 more  
have been acknowledged by developers.<br/>
        <br />
        <a href="issta20main-id128-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_available_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Available</span></a>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_evaluated_reusable_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Reusable</span></a>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_evaluated_functional_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Functional</span></a>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;"><a id="W"> </a>Wan, Jun
  </td>
  <td>
    <span onclick="toggle('issta20main-id149-p-wanjun')" title="DeepGini: Prioritizing Massive Tests to Enhance the Robustness of Deep Neural Networks  --  Yang Feng, Qingkai Shi, Xinyu Gao, Jun Wan, Chunrong Fang, and Zhenyu Chen" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "DeepGini: Prioritizing Massive ..."</span></small></a>
    </span>

    <span id="issta20main-id149-p-wanjun"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id149-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id149-p-wanjun')" 
      >
        <a id="issta20main-id149-p-titlewanjun" >
          <span style="font-size: 100%">
            DeepGini: Prioritizing Massive Tests to Enhance the Robustness of Deep Neural Networks
          </span>
        </a>
      </span>
      <br />
      Yang Feng, Qingkai Shi, Xinyu Gao, Jun Wan, Chunrong Fang, and <a href="http://software.nju.edu.cn/zychen/" target="_blank">Zhenyu Chen</a><br />
      <i><small>(Nanjing University, China; Hong Kong University of Science and Technology, China; Ant Financial Services, China)</small></i><br />
      <span id="issta20main-id149-p-abswanjun" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Deep neural networks (DNN) have been deployed in many software systems to assist in various classification tasks. In company with the fantastic effectiveness in classification, DNNs could also exhibit incorrect behaviors and result in accidents and losses. Therefore, testing techniques that can detect incorrect DNN behaviors and improve DNN quality are extremely necessary and critical. However, the testing oracle, which defines the correct output for a given input, is often not available in the automated testing. To obtain the oracle information, the testing tasks of DNN-based systems usually require expensive human efforts to label the testing data, which significantly slows down the process of quality assurance.  
<br/>

To mitigate this problem, we propose DeepGini, a test prioritization technique designed based on a statistical perspective of DNN. Such a statistical perspective allows us to reduce the problem of measuring misclassification probability to the problem of measuring set impurity, which allows us to quickly identify possibly-misclassified tests. To evaluate, we conduct an extensive empirical study on popular datasets and prevalent DNN models. The experimental results demonstrate that DeepGini outperforms existing coverage-based techniques in prioritizing tests regarding both effectiveness and efficiency. Meanwhile, we observe that the tests prioritized at the front by DeepGini are more effective in improving the DNN quality in comparison with the coverage-based techniques.<br/>
        <br />
        <a href="issta20main-id149-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Wang, Chengpeng  </td>
  <td>
    <span onclick="toggle('issta20main-id145-p-wangchengpeng')" title="Escaping Dependency Hell: Finding Build Dependency Errors with the Unified Dependency Graph  --  Gang Fan, Chengpeng Wang, Rongxin Wu, Xiao Xiao, Qingkai Shi, and Charles Zhang" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Escaping Dependency Hell: ..."</span></small></a>
    </span>

    <span id="issta20main-id145-p-wangchengpeng"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id145-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id145-p-wangchengpeng')" 
      >
        <a id="issta20main-id145-p-titlewangchengpeng" >
          <span style="font-size: 100%">
            Escaping Dependency Hell: Finding Build Dependency Errors with the Unified Dependency Graph
          </span>
        </a>
      </span>
      <br />
      Gang Fan, Chengpeng Wang, Rongxin Wu, Xiao Xiao, Qingkai Shi, and Charles Zhang<br />
      <i><small>(Hong Kong University of Science and Technology, China; Xiamen University, China; Sourcebrella, China)</small></i><br />
      <span id="issta20main-id145-p-abswangchengpeng" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Modern software projects rely on build systems and build scripts to assemble executable artifacts correctly and efficiently. However, developing build scripts is error-prone. Dependency-related errors in build scripts, mainly including missing dependencies and redundant dependencies, are common in various kinds of software projects. These errors lead to build failures, incorrect build results or poor performance in incremental or parallel builds. To detect such errors, various techniques are proposed and suffer from low efficiency and high false positive problems, due to the deficiency of the underlying dependency graphs. In this work, we design a new dependency graph, the unified dependency graph (UDG), which leverages both static and dynamic information to uniformly encode the declared and actual dependencies between build targets and files. The construction of UDG facilitates the efficient and precise detection of dependency errors via simple graph traversals. We implement the proposed approach as a tool, VeriBuild, and evaluate it on forty-two well-maintained open-source projects. The experimental results show that, without losing precision, VeriBuild incurs 58.2% less overhead than the state-of-the-art approach. By the time of writing, 398 detected dependency issues have been confirmed by the developers.<br/>
        <br />
        <a href="issta20main-id145-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Wang, Dong  </td>
  <td>
    <span onclick="toggle('issta20main-id139-p-wangdong')" title="Detecting Cache-Related Bugs in Spark Applications  --  Hui Li, Dong Wang, Tianze Huang, Yu Gao, Wensheng Dou, Lijie Xu, Wei Wang, Jun Wei, and Hua Zhong" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Detecting Cache-Related Bugs ..."</span></small></a>
    </span>

    <span id="issta20main-id139-p-wangdong"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id139-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id139-p-wangdong')" 
      >
        <a id="issta20main-id139-p-titlewangdong" >
          <span style="font-size: 100%">
            Detecting Cache-Related Bugs in Spark Applications
          </span>
        </a>
      </span>
      <br />
      Hui Li, Dong Wang, Tianze Huang, Yu Gao, <a href="http://www.tcse.cn/~wsdou/" target="_blank">Wensheng Dou</a>, Lijie Xu, Wei Wang, Jun Wei, and Hua Zhong<br />
      <i><small>(Institute of Software at Chinese Academy of Sciences, China; University of Chinese Academy of Sciences, China; Beijing University of Posts and Telecommunications, China)</small></i><br />
      <span id="issta20main-id139-p-abswangdong" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Apache Spark has been widely used to build big data applications. Spark utilizes the abstraction of Resilient Distributed Dataset (RDD) to store and retrieve large-scale data. To reduce duplicate computation of an RDD, Spark can cache the RDD in memory and then reuse it later, thus improving performance. Spark relies on application developers to enforce caching decisions by using <em>persist</em>() and <em>unpersist</em>() APIs, e.g., <em>which</em> RDD is persisted and <em>when</em> the RDD is persisted / unpersisted. Incorrect RDD caching decisions can cause duplicate computations, or waste precious memory resource, thus introducing serious performance degradation in Spark applications. In this paper, we propose <em>CacheCheck</em>, to automatically detect cache-related bugs in Spark applications. We summarize six cache-related bug patterns in Spark applications, and then dynamically detect cache-related bugs by analyzing the execution traces of Spark applications. We evaluate CacheCheck on six real-world Spark applications. The experimental result shows that CacheCheck detects 72 previously unknown cache-related bugs, and 28 of them have been fixed by developers.<br/>
        <br />
        <a href="issta20main-id139-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_available_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Available</span></a>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_evaluated_reusable_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Reusable</span></a>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_evaluated_functional_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Functional</span></a>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Wang, Guoxin  </td>
  <td>
    <span onclick="toggle('issta20main-id155-p-wangguoxin')" title="Reinforcement Learning Based Curiosity-Driven Testing of Android Applications  --  Minxue Pan, An Huang, Guoxin Wang, Tian Zhang, and Xuandong Li" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Reinforcement Learning Based ..."</span></small></a>
    </span>

    <span id="issta20main-id155-p-wangguoxin"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id155-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id155-p-wangguoxin')" 
      >
        <a id="issta20main-id155-p-titlewangguoxin" >
          <span style="font-size: 100%">
            Reinforcement Learning Based Curiosity-Driven Testing of Android Applications
          </span>
        </a>
      </span>
      <br />
      Minxue Pan, An Huang, Guoxin Wang, Tian Zhang, and Xuandong Li<br />
      <i><small>(Nanjing University, China)</small></i><br />
      <span id="issta20main-id155-p-abswangguoxin" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Mobile applications play an important role in our daily life, while it still remains a challenge to guarantee their correctness. Model-based and systematic approaches have been applied to Android GUI testing. However, they do not show significant advantages over random approaches because of limitations such as imprecise models and poor scalability. In this paper, we propose Q-testing, a reinforcement learning based approach which benefits from both random and model-based approaches to automated testing of Android applications. Q-testing explores the Android apps with a curiosity-driven strategy that utilizes a memory set to record part of previously visited states and guides the testing towards unfamiliar functionalities. A state comparison module, which is a neural network trained by plenty of collected samples, is novelly employed to divide different states at the granularity of functional scenarios. It can determine the reinforcement learning reward in Q-testing and help the curiosity-driven strategy explore different functionalities efficiently. We conduct experiments on 50 open-source applications where Q-testing outperforms the state-of-the-art and state-of-practice Android GUI testing tools in terms of code coverage and fault detection. So far, 22 of our reported faults have been confirmed, among which 7 have been fixed.<br/>
        <br />
        <a href="issta20main-id155-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
          <span style="font-size: 80%; color: blue;"> 
            <img width="20" src="../images/award.svg" alt="" />
            ACM SIGSOFT Distinguished Paper Award</span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Wang, Kaiyuan  </td>
  <td>
    <span onclick="toggle('issta20main-id27-p-wangkaiyuan')" title="Scalable Build Service System with Smart Scheduling Service  --  Kaiyuan Wang, Greg Tener, Vijay Gullapalli, Xin Huang, Ahmed Gad, and Daniel Rall" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Scalable Build Service System ..."</span></small></a>
    </span>

    <span id="issta20main-id27-p-wangkaiyuan"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id27-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id27-p-wangkaiyuan')" 
      >
        <a id="issta20main-id27-p-titlewangkaiyuan" >
          <span style="font-size: 100%">
            Scalable Build Service System with Smart Scheduling Service
          </span>
        </a>
      </span>
      <br />
      Kaiyuan Wang, Greg Tener, Vijay Gullapalli, Xin Huang, Ahmed Gad, and Daniel Rall<br />
      <i><small>(Google, USA)</small></i><br />
      <span id="issta20main-id27-p-abswangkaiyuan" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Build automation is critical for developers to check if their code compiles, passes all tests and is safe to deploy to the server. Many companies adopt Continuous Integration (CI) services to make sure that the code changes from multiple developers can be safely merged at the head of the project. Internally, CI triggers builds to make sure that the new code change compiles and passes the tests. For any large company which has a monolithic code repository and thousands of developers, it is hard to make sure that all code changes are safe to submit in a timely manner. The reason is that each code change may involve multiple builds, and the company needs to run millions of builds every day to guarantee developers&#8217; productivity.  
<br/>

Google is one of those large companies that need a scalable build service to support developers&#8217; work. More than 100,000 code changes are submitted to our repository on average each day, including changes from either human users or automated tools. More than 15 million builds are executed on average each day. In this paper, we first describe an overview of our scalable build service architecture. Then, we discuss more details about how we make build scheduling decisions. Finally, we discuss some experience in the scalability of the build service system and the performance of the build scheduling service.<br/>
        <br />
        <a href="issta20main-id27-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Wang, Ruoyu  </td>
  <td>
    <span onclick="toggle('issta20main-id47-p-wangruoyu')" title="An Empirical Study on ARM Disassembly Tools  --  Muhui Jiang, Yajin Zhou, Xiapu Luo, Ruoyu Wang, Yang Liu, and Kui Ren" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "An Empirical Study on ARM ..."</span></small></a>
    </span>

    <span id="issta20main-id47-p-wangruoyu"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id47-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id47-p-wangruoyu')" 
      >
        <a id="issta20main-id47-p-titlewangruoyu" >
          <span style="font-size: 100%">
            An Empirical Study on ARM Disassembly Tools
          </span>
        </a>
      </span>
      <br />
      Muhui Jiang, Yajin Zhou, <a href="http://www4.comp.polyu.edu.hk/~csxluo/" target="_blank">Xiapu Luo</a>, Ruoyu Wang, <a href="http://www.ntu.edu.sg/home/yangliu/" target="_blank">Yang Liu</a>, and Kui Ren<br />
      <i><small>(Hong Kong Polytechnic University, China; Zhejiang University, China; Arizona State University, USA; Nanyang Technological University, Singapore)</small></i><br />
      <span id="issta20main-id47-p-abswangruoyu" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              With the increasing popularity of embedded devices, ARM is becoming the dominant architecture for them. In the meanwhile, there is a pressing need to perform security assessments for these devices. Due to different types of peripherals, it is challenging to dynamically run the firmware of these devices in an emulated environment. Therefore, the static analysis is still commonly used. Existing work usually leverages off-the-shelf tools to disassemble stripped ARM binaries and (implicitly) assume that reliable disassembling binaries and function recognition are solved problems. However, whether this assumption really holds is unknown. <br/>In this paper, we conduct the first comprehensive study on ARM disassembly tools. Specifically, we build 1,896 ARM binaries (including 248 obfuscated ones) with different compilers, compiling options, and obfuscation methods. We then evaluate them using eight state-of-the-art ARM disassembly tools (including both commercial and noncommercial ones) on their capabilities to locate instructions and function boundaries. These two are fundamental ones, which are leveraged to build other primitives. Our work reveals some observations that have not been systematically summarized and/or confirmed. For instance, we find that the existence of both ARM and Thumb instruction sets, and the reuse of the BL instruction for both function calls and branches bring serious challenges to disassembly tools. Our evaluation sheds light on the limitations of state-of-the-art disassembly tools and points out potential directions for improvement. To engage the community, we release the data set, and the related scripts at https://github.com/valour01/arm_disasssembler_study.<br/>
        <br />
        <a href="issta20main-id47-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Wang, Shuai  </td>
  <td>
    <span onclick="toggle('issta20main-id103-p-wangshuai')" title="How Far We Have Come: Testing Decompilation Correctness of C Decompilers  --  Zhibo Liu and Shuai Wang" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "How Far We Have Come: Testing ..."</span></small></a>
    </span>

    <span id="issta20main-id103-p-wangshuai"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id103-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id103-p-wangshuai')" 
      >
        <a id="issta20main-id103-p-titlewangshuai" >
          <span style="font-size: 100%">
            How Far We Have Come: Testing Decompilation Correctness of C Decompilers
          </span>
        </a>
      </span>
      <br />
      Zhibo Liu and Shuai Wang<br />
      <i><small>(Hong Kong University of Science and Technology, China)</small></i><br />
      <span id="issta20main-id103-p-abswangshuai" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              A C decompiler converts an executable (the output from a C compiler) into source code. The recovered C source code, once recompiled, will produce an executable with the same functionality as the original executable. With over twenty years of development, C decompilers have been widely used in production to support reverse engineering applications, including legacy software migration, security retrofitting, software comprehension, and to act as the first step in launching adversarial software exploitations. As the paramount component and the trust base in numerous cybersecurity tasks, C decompilers have enabled the analysis of malware, ransomware, and promoted cybersecurity professionals&#8217; understanding of vulnerabilities in real-world systems.  
<br/>

In contrast to this flourishing market, our observation is that in academia, outputs of C decompilers (i.e., recovered C source code) are still not extensively used. Instead, the intermediate representations are often more desired for usage when developing applications such as binary security retrofitting. We acknowledge that such conservative approaches in academia are a result of widespread and pessimistic views on the decompilation correctness. However, in conventional software engineering and security research, how much of a problem is, for instance, reusing a piece of simple legacy code by taking the output of modern C decompilers?  
<br/>

In this work, we test decompilation correctness to present an up-to-date understanding regarding modern C decompilers. We detected a total of 1,423 inputs that can trigger decompilation errors from four popular decompilers, and with extensive manual effort, we identified 13 bugs in two open-source decompilers. Our findings show that the overly pessimistic view of decompilation correctness leads researchers to underestimate the potential of modern decompilers; the state-of-the-art decompilers certainly care about the functional correctness, and they are making promising progress. However, some tasks that have been studied for years in academia, such as type inference and optimization, still impede C decompilers from generating quality outputs more than is reflected in the literature. These issues rarely receive enough attention and can lead to great confusion that misleads users.<br/>
        <br />
        <a href="issta20main-id103-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_evaluated_functional_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Functional</span></a>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Wang, Wei  </td>
  <td>
    <span onclick="toggle('issta20main-id139-p-wangwei')" title="Detecting Cache-Related Bugs in Spark Applications  --  Hui Li, Dong Wang, Tianze Huang, Yu Gao, Wensheng Dou, Lijie Xu, Wei Wang, Jun Wei, and Hua Zhong" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Detecting Cache-Related Bugs ..."</span></small></a>
    </span>

    <span id="issta20main-id139-p-wangwei"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id139-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id139-p-wangwei')" 
      >
        <a id="issta20main-id139-p-titlewangwei" >
          <span style="font-size: 100%">
            Detecting Cache-Related Bugs in Spark Applications
          </span>
        </a>
      </span>
      <br />
      Hui Li, Dong Wang, Tianze Huang, Yu Gao, <a href="http://www.tcse.cn/~wsdou/" target="_blank">Wensheng Dou</a>, Lijie Xu, Wei Wang, Jun Wei, and Hua Zhong<br />
      <i><small>(Institute of Software at Chinese Academy of Sciences, China; University of Chinese Academy of Sciences, China; Beijing University of Posts and Telecommunications, China)</small></i><br />
      <span id="issta20main-id139-p-abswangwei" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Apache Spark has been widely used to build big data applications. Spark utilizes the abstraction of Resilient Distributed Dataset (RDD) to store and retrieve large-scale data. To reduce duplicate computation of an RDD, Spark can cache the RDD in memory and then reuse it later, thus improving performance. Spark relies on application developers to enforce caching decisions by using <em>persist</em>() and <em>unpersist</em>() APIs, e.g., <em>which</em> RDD is persisted and <em>when</em> the RDD is persisted / unpersisted. Incorrect RDD caching decisions can cause duplicate computations, or waste precious memory resource, thus introducing serious performance degradation in Spark applications. In this paper, we propose <em>CacheCheck</em>, to automatically detect cache-related bugs in Spark applications. We summarize six cache-related bug patterns in Spark applications, and then dynamically detect cache-related bugs by analyzing the execution traces of Spark applications. We evaluate CacheCheck on six real-world Spark applications. The experimental result shows that CacheCheck detects 72 previously unknown cache-related bugs, and 28 of them have been fixed by developers.<br/>
        <br />
        <a href="issta20main-id139-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_available_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Available</span></a>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_evaluated_reusable_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Reusable</span></a>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_evaluated_functional_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Functional</span></a>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Wang, Xingwei  </td>
  <td>
    <span onclick="toggle('issta20main-id76-p-wangxingwei')" title="Testing High Performance Numerical Simulation Programs: Experience, Lessons Learned, and Open Issues  --  Xiao He, Xingwei Wang, Jia Shi, and Yi Liu" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Testing High Performance Numerical ..."</span></small></a>
    </span>

    <span id="issta20main-id76-p-wangxingwei"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id76-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id76-p-wangxingwei')" 
      >
        <a id="issta20main-id76-p-titlewangxingwei" >
          <span style="font-size: 100%">
            Testing High Performance Numerical Simulation Programs: Experience, Lessons Learned, and Open Issues
          </span>
        </a>
      </span>
      <br />
      Xiao He, Xingwei Wang, Jia Shi, and Yi Liu<br />
      <i><small>(University of Science and Technology Beijing, China; CNCERT/CC, China)</small></i><br />
      <span id="issta20main-id76-p-abswangxingwei" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              High performance numerical simulation programs are widely used to simulate actual physical processes on high performance computers for the analysis of various physical and engineering problems. They are usually regarded as non-testable due to their high complexity. This paper reports our real experience and lessons learned from testing five simulation programs that will be used to design and analyze nuclear power plants. We applied five testing approaches and found 33 bugs. We found that property-based testing and metamorphic testing are two effective methods. Nevertheless, we suffered from the lack of domain knowledge, the high test costs, the shortage of test cases, severe oracle issues, and inadequate automation support. Consequently, the five programs are not exhaustively tested from the perspective of software testing, and many existing software testing techniques and tools are not fully applicable due to scalability and portability issues. We need more collaboration and communication with other communities to promote the research and application of software testing techniques.<br/>
        <br />
        <a href="issta20main-id76-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Wehrheim, Heike  </td>
  <td>
    <span onclick="toggle('issta20main-id85-p-wehrheimheike')" title="Higher Income, Larger Loan? Monotonicity Testing of Machine Learning Models  --  Arnab Sharma and Heike Wehrheim" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Higher Income, Larger Loan? ..."</span></small></a>
    </span>

    <span id="issta20main-id85-p-wehrheimheike"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id85-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id85-p-wehrheimheike')" 
      >
        <a id="issta20main-id85-p-titlewehrheimheike" >
          <span style="font-size: 100%">
            Higher Income, Larger Loan? Monotonicity Testing of Machine Learning Models
          </span>
        </a>
      </span>
      <br />
      Arnab Sharma and Heike Wehrheim<br />
      <i><small>(University of Paderborn, Germany)</small></i><br />
      <span id="issta20main-id85-p-abswehrheimheike" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Today, machine learning (ML) models are increasingly applied in decision making.  
This induces an urgent need for quality assurance of ML models with respect to (often domain-dependent) requirements. Monotonicity is one such requirement. It specifies a software as &#39;&#39;learned&#39;&#39; by an ML algorithm to give an increasing prediction with the increase of some attribute values. While there exist multiple ML algorithms for ensuring monotonicity of the generated model, approaches for checking monotonicity, in particular of black-box models are largely lacking.  
<br/>

In this work, we propose verification-based testing of monotonicity, i.e., the formal computation of test inputs on a white-box model via verification technology, and the automatic inference of  
this approximating white-box model from the black-box model under test. On the white-box model, the space of test inputs can be systematically explored by a directed computation of test cases.  
The empirical evaluation on 90 black-box models shows that verification-based testing can outperform adaptive random testing as well as property-based techniques with respect to effectiveness and efficiency.<br/>
        <br />
        <a href="issta20main-id85-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Wei, Jun  </td>
  <td>
    <span onclick="toggle('issta20main-id141-p-weijun')" title="Learning to Detect Table Clones in Spreadsheets  --  Yakun Zhang, Wensheng Dou, Jiaxin Zhu, Liang Xu, Zhiyong Zhou, Jun Wei, Dan Ye, and Bo Yang" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Learning to Detect Table Clones ..."</span></small></a>
    </span>

    <span id="issta20main-id141-p-weijun"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id141-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id141-p-weijun')" 
      >
        <a id="issta20main-id141-p-titleweijun" >
          <span style="font-size: 100%">
            Learning to Detect Table Clones in Spreadsheets
          </span>
        </a>
      </span>
      <br />
      Yakun Zhang, <a href="http://www.tcse.cn/~wsdou/" target="_blank">Wensheng Dou</a>, Jiaxin Zhu, Liang Xu, Zhiyong Zhou, Jun Wei, Dan Ye, and Bo Yang<br />
      <i><small>(Institute of Software at Chinese Academy of Sciences, China; Jinling Institute of Technology, China; North China University of Technology, China)</small></i><br />
      <span id="issta20main-id141-p-absweijun" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              In order to speed up spreadsheet development productivity, end users can create a spreadsheet table by copying and modifying an existing one. These two tables share the similar computational semantics, and form a table clone. End users may modify the tables in a table clone, e.g., adding new rows and deleting columns, thus introducing structure changes into the table clone. Our empirical study on real-world spreadsheets shows that about 58.5% of table clones involve structure changes. However, existing table clone detection approaches in spreadsheets can only detect table clones with the same structures. Therefore, many table clones with structure changes cannot be detected. <br/>We observe that, although the tables in a table clone may be modified, they usually share the similar structures and formats, e.g., headers, formulas and background colors. Based on this observation, we propose <em>LTC</em> (<em>L</em>earning to detect <em>T</em>able <em>C</em>lones), to automatically detect table clones with or without structure changes. LTC utilizes the structure and format information from labeled table clones and non table clones to train a binary classifier. LTC first identifies tables in spreadsheets, and then uses the trained binary classifier to judge whether every two tables can form a table clone. Our experiments on real-world spreadsheets from the EUSES and Enron corpora show that, LTC can achieve a precision of 97.8% and recall of 92.1% in table clone detection, significantly outperforming the state-of-the-art technique (a precision of 37.5% and recall of 11.1%).<br/>
        <br />
        <a href="issta20main-id141-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
    <span onclick="toggle('issta20main-id139-p-weijun')" title="Detecting Cache-Related Bugs in Spark Applications  --  Hui Li, Dong Wang, Tianze Huang, Yu Gao, Wensheng Dou, Lijie Xu, Wei Wang, Jun Wei, and Hua Zhong" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Detecting Cache-Related Bugs ..."</span></small></a>
    </span>

    <span id="issta20main-id139-p-weijun"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id139-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id139-p-weijun')" 
      >
        <a id="issta20main-id139-p-titleweijun" >
          <span style="font-size: 100%">
            Detecting Cache-Related Bugs in Spark Applications
          </span>
        </a>
      </span>
      <br />
      Hui Li, Dong Wang, Tianze Huang, Yu Gao, <a href="http://www.tcse.cn/~wsdou/" target="_blank">Wensheng Dou</a>, Lijie Xu, Wei Wang, Jun Wei, and Hua Zhong<br />
      <i><small>(Institute of Software at Chinese Academy of Sciences, China; University of Chinese Academy of Sciences, China; Beijing University of Posts and Telecommunications, China)</small></i><br />
      <span id="issta20main-id139-p-absweijun" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Apache Spark has been widely used to build big data applications. Spark utilizes the abstraction of Resilient Distributed Dataset (RDD) to store and retrieve large-scale data. To reduce duplicate computation of an RDD, Spark can cache the RDD in memory and then reuse it later, thus improving performance. Spark relies on application developers to enforce caching decisions by using <em>persist</em>() and <em>unpersist</em>() APIs, e.g., <em>which</em> RDD is persisted and <em>when</em> the RDD is persisted / unpersisted. Incorrect RDD caching decisions can cause duplicate computations, or waste precious memory resource, thus introducing serious performance degradation in Spark applications. In this paper, we propose <em>CacheCheck</em>, to automatically detect cache-related bugs in Spark applications. We summarize six cache-related bug patterns in Spark applications, and then dynamically detect cache-related bugs by analyzing the execution traces of Spark applications. We evaluate CacheCheck on six real-world Spark applications. The experimental result shows that CacheCheck detects 72 previously unknown cache-related bugs, and 28 of them have been fixed by developers.<br/>
        <br />
        <a href="issta20main-id139-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_available_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Available</span></a>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_evaluated_reusable_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Reusable</span></a>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_evaluated_functional_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Functional</span></a>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Wei, Moshi  </td>
  <td>
    <span onclick="toggle('issta20main-id96-p-weimoshi')" title="CoCoNuT: Combining Context-Aware Neural Translation Models using Ensemble for Program Repair  --  Thibaud Lutellier, Hung Viet Pham, Lawrence Pang, Yitong Li, Moshi Wei, and Lin Tan" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "CoCoNuT: Combining Context-Aware ..."</span></small></a>
    </span>

    <span id="issta20main-id96-p-weimoshi"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id96-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id96-p-weimoshi')" 
      >
        <a id="issta20main-id96-p-titleweimoshi" >
          <span style="font-size: 100%">
            CoCoNuT: Combining Context-Aware Neural Translation Models using Ensemble for Program Repair
          </span>
        </a>
      </span>
      <br />
      Thibaud Lutellier, Hung Viet Pham, Lawrence Pang, Yitong Li, Moshi Wei, and Lin Tan<br />
      <i><small>(University of Waterloo, Canada; Purdue University, USA)</small></i><br />
      <span id="issta20main-id96-p-absweimoshi" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Automated generate-and-validate (GV) program repair techniques (APR) typically rely on hard-coded rules, thus only fixing bugs following specific fix patterns. These rules require a significant amount of manual effort to discover and it is hard to adapt these rules to different programming languages. <br/>To address these challenges, we propose a new G&amp;V technique&#8212;CoCoNuT, which uses ensemble learning on the combination of convolutional neural networks (CNNs) and a new context-aware neural machine translation (NMT) architecture to automatically fix bugs in multiple programming languages. To better represent the context of a bug, we introduce a new context-aware NMT architecture that represents the buggy source code and its surrounding context separately. CoCoNuT uses CNNs instead of recurrent neural networks (RNNs), since CNN layers can be stacked to extract hierarchical features and better model source code at different granularity levels (e.g., statements and functions). In addition, CoCoNuT takes advantage of the randomness in hyperparameter tuning to build multiple models that fix different bugs and combines these models using ensemble learning to fix more bugs. <br/>Our evaluation on six popular benchmarks for four programming languages (Java, C, Python, and JavaScript) shows that CoCoNuT correctly fixes (i.e., the first generated patch is semantically equivalent to the developer&#8217;s patch) 509 bugs, including 309 bugs that are fixed by none of the 27 techniques with which we compare.<br/>
        <br />
        <a href="issta20main-id96-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Weyuker, Elaine J.  </td>
  <td>
    <span onclick="toggle('issta20main-id63-p-weyukerelainej')" title="Intermittently Failing Tests in the Embedded Systems Domain  --  Per Erik Strandberg, Thomas J. Ostrand, Elaine J. Weyuker, Wasif Afzal, and Daniel Sundmark" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Intermittently Failing Tests ..."</span></small></a>
    </span>

    <span id="issta20main-id63-p-weyukerelainej"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id63-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id63-p-weyukerelainej')" 
      >
        <a id="issta20main-id63-p-titleweyukerelainej" >
          <span style="font-size: 100%">
            Intermittently Failing Tests in the Embedded Systems Domain
          </span>
        </a>
      </span>
      <br />
      Per Erik Strandberg, Thomas J. Ostrand, Elaine J. Weyuker, Wasif Afzal, and Daniel Sundmark<br />
      <i><small>(Westermo Network Technologies, Sweden; Mälardalen University, Sweden; University of Central Florida, USA)</small></i><br />
      <span id="issta20main-id63-p-absweyukerelainej" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Software testing is sometimes plagued with intermittently failing tests and finding the root causes of such failing tests is often difficult. This problem has been widely studied at the unit testing level for open source software, but there has been far less investigation at the system test level, particularly the testing of industrial embedded systems. This paper describes our investigation of the root causes of intermittently failing tests in the embedded systems domain, with the goal of better understanding, explaining and categorizing the underlying faults. The subject of our investigation is a currently-running industrial embedded system, along with the system level testing that was performed. We devised and used a novel metric for classifying test cases as intermittent. From more than a half million test verdicts, we identified intermittently and consistently failing tests, and identified their root causes using multiple sources. We found that about 1-3% of all test cases were intermittently failing. From analysis of the case study results and related work, we identified nine factors associated with test case intermittence. We found that a fix for a consistently failing test typically removed a larger number of failures detected by other tests than a fix for an intermittent test. We also found that more effort was usually needed to identify fixes for intermittent tests than for consistent tests. An overlap between root causes leading to intermittent and consistent tests was identified. Many root causes of intermittence are the same in industrial embedded systems and open source software. However, when comparing unit testing to system level testing, especially for embedded systems, we observed that the test environment itself is often the cause of intermittence.<br/>
        <br />
        <a href="issta20main-id63-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Wu, Kaishun  </td>
  <td>
    <span onclick="toggle('issta20main-id2-p-wukaishun')" title="Detecting and Diagnosing Energy Issues for Mobile Applications  --  Xueliang Li, Yuming Yang, Yepang Liu, John P. Gallagher, and Kaishun Wu" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Detecting and Diagnosing Energy ..."</span></small></a>
    </span>

    <span id="issta20main-id2-p-wukaishun"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id2-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id2-p-wukaishun')" 
      >
        <a id="issta20main-id2-p-titlewukaishun" >
          <span style="font-size: 100%">
            Detecting and Diagnosing Energy Issues for Mobile Applications
          </span>
        </a>
      </span>
      <br />
      Xueliang Li, Yuming Yang, Yepang Liu, John P. Gallagher, and Kaishun Wu<br />
      <i><small>(Shenzhen University, China; Southern University of Science and Technology, China; Roskilde University, Denmark; IMDEA Software Institute, Spain)</small></i><br />
      <span id="issta20main-id2-p-abswukaishun" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Energy efficiency is an important criterion to judge the quality of mobile apps, but one third of our randomly sampled apps suffer from energy issues that can quickly drain battery power. To understand these issues, we conducted an empirical study on 27 well-maintained apps such as Chrome and Firefox, whose issue tracking systems are publicly accessible. Our study revealed that the main root causes of energy issues include unnecessary workload and excessively frequent operations. Surprisingly, these issues are beyond the application of present technology on energy issue detection. We also found that 25.0% of energy issues can only manifest themselves under specific contexts such as poor network performance, but such contexts are again neglected by present technology. In this paper, we propose a novel testing framework for detecting energy issues in real-world mobile apps. Our framework examines apps with well-designed input sequences and runtime contexts. To identify the root causes mentioned above, we employed a machine learning algorithm to cluster the workloads and further evaluate their necessity. For the issues concealed by the specific contexts, we carefully set up several execution contexts to catch them. More importantly, we designed leading edge technology, e.g. pre-designing input sequences with potential energy overuse and tuning tests on-the-fly, to achieve high efficacy in detecting energy issues. A large-scale evaluation shows that 91.6% issues detected in our experiments were previously unknown to developers. On average, these issues double the energy costs of the apps. Our testing technique achieves a low number of false positives.<br/>
        <br />
        <a href="issta20main-id2-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Wu, Rongxin  </td>
  <td>
    <span onclick="toggle('issta20main-id145-p-wurongxin')" title="Escaping Dependency Hell: Finding Build Dependency Errors with the Unified Dependency Graph  --  Gang Fan, Chengpeng Wang, Rongxin Wu, Xiao Xiao, Qingkai Shi, and Charles Zhang" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Escaping Dependency Hell: ..."</span></small></a>
    </span>

    <span id="issta20main-id145-p-wurongxin"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id145-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id145-p-wurongxin')" 
      >
        <a id="issta20main-id145-p-titlewurongxin" >
          <span style="font-size: 100%">
            Escaping Dependency Hell: Finding Build Dependency Errors with the Unified Dependency Graph
          </span>
        </a>
      </span>
      <br />
      Gang Fan, Chengpeng Wang, Rongxin Wu, Xiao Xiao, Qingkai Shi, and Charles Zhang<br />
      <i><small>(Hong Kong University of Science and Technology, China; Xiamen University, China; Sourcebrella, China)</small></i><br />
      <span id="issta20main-id145-p-abswurongxin" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Modern software projects rely on build systems and build scripts to assemble executable artifacts correctly and efficiently. However, developing build scripts is error-prone. Dependency-related errors in build scripts, mainly including missing dependencies and redundant dependencies, are common in various kinds of software projects. These errors lead to build failures, incorrect build results or poor performance in incremental or parallel builds. To detect such errors, various techniques are proposed and suffer from low efficiency and high false positive problems, due to the deficiency of the underlying dependency graphs. In this work, we design a new dependency graph, the unified dependency graph (UDG), which leverages both static and dynamic information to uniformly encode the declared and actual dependencies between build targets and files. The construction of UDG facilitates the efficient and precise detection of dependency errors via simple graph traversals. We implement the proposed approach as a tool, VeriBuild, and evaluate it on forty-two well-maintained open-source projects. The experimental results show that, without losing precision, VeriBuild incurs 58.2% less overhead than the state-of-the-art approach. By the time of writing, 398 detected dependency issues have been confirmed by the developers.<br/>
        <br />
        <a href="issta20main-id145-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Wu, Zhenhao  </td>
  <td>
    <span onclick="toggle('issta20tool-id11-p-wuzhenhao')" title="EShield: Protect Smart Contracts against Reverse Engineering  --  Wentian Yan, Jianbo Gao, Zhenhao Wu, Yue Li, Zhi Guan, Qingshan Li, and Zhong Chen" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20-TOOL: "EShield: Protect Smart Contracts ..."</span></small></a>
    </span>

    <span id="issta20tool-id11-p-wuzhenhao"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20tool-id11-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20tool-id11-p-wuzhenhao')" 
      >
        <a id="issta20tool-id11-p-titlewuzhenhao" >
          <span style="font-size: 100%">
            EShield: Protect Smart Contracts against Reverse Engineering
          </span>
        </a>
      </span>
      <br />
      Wentian Yan, Jianbo Gao, Zhenhao Wu, Yue Li, Zhi Guan, Qingshan Li, and Zhong Chen<br />
      <i><small>(Peking University, China; Boya Blockchain, China)</small></i><br />
      <span id="issta20tool-id11-p-abswuzhenhao" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Smart contracts are the back-end programs of blockchain-based applications and the execution results are deterministic and publicly visible. Developers are unwilling to release source code of some smart contracts to generate randomness or for security reasons, however, attackers still can use reverse engineering tools to decompile and analyze the code. In this paper, we propose EShield, an automated security enhancement tool for protecting smart contracts against reverse engineering. EShield replaces original instructions of operating jump addresses with anti-patterns to interfere with control flow recovery from bytecode. We have implemented four methods in EShield and conducted an experiment on over 20k smart contracts. The evaluation results show that all the protected smart contracts are resistant to three different reverse engineering tools with little extra gas cost.<br/>
        <br />
        <a href="issta20tool-id11-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;"><a id="X"> </a>Xiao, Xiao
  </td>
  <td>
    <span onclick="toggle('issta20main-id145-p-xiaoxiao')" title="Escaping Dependency Hell: Finding Build Dependency Errors with the Unified Dependency Graph  --  Gang Fan, Chengpeng Wang, Rongxin Wu, Xiao Xiao, Qingkai Shi, and Charles Zhang" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Escaping Dependency Hell: ..."</span></small></a>
    </span>

    <span id="issta20main-id145-p-xiaoxiao"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id145-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id145-p-xiaoxiao')" 
      >
        <a id="issta20main-id145-p-titlexiaoxiao" >
          <span style="font-size: 100%">
            Escaping Dependency Hell: Finding Build Dependency Errors with the Unified Dependency Graph
          </span>
        </a>
      </span>
      <br />
      Gang Fan, Chengpeng Wang, Rongxin Wu, Xiao Xiao, Qingkai Shi, and Charles Zhang<br />
      <i><small>(Hong Kong University of Science and Technology, China; Xiamen University, China; Sourcebrella, China)</small></i><br />
      <span id="issta20main-id145-p-absxiaoxiao" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Modern software projects rely on build systems and build scripts to assemble executable artifacts correctly and efficiently. However, developing build scripts is error-prone. Dependency-related errors in build scripts, mainly including missing dependencies and redundant dependencies, are common in various kinds of software projects. These errors lead to build failures, incorrect build results or poor performance in incremental or parallel builds. To detect such errors, various techniques are proposed and suffer from low efficiency and high false positive problems, due to the deficiency of the underlying dependency graphs. In this work, we design a new dependency graph, the unified dependency graph (UDG), which leverages both static and dynamic information to uniformly encode the declared and actual dependencies between build targets and files. The construction of UDG facilitates the efficient and precise detection of dependency errors via simple graph traversals. We implement the proposed approach as a tool, VeriBuild, and evaluate it on forty-two well-maintained open-source projects. The experimental results show that, without losing precision, VeriBuild incurs 58.2% less overhead than the state-of-the-art approach. By the time of writing, 398 detected dependency issues have been confirmed by the developers.<br/>
        <br />
        <a href="issta20main-id145-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;"><a href="http://taoxie.cs.illinois.edu/">Xie, Tao</a>  </td>
  <td>
    <span onclick="toggle('issta20main-id57-p-xietao')" title="Dependent-Test-Aware Regression Testing Techniques  --  Wing Lam, August Shi, Reed Oei, Sai Zhang, Michael D. Ernst, and Tao Xie" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Dependent-Test-Aware Regression ..."</span></small></a>
    </span>

    <span id="issta20main-id57-p-xietao"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id57-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id57-p-xietao')" 
      >
        <a id="issta20main-id57-p-titlexietao" >
          <span style="font-size: 100%">
            Dependent-Test-Aware Regression Testing Techniques
          </span>
        </a>
      </span>
      <br />
      <a href="http://winglam2.web.engr.illinois.edu/" target="_blank">Wing Lam</a>, <a href="http://mir.cs.illinois.edu/~awshi2/" target="_blank">August Shi</a>, Reed Oei, Sai Zhang, <a href="https://homes.cs.washington.edu/~mernst/" target="_blank">Michael D. Ernst</a>, and <a href="http://taoxie.cs.illinois.edu/" target="_blank">Tao Xie</a><br />
      <i><small>(University of Illinois at Urbana-Champaign, USA; Google, USA; University of Washington, USA; Peking University, China)</small></i><br />
      <span id="issta20main-id57-p-absxietao" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Developers typically rely on regression testing techniques to ensure that their changes do not break existing functionality. Unfortunately, these techniques suffer from flaky tests, which can both pass and fail when run multiple times on the same version of code and tests. One prominent type of flaky tests is order-dependent (OD) tests, which are tests that pass when run in one order but fail when run in another order. Although OD tests may cause flaky-test failures, OD tests can help developers run their tests faster by allowing them to share resources. We propose to make regression testing techniques dependent-test-aware to reduce flaky-test failures.  
<br/>

To understand the necessity of dependent-test-aware regression testing techniques, we conduct the first study on the impact of OD tests on three regression testing techniques: test prioritization, test selection, and test parallelization. In particular, we implement 4 test prioritization, 6 test selection, and 2 test parallelization algorithms, and we evaluate them on 11 Java modules with OD tests. When we run the orders produced by the traditional, dependent-test-unaware regression testing algorithms, 82% of human-written test suites and 100% of automatically-generated test suites with OD tests have at least one flaky-test failure.  
<br/>

We develop a general approach for enhancing regression testing algorithms to make them dependent-test-aware, and apply our approach to 12 algorithms. Compared to traditional, unenhanced regression testing algorithms, the enhanced algorithms use provided test dependencies to produce orders with different permutations or extra tests. Our evaluation shows that, in comparison to the orders produced by unenhanced algorithms, the orders produced by enhanced algorithms (1) have overall 80% fewer flaky-test failures due to OD tests, and (2) may add extra tests but run only 1% slower on average. Our results suggest that enhancing regression testing algorithms to be dependent-test-aware can substantially reduce flaky-test failures with only a minor slowdown to run the tests.<br/>
        <br />
        <a href="issta20main-id57-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Xiu, Ziheng  </td>
  <td>
    <span onclick="toggle('issta20main-id134-p-xiuziheng')" title="Recovering Fitness Gradients for Interprocedural Boolean Flags in Search-Based Testing  --  Yun Lin, Jun Sun, Gordon Fraser, Ziheng Xiu, Ting Liu, and Jin Song Dong" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Recovering Fitness Gradients ..."</span></small></a>
    </span>

    <span id="issta20main-id134-p-xiuziheng"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id134-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id134-p-xiuziheng')" 
      >
        <a id="issta20main-id134-p-titlexiuziheng" >
          <span style="font-size: 100%">
            Recovering Fitness Gradients for Interprocedural Boolean Flags in Search-Based Testing
          </span>
        </a>
      </span>
      <br />
      <a href="http://linyun.info/" target="_blank">Yun Lin</a>, Jun Sun, Gordon Fraser, Ziheng Xiu, Ting Liu, and Jin Song Dong<br />
      <i><small>(National University of Singapore, Singapore; Singapore Management University, Singapore; University of Passau, Germany; Xi&#39;an Jiaotong University, China)</small></i><br />
      <span id="issta20main-id134-p-absxiuziheng" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              In Search-based Software Testing (SBST), test generation is guided by fitness functions that estimate how close a test case is to reach an uncovered test goal (e.g., branch). A popular fitness function estimates how close conditional statements are to evaluating to true or false, i.e., the branch distance. However, when conditions read Boolean variables (e.g., if(x &amp;&amp; y)), the branch distance provides no gradient for the search, since a Boolean can either be true or false. This flag problem can be addressed by transforming individual procedures such that Boolean flags are replaced with numeric comparisons that provide better guidance for the search. Unfortunately, defining a semantics-preserving transformation that is applicable in an interprocedural case, where Boolean flags are passed around as parameters and return values, is a daunting task. Thus, it is not yet supported by modern test generators. <br/>This work is based on the insight that fitness gradients can be recovered by using runtime information: Given an uncovered interprocedural flag branch, our approach (1) calculates context-sensitive branch distance for all control flows potentially returning the required flag in the called method, and (2) recursively aggregates these distances into a continuous value. We implemented our approach on top of the EvoSuite framework for Java, and empirically compared it with state-of-the-art testability transformations on non-trivial methods suffering from interprocedural flag problems, sampled from open source Java projects. Our experiment demonstrates that our approach achieves higher coverage on the subject methods with statistical significance and acceptable runtime overheads.<br/>
        <br />
        <a href="issta20main-id134-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Xu, Liang  </td>
  <td>
    <span onclick="toggle('issta20main-id141-p-xuliang')" title="Learning to Detect Table Clones in Spreadsheets  --  Yakun Zhang, Wensheng Dou, Jiaxin Zhu, Liang Xu, Zhiyong Zhou, Jun Wei, Dan Ye, and Bo Yang" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Learning to Detect Table Clones ..."</span></small></a>
    </span>

    <span id="issta20main-id141-p-xuliang"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id141-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id141-p-xuliang')" 
      >
        <a id="issta20main-id141-p-titlexuliang" >
          <span style="font-size: 100%">
            Learning to Detect Table Clones in Spreadsheets
          </span>
        </a>
      </span>
      <br />
      Yakun Zhang, <a href="http://www.tcse.cn/~wsdou/" target="_blank">Wensheng Dou</a>, Jiaxin Zhu, Liang Xu, Zhiyong Zhou, Jun Wei, Dan Ye, and Bo Yang<br />
      <i><small>(Institute of Software at Chinese Academy of Sciences, China; Jinling Institute of Technology, China; North China University of Technology, China)</small></i><br />
      <span id="issta20main-id141-p-absxuliang" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              In order to speed up spreadsheet development productivity, end users can create a spreadsheet table by copying and modifying an existing one. These two tables share the similar computational semantics, and form a table clone. End users may modify the tables in a table clone, e.g., adding new rows and deleting columns, thus introducing structure changes into the table clone. Our empirical study on real-world spreadsheets shows that about 58.5% of table clones involve structure changes. However, existing table clone detection approaches in spreadsheets can only detect table clones with the same structures. Therefore, many table clones with structure changes cannot be detected. <br/>We observe that, although the tables in a table clone may be modified, they usually share the similar structures and formats, e.g., headers, formulas and background colors. Based on this observation, we propose <em>LTC</em> (<em>L</em>earning to detect <em>T</em>able <em>C</em>lones), to automatically detect table clones with or without structure changes. LTC utilizes the structure and format information from labeled table clones and non table clones to train a binary classifier. LTC first identifies tables in spreadsheets, and then uses the trained binary classifier to judge whether every two tables can form a table clone. Our experiments on real-world spreadsheets from the EUSES and Enron corpora show that, LTC can achieve a precision of 97.8% and recall of 92.1% in table clone detection, significantly outperforming the state-of-the-art technique (a precision of 37.5% and recall of 11.1%).<br/>
        <br />
        <a href="issta20main-id141-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Xu, Lijie  </td>
  <td>
    <span onclick="toggle('issta20main-id139-p-xulijie')" title="Detecting Cache-Related Bugs in Spark Applications  --  Hui Li, Dong Wang, Tianze Huang, Yu Gao, Wensheng Dou, Lijie Xu, Wei Wang, Jun Wei, and Hua Zhong" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Detecting Cache-Related Bugs ..."</span></small></a>
    </span>

    <span id="issta20main-id139-p-xulijie"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id139-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id139-p-xulijie')" 
      >
        <a id="issta20main-id139-p-titlexulijie" >
          <span style="font-size: 100%">
            Detecting Cache-Related Bugs in Spark Applications
          </span>
        </a>
      </span>
      <br />
      Hui Li, Dong Wang, Tianze Huang, Yu Gao, <a href="http://www.tcse.cn/~wsdou/" target="_blank">Wensheng Dou</a>, Lijie Xu, Wei Wang, Jun Wei, and Hua Zhong<br />
      <i><small>(Institute of Software at Chinese Academy of Sciences, China; University of Chinese Academy of Sciences, China; Beijing University of Posts and Telecommunications, China)</small></i><br />
      <span id="issta20main-id139-p-absxulijie" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Apache Spark has been widely used to build big data applications. Spark utilizes the abstraction of Resilient Distributed Dataset (RDD) to store and retrieve large-scale data. To reduce duplicate computation of an RDD, Spark can cache the RDD in memory and then reuse it later, thus improving performance. Spark relies on application developers to enforce caching decisions by using <em>persist</em>() and <em>unpersist</em>() APIs, e.g., <em>which</em> RDD is persisted and <em>when</em> the RDD is persisted / unpersisted. Incorrect RDD caching decisions can cause duplicate computations, or waste precious memory resource, thus introducing serious performance degradation in Spark applications. In this paper, we propose <em>CacheCheck</em>, to automatically detect cache-related bugs in Spark applications. We summarize six cache-related bug patterns in Spark applications, and then dynamically detect cache-related bugs by analyzing the execution traces of Spark applications. We evaluate CacheCheck on six real-world Spark applications. The experimental result shows that CacheCheck detects 72 previously unknown cache-related bugs, and 28 of them have been fixed by developers.<br/>
        <br />
        <a href="issta20main-id139-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_available_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Available</span></a>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_evaluated_reusable_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Reusable</span></a>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_evaluated_functional_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Functional</span></a>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Xu, Yifei  </td>
  <td>
    <span onclick="toggle('issta20main-id120-p-xuyifei')" title="Patch Based Vulnerability Matching for Binary Programs  --  Yifei Xu, Zhengzi Xu, Bihuan Chen, Fu Song, Yang Liu, and Ting Liu" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Patch Based Vulnerability ..."</span></small></a>
    </span>

    <span id="issta20main-id120-p-xuyifei"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id120-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id120-p-xuyifei')" 
      >
        <a id="issta20main-id120-p-titlexuyifei" >
          <span style="font-size: 100%">
            Patch Based Vulnerability Matching for Binary Programs
          </span>
        </a>
      </span>
      <br />
      Yifei Xu, Zhengzi Xu, Bihuan Chen, Fu Song, <a href="http://www.ntu.edu.sg/home/yangliu/" target="_blank">Yang Liu</a>, and Ting Liu<br />
      <i><small>(Xi&#39;an Jiaotong University, China; Nanyang Technological University, Singapore; Fudan University, China; ShanghaiTech University, China; Zhejiang University, China)</small></i><br />
      <span id="issta20main-id120-p-absxuyifei" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              The binary-level function matching has been widely used to detect whether there are 1-day vulnerabilities in released programs. However, the high false positive is a challenge for current function matching solutions, since the vulnerable function is highly similar to its corresponding patched version. In this paper, the Binary X-Ray (BinXray), a patch based vulnerability matching approach, is proposed to identify the specific 1-day vulnerabilities in target programs  
accurately and effectively. In the preparing step, a basic block mapping algorithm is designed to extract the signature of a patch, by comparing the given vulnerable and patched programs. The signature is represented as a set of basic block traces. In the detection step, the patching semantics is applied to reduce irrelevant basic block traces to speed up the signature searching. The trace similarity is also designed to identify whether a target program is patched. In experiments, 12 real software projects related to 479 CVEs are collected. BinXray achieves 93.31% accuracy and the analysis time cost is only 296.17ms per function, outperforming the state-of-the-art works.<br/>
        <br />
        <a href="issta20main-id120-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Xu, Zhengzi  </td>
  <td>
    <span onclick="toggle('issta20main-id120-p-xuzhengzi')" title="Patch Based Vulnerability Matching for Binary Programs  --  Yifei Xu, Zhengzi Xu, Bihuan Chen, Fu Song, Yang Liu, and Ting Liu" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Patch Based Vulnerability ..."</span></small></a>
    </span>

    <span id="issta20main-id120-p-xuzhengzi"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id120-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id120-p-xuzhengzi')" 
      >
        <a id="issta20main-id120-p-titlexuzhengzi" >
          <span style="font-size: 100%">
            Patch Based Vulnerability Matching for Binary Programs
          </span>
        </a>
      </span>
      <br />
      Yifei Xu, Zhengzi Xu, Bihuan Chen, Fu Song, <a href="http://www.ntu.edu.sg/home/yangliu/" target="_blank">Yang Liu</a>, and Ting Liu<br />
      <i><small>(Xi&#39;an Jiaotong University, China; Nanyang Technological University, Singapore; Fudan University, China; ShanghaiTech University, China; Zhejiang University, China)</small></i><br />
      <span id="issta20main-id120-p-absxuzhengzi" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              The binary-level function matching has been widely used to detect whether there are 1-day vulnerabilities in released programs. However, the high false positive is a challenge for current function matching solutions, since the vulnerable function is highly similar to its corresponding patched version. In this paper, the Binary X-Ray (BinXray), a patch based vulnerability matching approach, is proposed to identify the specific 1-day vulnerabilities in target programs  
accurately and effectively. In the preparing step, a basic block mapping algorithm is designed to extract the signature of a patch, by comparing the given vulnerable and patched programs. The signature is represented as a set of basic block traces. In the detection step, the patching semantics is applied to reduce irrelevant basic block traces to speed up the signature searching. The trace similarity is also designed to identify whether a target program is patched. In experiments, 12 real software projects related to 479 CVEs are collected. BinXray achieves 93.31% accuracy and the analysis time cost is only 296.17ms per function, outperforming the state-of-the-art works.<br/>
        <br />
        <a href="issta20main-id120-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Xuan, Bohan  </td>
  <td>
    <span onclick="toggle('issta20main-id40-p-xuanbohan')" title="Active Fuzzing for Testing and Securing Cyber-Physical Systems  --  Yuqi Chen, Bohan Xuan, Christopher M. Poskitt, Jun Sun, and Fan Zhang" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Active Fuzzing for Testing ..."</span></small></a>
    </span>

    <span id="issta20main-id40-p-xuanbohan"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id40-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id40-p-xuanbohan')" 
      >
        <a id="issta20main-id40-p-titlexuanbohan" >
          <span style="font-size: 100%">
            Active Fuzzing for Testing and Securing Cyber-Physical Systems
          </span>
        </a>
      </span>
      <br />
      Yuqi Chen, Bohan Xuan, Christopher M. Poskitt, Jun Sun, and Fan Zhang<br />
      <i><small>(Singapore Management University, Singapore; Zhejiang University, China; Zhejiang Lab, China; Alibaba-Zhejiang University Joint Institute of Frontier Technologies, China)</small></i><br />
      <span id="issta20main-id40-p-absxuanbohan" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Cyber-physical systems&#160;(CPSs) in critical infrastructure face a pervasive threat from attackers, motivating research into a variety of countermeasures for securing them. Assessing the effectiveness of these countermeasures is challenging, however, as realistic benchmarks of attacks are difficult to manually construct, blindly testing is ineffective due to the enormous search spaces and resource requirements, and intelligent fuzzing approaches require impractical amounts of data and network access. In this work, we propose <em>active fuzzing</em>, an automatic approach for finding test suites of packet-level CPS network attacks, targeting scenarios in which attackers can observe sensors and manipulate packets, but have no existing knowledge about the payload encodings. Our approach learns regression models for predicting sensor values that will result from sampled network packets, and uses these predictions to guide a search for payload manipulations (i.e.&#160;bit flips) most likely to drive the CPS into an unsafe state. Key to our solution is the use of <em>online active learning</em>, which iteratively updates the models by sampling payloads that are estimated to maximally improve them. We evaluate the efficacy of active fuzzing by implementing it for a water purification plant testbed, finding it can automatically discover a test suite of flow, pressure, and over/underflow attacks, all with substantially less time, data, and network access than the most comparable approach. Finally, we demonstrate that our prediction models can also be utilised as countermeasures themselves, implementing them as anomaly detectors and early warning systems.<br/>
        <br />
        <a href="issta20main-id40-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Xue, Feng  </td>
  <td>
    <span onclick="toggle('issta20doc-p2-p-xuefeng')" title="Automated Mobile Apps Testing from Visual Perspective  --  Feng Xue" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20-DOC: "Automated Mobile Apps Testing ..."</span></small></a>
    </span>

    <span id="issta20doc-p2-p-xuefeng"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20doc-p2-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20doc-p2-p-xuefeng')" 
      >
        <a id="issta20doc-p2-p-titlexuefeng" >
          <span style="font-size: 100%">
            Automated Mobile Apps Testing from Visual Perspective
          </span>
        </a>
      </span>
      <br />
      Feng Xue<br />
      <i><small>(Northwestern Polytechnical University, China)</small></i><br />
      <span id="issta20doc-p2-p-absxuefeng" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              The current implementation of automated mobile apps testing generally relies on internal program information, such as reading code or GUI layout files, capturing event streams. This paper proposes an approach of automated mobile apps testing from a completely visual perspective. It uses computer vision technology to enable computer to judge the internal functions from the external GUI information of mobile apps as we humans do and generates test strategy for execution, which improves the interactivity, flexibility, and authenticity of testing. We believe that this vision-based testing approach will further help alleviate the contradiction between the current huge test requirements of mobile apps and the relatively lack of testers.<br/>
        <br />
        <a href="issta20doc-p2-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;"><a id="Y"> </a>Yan, Wentian
  </td>
  <td>
    <span onclick="toggle('issta20tool-id11-p-yanwentian')" title="EShield: Protect Smart Contracts against Reverse Engineering  --  Wentian Yan, Jianbo Gao, Zhenhao Wu, Yue Li, Zhi Guan, Qingshan Li, and Zhong Chen" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20-TOOL: "EShield: Protect Smart Contracts ..."</span></small></a>
    </span>

    <span id="issta20tool-id11-p-yanwentian"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20tool-id11-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20tool-id11-p-yanwentian')" 
      >
        <a id="issta20tool-id11-p-titleyanwentian" >
          <span style="font-size: 100%">
            EShield: Protect Smart Contracts against Reverse Engineering
          </span>
        </a>
      </span>
      <br />
      Wentian Yan, Jianbo Gao, Zhenhao Wu, Yue Li, Zhi Guan, Qingshan Li, and Zhong Chen<br />
      <i><small>(Peking University, China; Boya Blockchain, China)</small></i><br />
      <span id="issta20tool-id11-p-absyanwentian" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Smart contracts are the back-end programs of blockchain-based applications and the execution results are deterministic and publicly visible. Developers are unwilling to release source code of some smart contracts to generate randomness or for security reasons, however, attackers still can use reverse engineering tools to decompile and analyze the code. In this paper, we propose EShield, an automated security enhancement tool for protecting smart contracts against reverse engineering. EShield replaces original instructions of operating jump addresses with anti-patterns to interfere with control flow recovery from bytecode. We have implemented four methods in EShield and conducted an experiment on over 20k smart contracts. The evaluation results show that all the protected smart contracts are resistant to three different reverse engineering tools with little extra gas cost.<br/>
        <br />
        <a href="issta20tool-id11-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Yang, Bo  </td>
  <td>
    <span onclick="toggle('issta20main-id141-p-yangbo')" title="Learning to Detect Table Clones in Spreadsheets  --  Yakun Zhang, Wensheng Dou, Jiaxin Zhu, Liang Xu, Zhiyong Zhou, Jun Wei, Dan Ye, and Bo Yang" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Learning to Detect Table Clones ..."</span></small></a>
    </span>

    <span id="issta20main-id141-p-yangbo"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id141-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id141-p-yangbo')" 
      >
        <a id="issta20main-id141-p-titleyangbo" >
          <span style="font-size: 100%">
            Learning to Detect Table Clones in Spreadsheets
          </span>
        </a>
      </span>
      <br />
      Yakun Zhang, <a href="http://www.tcse.cn/~wsdou/" target="_blank">Wensheng Dou</a>, Jiaxin Zhu, Liang Xu, Zhiyong Zhou, Jun Wei, Dan Ye, and Bo Yang<br />
      <i><small>(Institute of Software at Chinese Academy of Sciences, China; Jinling Institute of Technology, China; North China University of Technology, China)</small></i><br />
      <span id="issta20main-id141-p-absyangbo" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              In order to speed up spreadsheet development productivity, end users can create a spreadsheet table by copying and modifying an existing one. These two tables share the similar computational semantics, and form a table clone. End users may modify the tables in a table clone, e.g., adding new rows and deleting columns, thus introducing structure changes into the table clone. Our empirical study on real-world spreadsheets shows that about 58.5% of table clones involve structure changes. However, existing table clone detection approaches in spreadsheets can only detect table clones with the same structures. Therefore, many table clones with structure changes cannot be detected. <br/>We observe that, although the tables in a table clone may be modified, they usually share the similar structures and formats, e.g., headers, formulas and background colors. Based on this observation, we propose <em>LTC</em> (<em>L</em>earning to detect <em>T</em>able <em>C</em>lones), to automatically detect table clones with or without structure changes. LTC utilizes the structure and format information from labeled table clones and non table clones to train a binary classifier. LTC first identifies tables in spreadsheets, and then uses the trained binary classifier to judge whether every two tables can form a table clone. Our experiments on real-world spreadsheets from the EUSES and Enron corpora show that, LTC can achieve a precision of 97.8% and recall of 92.1% in table clone detection, significantly outperforming the state-of-the-art technique (a precision of 37.5% and recall of 11.1%).<br/>
        <br />
        <a href="issta20main-id141-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Yang, Yuming  </td>
  <td>
    <span onclick="toggle('issta20main-id2-p-yangyuming')" title="Detecting and Diagnosing Energy Issues for Mobile Applications  --  Xueliang Li, Yuming Yang, Yepang Liu, John P. Gallagher, and Kaishun Wu" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Detecting and Diagnosing Energy ..."</span></small></a>
    </span>

    <span id="issta20main-id2-p-yangyuming"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id2-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id2-p-yangyuming')" 
      >
        <a id="issta20main-id2-p-titleyangyuming" >
          <span style="font-size: 100%">
            Detecting and Diagnosing Energy Issues for Mobile Applications
          </span>
        </a>
      </span>
      <br />
      Xueliang Li, Yuming Yang, Yepang Liu, John P. Gallagher, and Kaishun Wu<br />
      <i><small>(Shenzhen University, China; Southern University of Science and Technology, China; Roskilde University, Denmark; IMDEA Software Institute, Spain)</small></i><br />
      <span id="issta20main-id2-p-absyangyuming" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Energy efficiency is an important criterion to judge the quality of mobile apps, but one third of our randomly sampled apps suffer from energy issues that can quickly drain battery power. To understand these issues, we conducted an empirical study on 27 well-maintained apps such as Chrome and Firefox, whose issue tracking systems are publicly accessible. Our study revealed that the main root causes of energy issues include unnecessary workload and excessively frequent operations. Surprisingly, these issues are beyond the application of present technology on energy issue detection. We also found that 25.0% of energy issues can only manifest themselves under specific contexts such as poor network performance, but such contexts are again neglected by present technology. In this paper, we propose a novel testing framework for detecting energy issues in real-world mobile apps. Our framework examines apps with well-designed input sequences and runtime contexts. To identify the root causes mentioned above, we employed a machine learning algorithm to cluster the workloads and further evaluate their necessity. For the issues concealed by the specific contexts, we carefully set up several execution contexts to catch them. More importantly, we designed leading edge technology, e.g. pre-designing input sequences with potential energy overuse and tuning tests on-the-fly, to achieve high efficacy in detecting energy issues. A large-scale evaluation shows that 91.6% issues detected in our experiments were previously unknown to developers. On average, these issues double the energy costs of the apps. Our testing technique achieves a low number of false positives.<br/>
        <br />
        <a href="issta20main-id2-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Yao, Peisen  </td>
  <td>
    <span onclick="toggle('issta20main-id21-p-yaopeisen')" title="Fast Bit-Vector Satisfiability  --  Peisen Yao, Qingkai Shi, Heqing Huang, and Charles Zhang" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Fast Bit-Vector Satisfiability ..."</span></small></a>
    </span>

    <span id="issta20main-id21-p-yaopeisen"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id21-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id21-p-yaopeisen')" 
      >
        <a id="issta20main-id21-p-titleyaopeisen" >
          <span style="font-size: 100%">
            Fast Bit-Vector Satisfiability
          </span>
        </a>
      </span>
      <br />
      Peisen Yao, Qingkai Shi, Heqing Huang, and Charles Zhang<br />
      <i><small>(Hong Kong University of Science and Technology, China)</small></i><br />
      <span id="issta20main-id21-p-absyaopeisen" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              SMT solving is often a major source of cost in a broad range of techniques such as symbolic program analysis.  
Thus, speeding up SMT solving is still an urgent requirement.  
A dominant approach, which is known as eager SMT solving, is to reduce a first-order formula to a pure Boolean formula, which is handed to an expensive SAT solver to determine the satisfiability.  
We observe that the SAT solver can utilize the knowledge in the first-order formula to boost its solving efficiency.  
Unfortunately, despite much progress, it is still not clear how to make use of the knowledge in an eager SMT solver.  
This paper addresses the problem by introducing a new and fast method,  
which utilizes the interval and data-dependence information learned from the first-order formulas.  
<br/>

We have implemented the approach as a tool called Trident and evaluated it on three symbolic analyzers (Angr, Qsym, and Pinpoint).  
The experimental results, based on seven million SMT solving instances generated for thirty real-world software systems, show that Trident significantly reduces the total solving time from 2.9X to 7.9X over three state-of-the-art SMT solvers (Z3, CVC4, and Boolector),  
without sacrificing the number of solved instances.  
We also demonstrate that Trident achieves  
end-to-end speedups for three program analysis clients by 1.9X, 1.6X, and 2.4X, respectively.<br/>
        <br />
        <a href="issta20main-id21-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Ye, Dan  </td>
  <td>
    <span onclick="toggle('issta20main-id141-p-yedan')" title="Learning to Detect Table Clones in Spreadsheets  --  Yakun Zhang, Wensheng Dou, Jiaxin Zhu, Liang Xu, Zhiyong Zhou, Jun Wei, Dan Ye, and Bo Yang" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Learning to Detect Table Clones ..."</span></small></a>
    </span>

    <span id="issta20main-id141-p-yedan"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id141-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id141-p-yedan')" 
      >
        <a id="issta20main-id141-p-titleyedan" >
          <span style="font-size: 100%">
            Learning to Detect Table Clones in Spreadsheets
          </span>
        </a>
      </span>
      <br />
      Yakun Zhang, <a href="http://www.tcse.cn/~wsdou/" target="_blank">Wensheng Dou</a>, Jiaxin Zhu, Liang Xu, Zhiyong Zhou, Jun Wei, Dan Ye, and Bo Yang<br />
      <i><small>(Institute of Software at Chinese Academy of Sciences, China; Jinling Institute of Technology, China; North China University of Technology, China)</small></i><br />
      <span id="issta20main-id141-p-absyedan" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              In order to speed up spreadsheet development productivity, end users can create a spreadsheet table by copying and modifying an existing one. These two tables share the similar computational semantics, and form a table clone. End users may modify the tables in a table clone, e.g., adding new rows and deleting columns, thus introducing structure changes into the table clone. Our empirical study on real-world spreadsheets shows that about 58.5% of table clones involve structure changes. However, existing table clone detection approaches in spreadsheets can only detect table clones with the same structures. Therefore, many table clones with structure changes cannot be detected. <br/>We observe that, although the tables in a table clone may be modified, they usually share the similar structures and formats, e.g., headers, formulas and background colors. Based on this observation, we propose <em>LTC</em> (<em>L</em>earning to detect <em>T</em>able <em>C</em>lones), to automatically detect table clones with or without structure changes. LTC utilizes the structure and format information from labeled table clones and non table clones to train a binary classifier. LTC first identifies tables in spreadsheets, and then uses the trained binary classifier to judge whether every two tables can form a table clone. Our experiments on real-world spreadsheets from the EUSES and Enron corpora show that, LTC can achieve a precision of 97.8% and recall of 92.1% in table clone detection, significantly outperforming the state-of-the-art technique (a precision of 37.5% and recall of 11.1%).<br/>
        <br />
        <a href="issta20main-id141-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Yuan, Wei  </td>
  <td>
    <span onclick="toggle('issta20tool-id7-p-yuanwei')" title="Crowdsourced Requirements Generation for Automatic Testing via Knowledge Graph  --  Chao Guo, Tieke He, Wei Yuan, Yue Guo, and Rui Hao" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20-TOOL: "Crowdsourced Requirements ..."</span></small></a>
    </span>

    <span id="issta20tool-id7-p-yuanwei"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20tool-id7-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20tool-id7-p-yuanwei')" 
      >
        <a id="issta20tool-id7-p-titleyuanwei" >
          <span style="font-size: 100%">
            Crowdsourced Requirements Generation for Automatic Testing via Knowledge Graph
          </span>
        </a>
      </span>
      <br />
      Chao Guo, Tieke He, Wei Yuan, Yue Guo, and Rui Hao<br />
      <i><small>(Nanjing University, China)</small></i><br />
      <span id="issta20tool-id7-p-absyuanwei" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Crowdsourced testing provides an effective way to deal with the problem of Android system fragmentation, as well as the application scenario diversity faced by Android testing. The generation of test requirements is a significant part of crowdsourced testing. However, manually generating crowdsourced testing requirements is tedious, which requires the issuers to have the domain knowledge of the Android application under test. To solve these problems, we have developed a tool named KARA, short for Knowledge Graph Aided Crowdsourced Requirements Generation for Android Testing. KARA first analyzes the result of automatic testing on the Android application, through which the operation sequences can be obtained. Then, the knowledge graph of the target application is constructed in a manner of pay-as-you-go. Finally, KARA utilizes knowledge graph and the automatic testing result to generate crowdsourced testing requirements with domain knowledge. Experiments prove that the test requirements generated by KARA are well understandable, and KARA can improve the quality of crowdsourced testing. The demo video can be found at https://youtu.be/kE-dOiekWWM.<br/>
        <br />
        <a href="issta20tool-id7-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;"><a id="Z"> </a>Zeller, Andreas
  </td>
  <td>
    <span onclick="toggle('issta20main-id136-p-zellerandreas')" title="Abstracting Failure-Inducing Inputs  --  Rahul Gopinath, Alexander Kampmann, Nikolas Havrikov, Ezekiel O. Soremekun, and Andreas Zeller" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Abstracting Failure-Inducing ..."</span></small></a>
    </span>

    <span id="issta20main-id136-p-zellerandreas"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id136-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id136-p-zellerandreas')" 
      >
        <a id="issta20main-id136-p-titlezellerandreas" >
          <span style="font-size: 100%">
            Abstracting Failure-Inducing Inputs
          </span>
        </a>
      </span>
      <br />
      Rahul Gopinath, Alexander Kampmann, Nikolas Havrikov, Ezekiel O. Soremekun, and Andreas Zeller<br />
      <i><small>(CISPA, Germany)</small></i><br />
      <span id="issta20main-id136-p-abszellerandreas" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              A program fails. Under which circumstances does the failure occur? Starting with a single failure-inducing input (&quot;The input ((4)) fails&quot;) and an input grammar, the DDSET algorithm uses systematic tests to automatically generalize the input to an abstract failure-inducing input that contains both (concrete) terminal symbols and (abstract) nonterminal symbols from the grammar&#8212;for instance, &quot;((&#60;expr&#62;))&quot;, which represents any expression &#60;expr&#62; in double parentheses. Such an abstract failure-inducing input can be used (1) as a debugging diagnostic, characterizing the circumstances under which a failure occurs (&quot;The error occurs whenever an expression is enclosed in double parentheses&quot;); (2) as a producer of additional failure-inducing tests to help design and validate fixes and repair candidates (&quot;The inputs ((1)), ((3 * 4)), and many more also fail&quot;). In its evaluation on real-world bugs in JavaScript, Clojure, Lua, and UNIX command line utilities, DDSET&#8217;s abstract failure-inducing inputs provided to-the-point diagnostics, and precise producers for further failure inducing inputs.<br/>
        <br />
        <a href="issta20main-id136-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
      <a href="https://github.com/vrthra/ddset"><img width="15" src="../images/tool.png" alt="" /><span style="font-size: 90%"> Info</span></a>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_available_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Available</span></a>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_evaluated_reusable_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Reusable</span></a>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_evaluated_functional_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Functional</span></a>
          <span style="font-size: 80%; color: blue;"> 
            <img width="20" src="../images/award.svg" alt="" />
            ACM SIGSOFT Distinguished Paper Award</span>
    </span>
    <span onclick="toggle('issta20main-id130-p-zellerandreas')" title="Learning Input Tokens for Effective Fuzzing  --  Björn Mathis, Rahul Gopinath, and Andreas Zeller" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Learning Input Tokens for ..."</span></small></a>
    </span>

    <span id="issta20main-id130-p-zellerandreas"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id130-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id130-p-zellerandreas')" 
      >
        <a id="issta20main-id130-p-titlezellerandreas" >
          <span style="font-size: 100%">
            Learning Input Tokens for Effective Fuzzing
          </span>
        </a>
      </span>
      <br />
      Björn Mathis, Rahul Gopinath, and Andreas Zeller<br />
      <i><small>(CISPA, Germany)</small></i><br />
      <span id="issta20main-id130-p-abszellerandreas" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Modern fuzzing tools like AFL operate at a lexical level: They explore the input space of tested programs one byte after another. For inputs with complex syntactical properties, this is very inefficient, as keywords and other tokens have to be composed one character at a time. Fuzzers thus allow to specify dictionaries listing possible tokens the input can be composed from; such dictionaries speed up fuzzers dramatically. Also, fuzzers make use of dynamic tainting to track input tokens and infer values that are expected in the input validation phase. Unfortunately, such tokens are usually implicitly converted to program specific values which causes a loss of the taints attached to the input data in the lexical phase.  
In this paper, we present a technique to extend dynamic tainting to not only track explicit data flows but also taint implicitly converted data without suffering from taint explosion. This extension makes it possible to augment existing techniques and automatically infer a set of tokens and seed inputs for the input language of a program given nothing but the source code. Specifically targeting the lexical analysis of an input processor, our lFuzzer test generator systematically explores branches of the lexical analysis, producing a set of tokens that fully cover all decisions seen. The resulting set of tokens can be directly used as a dictionary for fuzzing. Along with the token extraction seed inputs are generated which give further fuzzing processes a head start. In our experiments, the lFuzzer-AFL combination achieves up to 17% more coverage on complex input formats like json, lisp, tinyC, and JavaScript compared to AFL.<br/>
        <br />
        <a href="issta20main-id130-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_available_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Available</span></a>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_evaluated_functional_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Functional</span></a>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Zhai, Juan  </td>
  <td>
    <span onclick="toggle('issta20tool-id21-p-zhaijuan')" title="FineLock: Automatically Refactoring Coarse-Grained Locks into Fine-Grained Locks  --  Yang Zhang, Shuai Shao, Juan Zhai, and Shiqing Ma" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20-TOOL: "FineLock: Automatically Refactoring ..."</span></small></a>
    </span>

    <span id="issta20tool-id21-p-zhaijuan"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20tool-id21-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20tool-id21-p-zhaijuan')" 
      >
        <a id="issta20tool-id21-p-titlezhaijuan" >
          <span style="font-size: 100%">
            FineLock: Automatically Refactoring Coarse-Grained Locks into Fine-Grained Locks
          </span>
        </a>
      </span>
      <br />
      Yang Zhang, Shuai Shao, Juan Zhai, and Shiqing Ma<br />
      <i><small>(Hebei University of Science and Technology, China; Rutgers University, USA)</small></i><br />
      <span id="issta20tool-id21-p-abszhaijuan" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Lock is a frequently-used synchronization mechanism to enforce exclusive access to a shared resource. However, lock-based concurrent programs are susceptible to lock contention, which leads to low performance and poor scalability. Furthermore, inappropriate granularity of a lock makes lock contention even worse. Compared to coarse-grained lock, fine-grained lock can mitigate lock contention but difficult to use. Converting coarse-grained lock into fine-grained lock manually is not only error-prone and tedious, but also requires a lot of expertise. In this paper, we propose to leverage program analysis techniques and pushdown automaton to automatically covert coarse-grained locks into fine-grained locks to reduce lock contention. We developed a prototype FineLock and evaluates it on 5 projects. The evaluation results demonstrate FineLock can refactor 1,546 locks in an average of 27.6 seconds, including converting 129 coarse-grained locks into fine-grained locks and 1,417 coarse-grained locks into read/write locks. By automatically providing potential refactoring recommendations, our tool saves a lot of efforts for developers.<br/>
        <br />
        <a href="issta20tool-id21-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Zhang, Charles  </td>
  <td>
    <span onclick="toggle('issta20main-id21-p-zhangcharles')" title="Fast Bit-Vector Satisfiability  --  Peisen Yao, Qingkai Shi, Heqing Huang, and Charles Zhang" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Fast Bit-Vector Satisfiability ..."</span></small></a>
    </span>

    <span id="issta20main-id21-p-zhangcharles"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id21-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id21-p-zhangcharles')" 
      >
        <a id="issta20main-id21-p-titlezhangcharles" >
          <span style="font-size: 100%">
            Fast Bit-Vector Satisfiability
          </span>
        </a>
      </span>
      <br />
      Peisen Yao, Qingkai Shi, Heqing Huang, and Charles Zhang<br />
      <i><small>(Hong Kong University of Science and Technology, China)</small></i><br />
      <span id="issta20main-id21-p-abszhangcharles" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              SMT solving is often a major source of cost in a broad range of techniques such as symbolic program analysis.  
Thus, speeding up SMT solving is still an urgent requirement.  
A dominant approach, which is known as eager SMT solving, is to reduce a first-order formula to a pure Boolean formula, which is handed to an expensive SAT solver to determine the satisfiability.  
We observe that the SAT solver can utilize the knowledge in the first-order formula to boost its solving efficiency.  
Unfortunately, despite much progress, it is still not clear how to make use of the knowledge in an eager SMT solver.  
This paper addresses the problem by introducing a new and fast method,  
which utilizes the interval and data-dependence information learned from the first-order formulas.  
<br/>

We have implemented the approach as a tool called Trident and evaluated it on three symbolic analyzers (Angr, Qsym, and Pinpoint).  
The experimental results, based on seven million SMT solving instances generated for thirty real-world software systems, show that Trident significantly reduces the total solving time from 2.9X to 7.9X over three state-of-the-art SMT solvers (Z3, CVC4, and Boolector),  
without sacrificing the number of solved instances.  
We also demonstrate that Trident achieves  
end-to-end speedups for three program analysis clients by 1.9X, 1.6X, and 2.4X, respectively.<br/>
        <br />
        <a href="issta20main-id21-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
    <span onclick="toggle('issta20main-id145-p-zhangcharles')" title="Escaping Dependency Hell: Finding Build Dependency Errors with the Unified Dependency Graph  --  Gang Fan, Chengpeng Wang, Rongxin Wu, Xiao Xiao, Qingkai Shi, and Charles Zhang" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Escaping Dependency Hell: ..."</span></small></a>
    </span>

    <span id="issta20main-id145-p-zhangcharles"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id145-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id145-p-zhangcharles')" 
      >
        <a id="issta20main-id145-p-titlezhangcharles" >
          <span style="font-size: 100%">
            Escaping Dependency Hell: Finding Build Dependency Errors with the Unified Dependency Graph
          </span>
        </a>
      </span>
      <br />
      Gang Fan, Chengpeng Wang, Rongxin Wu, Xiao Xiao, Qingkai Shi, and Charles Zhang<br />
      <i><small>(Hong Kong University of Science and Technology, China; Xiamen University, China; Sourcebrella, China)</small></i><br />
      <span id="issta20main-id145-p-abszhangcharles" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Modern software projects rely on build systems and build scripts to assemble executable artifacts correctly and efficiently. However, developing build scripts is error-prone. Dependency-related errors in build scripts, mainly including missing dependencies and redundant dependencies, are common in various kinds of software projects. These errors lead to build failures, incorrect build results or poor performance in incremental or parallel builds. To detect such errors, various techniques are proposed and suffer from low efficiency and high false positive problems, due to the deficiency of the underlying dependency graphs. In this work, we design a new dependency graph, the unified dependency graph (UDG), which leverages both static and dynamic information to uniformly encode the declared and actual dependencies between build targets and files. The construction of UDG facilitates the efficient and precise detection of dependency errors via simple graph traversals. We implement the proposed approach as a tool, VeriBuild, and evaluate it on forty-two well-maintained open-source projects. The experimental results show that, without losing precision, VeriBuild incurs 58.2% less overhead than the state-of-the-art approach. By the time of writing, 398 detected dependency issues have been confirmed by the developers.<br/>
        <br />
        <a href="issta20main-id145-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Zhang, Fan  </td>
  <td>
    <span onclick="toggle('issta20main-id40-p-zhangfan')" title="Active Fuzzing for Testing and Securing Cyber-Physical Systems  --  Yuqi Chen, Bohan Xuan, Christopher M. Poskitt, Jun Sun, and Fan Zhang" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Active Fuzzing for Testing ..."</span></small></a>
    </span>

    <span id="issta20main-id40-p-zhangfan"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id40-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id40-p-zhangfan')" 
      >
        <a id="issta20main-id40-p-titlezhangfan" >
          <span style="font-size: 100%">
            Active Fuzzing for Testing and Securing Cyber-Physical Systems
          </span>
        </a>
      </span>
      <br />
      Yuqi Chen, Bohan Xuan, Christopher M. Poskitt, Jun Sun, and Fan Zhang<br />
      <i><small>(Singapore Management University, Singapore; Zhejiang University, China; Zhejiang Lab, China; Alibaba-Zhejiang University Joint Institute of Frontier Technologies, China)</small></i><br />
      <span id="issta20main-id40-p-abszhangfan" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Cyber-physical systems&#160;(CPSs) in critical infrastructure face a pervasive threat from attackers, motivating research into a variety of countermeasures for securing them. Assessing the effectiveness of these countermeasures is challenging, however, as realistic benchmarks of attacks are difficult to manually construct, blindly testing is ineffective due to the enormous search spaces and resource requirements, and intelligent fuzzing approaches require impractical amounts of data and network access. In this work, we propose <em>active fuzzing</em>, an automatic approach for finding test suites of packet-level CPS network attacks, targeting scenarios in which attackers can observe sensors and manipulate packets, but have no existing knowledge about the payload encodings. Our approach learns regression models for predicting sensor values that will result from sampled network packets, and uses these predictions to guide a search for payload manipulations (i.e.&#160;bit flips) most likely to drive the CPS into an unsafe state. Key to our solution is the use of <em>online active learning</em>, which iteratively updates the models by sampling payloads that are estimated to maximally improve them. We evaluate the efficacy of active fuzzing by implementing it for a water purification plant testbed, finding it can automatically discover a test suite of flow, pressure, and over/underflow attacks, all with substantially less time, data, and network access than the most comparable approach. Finally, we demonstrate that our prediction models can also be utilised as countermeasures themselves, implementing them as anomaly detectors and early warning systems.<br/>
        <br />
        <a href="issta20main-id40-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Zhang, Haotian  </td>
  <td>
    <span onclick="toggle('issta20main-id22-p-zhanghaotian')" title="Can Automated Program Repair Refine Fault Localization? A Unified Debugging Approach  --  Yiling Lou, Ali Ghanbari, Xia Li, Lingming Zhang, Haotian Zhang, Dan Hao, and Lu Zhang" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Can Automated Program Repair ..."</span></small></a>
    </span>

    <span id="issta20main-id22-p-zhanghaotian"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id22-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id22-p-zhanghaotian')" 
      >
        <a id="issta20main-id22-p-titlezhanghaotian" >
          <span style="font-size: 100%">
            Can Automated Program Repair Refine Fault Localization? A Unified Debugging Approach
          </span>
        </a>
      </span>
      <br />
      Yiling Lou, Ali Ghanbari, Xia Li, Lingming Zhang, Haotian Zhang, Dan Hao, and Lu Zhang<br />
      <i><small>(Peking University, China; University of Texas at Dallas, USA; Ant Financial Services, China)</small></i><br />
      <span id="issta20main-id22-p-abszhanghaotian" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              A large body of research efforts have been dedicated to automated software debugging, including both automated fault localization and program repair. However, existing fault localization techniques have limited effectiveness on real-world software systems while even the most advanced program repair techniques can only fix a small ratio of real-world bugs. Although fault localization and program repair are inherently connected, their only existing connection in the literature is that program repair techniques usually use off-the-shelf fault localization techniques (e.g., Ochiai) to determine the potential candidate statements/elements for patching. In this work, we propose the unified debugging approach to unify the two areas in the other direction for the first time, i.e., can program repair in turn help with fault localization? In this way, we not only open a new dimension for more powerful fault localization, but also extend the application scope of program repair to all possible bugs (not only the bugs that can be directly automatically fixed). We have designed ProFL to leverage patch-execution results (from program repair) as the feedback information for fault localization. The experimental results on the widely used Defects4J benchmark show that the basic ProFL can already at least localize 37.61% more bugs within Top-1 than state-of-the-art spectrum and mutation based fault localization. Furthermore, ProFL can boost state-of-the-art fault localization via both unsupervised and supervised learning. Meanwhile, we have demonstrated ProFL&#39;s effectiveness under different settings and through a case study within Alipay, a popular online payment system with over 1 billion global users.<br/>
        <br />
        <a href="issta20main-id22-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_available_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Available</span></a>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_evaluated_reusable_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Reusable</span></a>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_evaluated_functional_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Functional</span></a>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Zhang, Lingming  </td>
  <td>
    <span onclick="toggle('issta20main-id22-p-zhanglingming')" title="Can Automated Program Repair Refine Fault Localization? A Unified Debugging Approach  --  Yiling Lou, Ali Ghanbari, Xia Li, Lingming Zhang, Haotian Zhang, Dan Hao, and Lu Zhang" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Can Automated Program Repair ..."</span></small></a>
    </span>

    <span id="issta20main-id22-p-zhanglingming"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id22-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id22-p-zhanglingming')" 
      >
        <a id="issta20main-id22-p-titlezhanglingming" >
          <span style="font-size: 100%">
            Can Automated Program Repair Refine Fault Localization? A Unified Debugging Approach
          </span>
        </a>
      </span>
      <br />
      Yiling Lou, Ali Ghanbari, Xia Li, Lingming Zhang, Haotian Zhang, Dan Hao, and Lu Zhang<br />
      <i><small>(Peking University, China; University of Texas at Dallas, USA; Ant Financial Services, China)</small></i><br />
      <span id="issta20main-id22-p-abszhanglingming" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              A large body of research efforts have been dedicated to automated software debugging, including both automated fault localization and program repair. However, existing fault localization techniques have limited effectiveness on real-world software systems while even the most advanced program repair techniques can only fix a small ratio of real-world bugs. Although fault localization and program repair are inherently connected, their only existing connection in the literature is that program repair techniques usually use off-the-shelf fault localization techniques (e.g., Ochiai) to determine the potential candidate statements/elements for patching. In this work, we propose the unified debugging approach to unify the two areas in the other direction for the first time, i.e., can program repair in turn help with fault localization? In this way, we not only open a new dimension for more powerful fault localization, but also extend the application scope of program repair to all possible bugs (not only the bugs that can be directly automatically fixed). We have designed ProFL to leverage patch-execution results (from program repair) as the feedback information for fault localization. The experimental results on the widely used Defects4J benchmark show that the basic ProFL can already at least localize 37.61% more bugs within Top-1 than state-of-the-art spectrum and mutation based fault localization. Furthermore, ProFL can boost state-of-the-art fault localization via both unsupervised and supervised learning. Meanwhile, we have demonstrated ProFL&#39;s effectiveness under different settings and through a case study within Alipay, a popular online payment system with over 1 billion global users.<br/>
        <br />
        <a href="issta20main-id22-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_available_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Available</span></a>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_evaluated_reusable_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Reusable</span></a>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_evaluated_functional_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Functional</span></a>
    </span>
    <span onclick="toggle('issta20main-id126-p-zhanglingming')" title="Empirically Revisiting and Enhancing IR-Based Test-Case Prioritization  --  Qianyang Peng, August Shi, and Lingming Zhang" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Empirically Revisiting and ..."</span></small></a>
    </span>

    <span id="issta20main-id126-p-zhanglingming"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id126-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id126-p-zhanglingming')" 
      >
        <a id="issta20main-id126-p-titlezhanglingming" >
          <span style="font-size: 100%">
            Empirically Revisiting and Enhancing IR-Based Test-Case Prioritization
          </span>
        </a>
      </span>
      <br />
      Qianyang Peng, <a href="http://mir.cs.illinois.edu/~awshi2/" target="_blank">August Shi</a>, and Lingming Zhang<br />
      <i><small>(University of Illinois at Urbana-Champaign, USA; University of Texas at Dallas, USA)</small></i><br />
      <span id="issta20main-id126-p-abszhanglingming" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Test-case prioritization (TCP) aims to detect regression bugs faster  
via reordering the tests run. While TCP has been studied for over  
20 years, it was almost always evaluated using seeded faults/mutants as opposed to using real test failures. In this work, we study  
the recent change-aware information retrieval (IR) technique for  
TCP. Prior work has shown it performing better than traditional  
coverage-based TCP techniques, but it was only evaluated on a  
small-scale dataset with a cost-unaware metric based on seeded  
faults/mutants. We extend the prior work by conducting a much  
larger and more realistic evaluation as well as proposing enhancements that substantially improve the performance. In particular,  
we evaluate the original technique on a large-scale, real-world  
software-evolution dataset with real failures using both cost-aware  
and cost-unaware metrics under various configurations. Also, we  
design and evaluate hybrid techniques combining the IR features,  
historical test execution time, and test failure frequencies. Our  
results show that the change-aware IR technique outperforms stateof-the-art coverage-based techniques in this real-world setting, and  
our hybrid techniques improve even further upon the original IR  
technique. Moreover, we show that flaky tests have a substantial  
impact on evaluating the change-aware TCP techniques based on  
real test failures.<br/>
        <br />
        <a href="issta20main-id126-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
      <a href="https://sites.google.com/view/ir-based-tcp"><img width="15" src="../images/tool.png" alt="" /><span style="font-size: 90%"> Info</span></a>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Zhang, Lu  </td>
  <td>
    <span onclick="toggle('issta20main-id22-p-zhanglu')" title="Can Automated Program Repair Refine Fault Localization? A Unified Debugging Approach  --  Yiling Lou, Ali Ghanbari, Xia Li, Lingming Zhang, Haotian Zhang, Dan Hao, and Lu Zhang" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Can Automated Program Repair ..."</span></small></a>
    </span>

    <span id="issta20main-id22-p-zhanglu"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id22-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id22-p-zhanglu')" 
      >
        <a id="issta20main-id22-p-titlezhanglu" >
          <span style="font-size: 100%">
            Can Automated Program Repair Refine Fault Localization? A Unified Debugging Approach
          </span>
        </a>
      </span>
      <br />
      Yiling Lou, Ali Ghanbari, Xia Li, Lingming Zhang, Haotian Zhang, Dan Hao, and Lu Zhang<br />
      <i><small>(Peking University, China; University of Texas at Dallas, USA; Ant Financial Services, China)</small></i><br />
      <span id="issta20main-id22-p-abszhanglu" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              A large body of research efforts have been dedicated to automated software debugging, including both automated fault localization and program repair. However, existing fault localization techniques have limited effectiveness on real-world software systems while even the most advanced program repair techniques can only fix a small ratio of real-world bugs. Although fault localization and program repair are inherently connected, their only existing connection in the literature is that program repair techniques usually use off-the-shelf fault localization techniques (e.g., Ochiai) to determine the potential candidate statements/elements for patching. In this work, we propose the unified debugging approach to unify the two areas in the other direction for the first time, i.e., can program repair in turn help with fault localization? In this way, we not only open a new dimension for more powerful fault localization, but also extend the application scope of program repair to all possible bugs (not only the bugs that can be directly automatically fixed). We have designed ProFL to leverage patch-execution results (from program repair) as the feedback information for fault localization. The experimental results on the widely used Defects4J benchmark show that the basic ProFL can already at least localize 37.61% more bugs within Top-1 than state-of-the-art spectrum and mutation based fault localization. Furthermore, ProFL can boost state-of-the-art fault localization via both unsupervised and supervised learning. Meanwhile, we have demonstrated ProFL&#39;s effectiveness under different settings and through a case study within Alipay, a popular online payment system with over 1 billion global users.<br/>
        <br />
        <a href="issta20main-id22-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_available_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Available</span></a>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_evaluated_reusable_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Reusable</span></a>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_evaluated_functional_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Functional</span></a>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Zhang, Sai  </td>
  <td>
    <span onclick="toggle('issta20main-id57-p-zhangsai')" title="Dependent-Test-Aware Regression Testing Techniques  --  Wing Lam, August Shi, Reed Oei, Sai Zhang, Michael D. Ernst, and Tao Xie" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Dependent-Test-Aware Regression ..."</span></small></a>
    </span>

    <span id="issta20main-id57-p-zhangsai"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id57-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id57-p-zhangsai')" 
      >
        <a id="issta20main-id57-p-titlezhangsai" >
          <span style="font-size: 100%">
            Dependent-Test-Aware Regression Testing Techniques
          </span>
        </a>
      </span>
      <br />
      <a href="http://winglam2.web.engr.illinois.edu/" target="_blank">Wing Lam</a>, <a href="http://mir.cs.illinois.edu/~awshi2/" target="_blank">August Shi</a>, Reed Oei, Sai Zhang, <a href="https://homes.cs.washington.edu/~mernst/" target="_blank">Michael D. Ernst</a>, and <a href="http://taoxie.cs.illinois.edu/" target="_blank">Tao Xie</a><br />
      <i><small>(University of Illinois at Urbana-Champaign, USA; Google, USA; University of Washington, USA; Peking University, China)</small></i><br />
      <span id="issta20main-id57-p-abszhangsai" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Developers typically rely on regression testing techniques to ensure that their changes do not break existing functionality. Unfortunately, these techniques suffer from flaky tests, which can both pass and fail when run multiple times on the same version of code and tests. One prominent type of flaky tests is order-dependent (OD) tests, which are tests that pass when run in one order but fail when run in another order. Although OD tests may cause flaky-test failures, OD tests can help developers run their tests faster by allowing them to share resources. We propose to make regression testing techniques dependent-test-aware to reduce flaky-test failures.  
<br/>

To understand the necessity of dependent-test-aware regression testing techniques, we conduct the first study on the impact of OD tests on three regression testing techniques: test prioritization, test selection, and test parallelization. In particular, we implement 4 test prioritization, 6 test selection, and 2 test parallelization algorithms, and we evaluate them on 11 Java modules with OD tests. When we run the orders produced by the traditional, dependent-test-unaware regression testing algorithms, 82% of human-written test suites and 100% of automatically-generated test suites with OD tests have at least one flaky-test failure.  
<br/>

We develop a general approach for enhancing regression testing algorithms to make them dependent-test-aware, and apply our approach to 12 algorithms. Compared to traditional, unenhanced regression testing algorithms, the enhanced algorithms use provided test dependencies to produce orders with different permutations or extra tests. Our evaluation shows that, in comparison to the orders produced by unenhanced algorithms, the orders produced by enhanced algorithms (1) have overall 80% fewer flaky-test failures due to OD tests, and (2) may add extra tests but run only 1% slower on average. Our results suggest that enhancing regression testing algorithms to be dependent-test-aware can substantially reduce flaky-test failures with only a minor slowdown to run the tests.<br/>
        <br />
        <a href="issta20main-id57-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Zhang, Tian  </td>
  <td>
    <span onclick="toggle('issta20main-id155-p-zhangtian')" title="Reinforcement Learning Based Curiosity-Driven Testing of Android Applications  --  Minxue Pan, An Huang, Guoxin Wang, Tian Zhang, and Xuandong Li" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Reinforcement Learning Based ..."</span></small></a>
    </span>

    <span id="issta20main-id155-p-zhangtian"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id155-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id155-p-zhangtian')" 
      >
        <a id="issta20main-id155-p-titlezhangtian" >
          <span style="font-size: 100%">
            Reinforcement Learning Based Curiosity-Driven Testing of Android Applications
          </span>
        </a>
      </span>
      <br />
      Minxue Pan, An Huang, Guoxin Wang, Tian Zhang, and Xuandong Li<br />
      <i><small>(Nanjing University, China)</small></i><br />
      <span id="issta20main-id155-p-abszhangtian" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Mobile applications play an important role in our daily life, while it still remains a challenge to guarantee their correctness. Model-based and systematic approaches have been applied to Android GUI testing. However, they do not show significant advantages over random approaches because of limitations such as imprecise models and poor scalability. In this paper, we propose Q-testing, a reinforcement learning based approach which benefits from both random and model-based approaches to automated testing of Android applications. Q-testing explores the Android apps with a curiosity-driven strategy that utilizes a memory set to record part of previously visited states and guides the testing towards unfamiliar functionalities. A state comparison module, which is a neural network trained by plenty of collected samples, is novelly employed to divide different states at the granularity of functional scenarios. It can determine the reinforcement learning reward in Q-testing and help the curiosity-driven strategy explore different functionalities efficiently. We conduct experiments on 50 open-source applications where Q-testing outperforms the state-of-the-art and state-of-practice Android GUI testing tools in terms of code coverage and fault detection. So far, 22 of our reported faults have been confirmed, among which 7 have been fixed.<br/>
        <br />
        <a href="issta20main-id155-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
          <span style="font-size: 80%; color: blue;"> 
            <img width="20" src="../images/award.svg" alt="" />
            ACM SIGSOFT Distinguished Paper Award</span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Zhang, Yakun  </td>
  <td>
    <span onclick="toggle('issta20main-id141-p-zhangyakun')" title="Learning to Detect Table Clones in Spreadsheets  --  Yakun Zhang, Wensheng Dou, Jiaxin Zhu, Liang Xu, Zhiyong Zhou, Jun Wei, Dan Ye, and Bo Yang" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Learning to Detect Table Clones ..."</span></small></a>
    </span>

    <span id="issta20main-id141-p-zhangyakun"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id141-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id141-p-zhangyakun')" 
      >
        <a id="issta20main-id141-p-titlezhangyakun" >
          <span style="font-size: 100%">
            Learning to Detect Table Clones in Spreadsheets
          </span>
        </a>
      </span>
      <br />
      Yakun Zhang, <a href="http://www.tcse.cn/~wsdou/" target="_blank">Wensheng Dou</a>, Jiaxin Zhu, Liang Xu, Zhiyong Zhou, Jun Wei, Dan Ye, and Bo Yang<br />
      <i><small>(Institute of Software at Chinese Academy of Sciences, China; Jinling Institute of Technology, China; North China University of Technology, China)</small></i><br />
      <span id="issta20main-id141-p-abszhangyakun" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              In order to speed up spreadsheet development productivity, end users can create a spreadsheet table by copying and modifying an existing one. These two tables share the similar computational semantics, and form a table clone. End users may modify the tables in a table clone, e.g., adding new rows and deleting columns, thus introducing structure changes into the table clone. Our empirical study on real-world spreadsheets shows that about 58.5% of table clones involve structure changes. However, existing table clone detection approaches in spreadsheets can only detect table clones with the same structures. Therefore, many table clones with structure changes cannot be detected. <br/>We observe that, although the tables in a table clone may be modified, they usually share the similar structures and formats, e.g., headers, formulas and background colors. Based on this observation, we propose <em>LTC</em> (<em>L</em>earning to detect <em>T</em>able <em>C</em>lones), to automatically detect table clones with or without structure changes. LTC utilizes the structure and format information from labeled table clones and non table clones to train a binary classifier. LTC first identifies tables in spreadsheets, and then uses the trained binary classifier to judge whether every two tables can form a table clone. Our experiments on real-world spreadsheets from the EUSES and Enron corpora show that, LTC can achieve a precision of 97.8% and recall of 92.1% in table clone detection, significantly outperforming the state-of-the-art technique (a precision of 37.5% and recall of 11.1%).<br/>
        <br />
        <a href="issta20main-id141-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Zhang, Yang  </td>
  <td>
    <span onclick="toggle('issta20tool-id21-p-zhangyang')" title="FineLock: Automatically Refactoring Coarse-Grained Locks into Fine-Grained Locks  --  Yang Zhang, Shuai Shao, Juan Zhai, and Shiqing Ma" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20-TOOL: "FineLock: Automatically Refactoring ..."</span></small></a>
    </span>

    <span id="issta20tool-id21-p-zhangyang"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20tool-id21-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20tool-id21-p-zhangyang')" 
      >
        <a id="issta20tool-id21-p-titlezhangyang" >
          <span style="font-size: 100%">
            FineLock: Automatically Refactoring Coarse-Grained Locks into Fine-Grained Locks
          </span>
        </a>
      </span>
      <br />
      Yang Zhang, Shuai Shao, Juan Zhai, and Shiqing Ma<br />
      <i><small>(Hebei University of Science and Technology, China; Rutgers University, USA)</small></i><br />
      <span id="issta20tool-id21-p-abszhangyang" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Lock is a frequently-used synchronization mechanism to enforce exclusive access to a shared resource. However, lock-based concurrent programs are susceptible to lock contention, which leads to low performance and poor scalability. Furthermore, inappropriate granularity of a lock makes lock contention even worse. Compared to coarse-grained lock, fine-grained lock can mitigate lock contention but difficult to use. Converting coarse-grained lock into fine-grained lock manually is not only error-prone and tedious, but also requires a lot of expertise. In this paper, we propose to leverage program analysis techniques and pushdown automaton to automatically covert coarse-grained locks into fine-grained locks to reduce lock contention. We developed a prototype FineLock and evaluates it on 5 projects. The evaluation results demonstrate FineLock can refactor 1,546 locks in an average of 27.6 seconds, including converting 129 coarse-grained locks into fine-grained locks and 1,417 coarse-grained locks into read/write locks. By automatically providing potential refactoring recommendations, our tool saves a lot of efforts for developers.<br/>
        <br />
        <a href="issta20tool-id21-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Zhang, Zhekun  </td>
  <td>
    <span onclick="toggle('issta20main-id159-p-zhangzhekun')" title="Detecting Flaky Tests in Probabilistic and Machine Learning Applications  --  Saikat Dutta, August Shi, Rutvik Choudhary, Zhekun Zhang, Aryaman Jain, and Sasa Misailovic" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Detecting Flaky Tests in Probabilistic ..."</span></small></a>
    </span>

    <span id="issta20main-id159-p-zhangzhekun"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id159-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id159-p-zhangzhekun')" 
      >
        <a id="issta20main-id159-p-titlezhangzhekun" >
          <span style="font-size: 100%">
            Detecting Flaky Tests in Probabilistic and Machine Learning Applications
          </span>
        </a>
      </span>
      <br />
      Saikat Dutta, <a href="http://mir.cs.illinois.edu/~awshi2/" target="_blank">August Shi</a>, Rutvik Choudhary, Zhekun Zhang, Aryaman Jain, and Sasa Misailovic<br />
      <i><small>(University of Illinois at Urbana-Champaign, USA)</small></i><br />
      <span id="issta20main-id159-p-abszhangzhekun" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Probabilistic programming systems and machine learning frameworks like Pyro, PyMC3, TensorFlow, and PyTorch provide scalable and efficient primitives for inference and training. However, such operations are non-deterministic. Hence, it is challenging for developers to write tests for applications that depend on such frameworks, often resulting in flaky tests &#8211; tests which fail non-deterministically when run on the same version of code.  
<br/>

In this paper, we conduct the first extensive study of flaky tests in this domain. In particular, we study the projects that depend on four frameworks: Pyro, PyMC3, TensorFlow-Probability, and  
PyTorch. We identify 75 bug reports/commits that deal with flaky tests, and we categorize the common causes and fixes for them. This study provides developers with useful insights on dealing with flaky tests in this domain.  
<br/>

Motivated by our study, we develop a technique, FLASH, to systematically detect flaky tests due to assertions passing and failing in different runs on the same code. These assertions fail due to differences in the sequence of random numbers in different runs of the same test. FLASH exposes such failures, and our evaluation on 20 projects results in 11 previously-unknown flaky tests that we reported to developers.<br/>
        <br />
        <a href="issta20main-id159-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Zhangzhu, Peitian  </td>
  <td>
    <span onclick="toggle('issta20tool-id8-p-zhangzhupeitian')" title="TauJud: Test Augmentation of Machine Learning in Judicial Documents  --  Zichen Guo, Jiawei Liu, Tieke He, Zhuoyang Li, and Peitian Zhangzhu" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20-TOOL: "TauJud: Test Augmentation ..."</span></small></a>
    </span>

    <span id="issta20tool-id8-p-zhangzhupeitian"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20tool-id8-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20tool-id8-p-zhangzhupeitian')" 
      >
        <a id="issta20tool-id8-p-titlezhangzhupeitian" >
          <span style="font-size: 100%">
            TauJud: Test Augmentation of Machine Learning in Judicial Documents
          </span>
        </a>
      </span>
      <br />
      Zichen Guo, Jiawei Liu, Tieke He, Zhuoyang Li, and Peitian Zhangzhu<br />
      <i><small>(Nanjing University, China)</small></i><br />
      <span id="issta20tool-id8-p-abszhangzhupeitian" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              The booming of big data makes the adoption of machine learning ubiquitous in the legal field. As we all know, a large amount of test data can better reflect the performance of the model, so the test data must be naturally expanded. In order to solve the high cost problem of labeling data in natural language processing, people in the industry have improved the performance of text classification tasks through simple data amplification techniques. However, the data amplification requirements in the judgment documents are interpretable and logical, as observed from CAIL2018 test data with over 200,000 judicial documents. Therefore, we have designed a test augmentation tool called TauJud specifically for generating more effective test data with uniform distribution over time and location for model evaluation and save time in marking data. The demo can be found at https://github.com/governormars/TauJud.<br/>
        <br />
        <a href="issta20tool-id8-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Zhao, Yuan  </td>
  <td>
    <span onclick="toggle('issta20tool-id28-p-zhaoyuan')" title="Test Recommendation System Based on Slicing Coverage Filtering  --  Ruixiang Qian, Yuan Zhao, Duo Men, Yang Feng, Qingkai Shi, Yong Huang, and Zhenyu Chen" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20-TOOL: "Test Recommendation System ..."</span></small></a>
    </span>

    <span id="issta20tool-id28-p-zhaoyuan"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20tool-id28-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20tool-id28-p-zhaoyuan')" 
      >
        <a id="issta20tool-id28-p-titlezhaoyuan" >
          <span style="font-size: 100%">
            Test Recommendation System Based on Slicing Coverage Filtering
          </span>
        </a>
      </span>
      <br />
      Ruixiang Qian, Yuan Zhao, Duo Men, Yang Feng, Qingkai Shi, Yong Huang, and <a href="http://software.nju.edu.cn/zychen/" target="_blank">Zhenyu Chen</a><br />
      <i><small>(Nanjing University, China; Hong Kong University of Science and Technology, China; Mooctest, China)</small></i><br />
      <span id="issta20tool-id28-p-abszhaoyuan" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Software testing plays a crucial role in software lifecycle. As a basic approach of software testing, unit testing is one of the necessary skills for software practitioners. Since testers are required to understand the inner code of the software under test(SUT) while writing a test case, testers usually need to learn how to detect the bug within SUT effectively. When novice programmers started to learn writing unit tests, they will generally watch a video lesson or reading unit tests written by others. These learning approaches are either time-consuming or too hard for a novice. To solve these problems, we developed a system, named TeSRS, to assist novice programmers to learn unit testing. TeSRS is a test recommendation system which can effectively assist test novice in learning unit testing. Utilizing program slice technique, TeSRS has gotten an enormous amount of test snippets from superior crowdsourcing test scripts. Depending on these test snippets, TeSRS provides novices a easier way for unit test learning. To sum up, TeSRS can help test novices (1) obtain high level design ideas of unit test case and (2) improve capabilities(e.g. branch coverage rate and mutation coverage rate) of their test scripts. TeSRS has built a scalable corpus composed of over 8000 test snippets from more than 25 test problems. Its stable performance shows effectiveness in unit test learning. <br/>Demo video can be found at <a>https://youtu.be/xvrLdvU8zFA</a><br/>
        <br />
        <a href="issta20tool-id28-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
      <a href="https://www.youtube.com/watch?v=xvrLdvU8zFA"><img width="15" src="../images/video.png" alt="" /><span style="font-size: 90%"> Video</span></a>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Zhong, Hua  </td>
  <td>
    <span onclick="toggle('issta20main-id139-p-zhonghua')" title="Detecting Cache-Related Bugs in Spark Applications  --  Hui Li, Dong Wang, Tianze Huang, Yu Gao, Wensheng Dou, Lijie Xu, Wei Wang, Jun Wei, and Hua Zhong" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Detecting Cache-Related Bugs ..."</span></small></a>
    </span>

    <span id="issta20main-id139-p-zhonghua"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id139-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id139-p-zhonghua')" 
      >
        <a id="issta20main-id139-p-titlezhonghua" >
          <span style="font-size: 100%">
            Detecting Cache-Related Bugs in Spark Applications
          </span>
        </a>
      </span>
      <br />
      Hui Li, Dong Wang, Tianze Huang, Yu Gao, <a href="http://www.tcse.cn/~wsdou/" target="_blank">Wensheng Dou</a>, Lijie Xu, Wei Wang, Jun Wei, and Hua Zhong<br />
      <i><small>(Institute of Software at Chinese Academy of Sciences, China; University of Chinese Academy of Sciences, China; Beijing University of Posts and Telecommunications, China)</small></i><br />
      <span id="issta20main-id139-p-abszhonghua" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              Apache Spark has been widely used to build big data applications. Spark utilizes the abstraction of Resilient Distributed Dataset (RDD) to store and retrieve large-scale data. To reduce duplicate computation of an RDD, Spark can cache the RDD in memory and then reuse it later, thus improving performance. Spark relies on application developers to enforce caching decisions by using <em>persist</em>() and <em>unpersist</em>() APIs, e.g., <em>which</em> RDD is persisted and <em>when</em> the RDD is persisted / unpersisted. Incorrect RDD caching decisions can cause duplicate computations, or waste precious memory resource, thus introducing serious performance degradation in Spark applications. In this paper, we propose <em>CacheCheck</em>, to automatically detect cache-related bugs in Spark applications. We summarize six cache-related bug patterns in Spark applications, and then dynamically detect cache-related bugs by analyzing the execution traces of Spark applications. We evaluate CacheCheck on six real-world Spark applications. The experimental result shows that CacheCheck detects 72 previously unknown cache-related bugs, and 28 of them have been fixed by developers.<br/>
        <br />
        <a href="issta20main-id139-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_available_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Available</span></a>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_evaluated_reusable_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Reusable</span></a>
          <a href="https://www.acm.org/publications/policies/artifact-review-badging">
            <img width="20" src="../images/acm_artifacts_evaluated_functional_dl.jpg" alt="" />
            <span style="font-size: 80%"> Artifacts Functional</span></a>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Zhou, Yajin  </td>
  <td>
    <span onclick="toggle('issta20main-id47-p-zhouyajin')" title="An Empirical Study on ARM Disassembly Tools  --  Muhui Jiang, Yajin Zhou, Xiapu Luo, Ruoyu Wang, Yang Liu, and Kui Ren" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "An Empirical Study on ARM ..."</span></small></a>
    </span>

    <span id="issta20main-id47-p-zhouyajin"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id47-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id47-p-zhouyajin')" 
      >
        <a id="issta20main-id47-p-titlezhouyajin" >
          <span style="font-size: 100%">
            An Empirical Study on ARM Disassembly Tools
          </span>
        </a>
      </span>
      <br />
      Muhui Jiang, Yajin Zhou, <a href="http://www4.comp.polyu.edu.hk/~csxluo/" target="_blank">Xiapu Luo</a>, Ruoyu Wang, <a href="http://www.ntu.edu.sg/home/yangliu/" target="_blank">Yang Liu</a>, and Kui Ren<br />
      <i><small>(Hong Kong Polytechnic University, China; Zhejiang University, China; Arizona State University, USA; Nanyang Technological University, Singapore)</small></i><br />
      <span id="issta20main-id47-p-abszhouyajin" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              With the increasing popularity of embedded devices, ARM is becoming the dominant architecture for them. In the meanwhile, there is a pressing need to perform security assessments for these devices. Due to different types of peripherals, it is challenging to dynamically run the firmware of these devices in an emulated environment. Therefore, the static analysis is still commonly used. Existing work usually leverages off-the-shelf tools to disassemble stripped ARM binaries and (implicitly) assume that reliable disassembling binaries and function recognition are solved problems. However, whether this assumption really holds is unknown. <br/>In this paper, we conduct the first comprehensive study on ARM disassembly tools. Specifically, we build 1,896 ARM binaries (including 248 obfuscated ones) with different compilers, compiling options, and obfuscation methods. We then evaluate them using eight state-of-the-art ARM disassembly tools (including both commercial and noncommercial ones) on their capabilities to locate instructions and function boundaries. These two are fundamental ones, which are leveraged to build other primitives. Our work reveals some observations that have not been systematically summarized and/or confirmed. For instance, we find that the existence of both ARM and Thumb instruction sets, and the reuse of the BL instruction for both function calls and branches bring serious challenges to disassembly tools. Our evaluation sheds light on the limitations of state-of-the-art disassembly tools and points out potential directions for improvement. To engage the community, we release the data set, and the related scripts at https://github.com/valour01/arm_disasssembler_study.<br/>
        <br />
        <a href="issta20main-id47-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Zhou, Zhiyong  </td>
  <td>
    <span onclick="toggle('issta20main-id141-p-zhouzhiyong')" title="Learning to Detect Table Clones in Spreadsheets  --  Yakun Zhang, Wensheng Dou, Jiaxin Zhu, Liang Xu, Zhiyong Zhou, Jun Wei, Dan Ye, and Bo Yang" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Learning to Detect Table Clones ..."</span></small></a>
    </span>

    <span id="issta20main-id141-p-zhouzhiyong"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id141-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id141-p-zhouzhiyong')" 
      >
        <a id="issta20main-id141-p-titlezhouzhiyong" >
          <span style="font-size: 100%">
            Learning to Detect Table Clones in Spreadsheets
          </span>
        </a>
      </span>
      <br />
      Yakun Zhang, <a href="http://www.tcse.cn/~wsdou/" target="_blank">Wensheng Dou</a>, Jiaxin Zhu, Liang Xu, Zhiyong Zhou, Jun Wei, Dan Ye, and Bo Yang<br />
      <i><small>(Institute of Software at Chinese Academy of Sciences, China; Jinling Institute of Technology, China; North China University of Technology, China)</small></i><br />
      <span id="issta20main-id141-p-abszhouzhiyong" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              In order to speed up spreadsheet development productivity, end users can create a spreadsheet table by copying and modifying an existing one. These two tables share the similar computational semantics, and form a table clone. End users may modify the tables in a table clone, e.g., adding new rows and deleting columns, thus introducing structure changes into the table clone. Our empirical study on real-world spreadsheets shows that about 58.5% of table clones involve structure changes. However, existing table clone detection approaches in spreadsheets can only detect table clones with the same structures. Therefore, many table clones with structure changes cannot be detected. <br/>We observe that, although the tables in a table clone may be modified, they usually share the similar structures and formats, e.g., headers, formulas and background colors. Based on this observation, we propose <em>LTC</em> (<em>L</em>earning to detect <em>T</em>able <em>C</em>lones), to automatically detect table clones with or without structure changes. LTC utilizes the structure and format information from labeled table clones and non table clones to train a binary classifier. LTC first identifies tables in spreadsheets, and then uses the trained binary classifier to judge whether every two tables can form a table clone. Our experiments on real-world spreadsheets from the EUSES and Enron corpora show that, LTC can achieve a precision of 97.8% and recall of 92.1% in table clone detection, significantly outperforming the state-of-the-art technique (a precision of 37.5% and recall of 11.1%).<br/>
        <br />
        <a href="issta20main-id141-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>

<tr style="vertical-align: top;">
  <td>  </td>
  <td style="width: 200px;">Zhu, Jiaxin  </td>
  <td>
    <span onclick="toggle('issta20main-id141-p-zhujiaxin')" title="Learning to Detect Table Clones in Spreadsheets  --  Yakun Zhang, Wensheng Dou, Jiaxin Zhu, Liang Xu, Zhiyong Zhou, Jun Wei, Dan Ye, and Bo Yang" > 
      <img style="border: 0;" width="16" src="../images/text.png" alt="" /> 
      <a><small><span style="">ISSTA &#39;20: "Learning to Detect Table Clones ..."</span></small></a>
    </span>

    <span id="issta20main-id141-p-zhujiaxin"
          style="display:none; border:1ex solid transparent;" >
      <a href="issta20main-id141-p.pdf"><img width="16" src="../images/pdf.png" alt="" /></a>
      <span
        onclick="toggle('issta20main-id141-p-zhujiaxin')" 
      >
        <a id="issta20main-id141-p-titlezhujiaxin" >
          <span style="font-size: 100%">
            Learning to Detect Table Clones in Spreadsheets
          </span>
        </a>
      </span>
      <br />
      Yakun Zhang, <a href="http://www.tcse.cn/~wsdou/" target="_blank">Wensheng Dou</a>, Jiaxin Zhu, Liang Xu, Zhiyong Zhou, Jun Wei, Dan Ye, and Bo Yang<br />
      <i><small>(Institute of Software at Chinese Academy of Sciences, China; Jinling Institute of Technology, China; North China University of Technology, China)</small></i><br />
      <span id="issta20main-id141-p-abszhujiaxin" style="display:block; border:1ex solid transparent; font-size: smaller;" >
              In order to speed up spreadsheet development productivity, end users can create a spreadsheet table by copying and modifying an existing one. These two tables share the similar computational semantics, and form a table clone. End users may modify the tables in a table clone, e.g., adding new rows and deleting columns, thus introducing structure changes into the table clone. Our empirical study on real-world spreadsheets shows that about 58.5% of table clones involve structure changes. However, existing table clone detection approaches in spreadsheets can only detect table clones with the same structures. Therefore, many table clones with structure changes cannot be detected. <br/>We observe that, although the tables in a table clone may be modified, they usually share the similar structures and formats, e.g., headers, formulas and background colors. Based on this observation, we propose <em>LTC</em> (<em>L</em>earning to detect <em>T</em>able <em>C</em>lones), to automatically detect table clones with or without structure changes. LTC utilizes the structure and format information from labeled table clones and non table clones to train a binary classifier. LTC first identifies tables in spreadsheets, and then uses the trained binary classifier to judge whether every two tables can form a table clone. Our experiments on real-world spreadsheets from the EUSES and Enron corpora show that, LTC can achieve a precision of 97.8% and recall of 92.1% in table clone detection, significantly outperforming the state-of-the-art technique (a precision of 37.5% and recall of 11.1%).<br/>
        <br />
        <a href="issta20main-id141-p.pdf"><img width="16" src="../images/pdf.png" alt="" /> Full Document</a><br />
      </span>
    </span>
  </td>
</tr>
</table>
<p><small><small>223 authors</small></small></p>
<!-- BEGIN FOOTER -->

  </body>
</html>
<!-- END FOOTER -->
